
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model patients
 * 
 */
export type patients = $Result.DefaultSelection<Prisma.$patientsPayload>
/**
 * Model consultations
 * 
 */
export type consultations = $Result.DefaultSelection<Prisma.$consultationsPayload>
/**
 * Model vital_signs
 * 
 */
export type vital_signs = $Result.DefaultSelection<Prisma.$vital_signsPayload>
/**
 * Model lab_requests
 * 
 */
export type lab_requests = $Result.DefaultSelection<Prisma.$lab_requestsPayload>
/**
 * Model lab_results
 * 
 */
export type lab_results = $Result.DefaultSelection<Prisma.$lab_resultsPayload>
/**
 * Model prescriptions
 * 
 */
export type prescriptions = $Result.DefaultSelection<Prisma.$prescriptionsPayload>
/**
 * Model queue_entries
 * 
 */
export type queue_entries = $Result.DefaultSelection<Prisma.$queue_entriesPayload>
/**
 * Model appointments
 * 
 */
export type appointments = $Result.DefaultSelection<Prisma.$appointmentsPayload>
/**
 * Model admissions
 * 
 */
export type admissions = $Result.DefaultSelection<Prisma.$admissionsPayload>
/**
 * Model drugs
 * 
 */
export type drugs = $Result.DefaultSelection<Prisma.$drugsPayload>
/**
 * Model lab_tests
 * 
 */
export type lab_tests = $Result.DefaultSelection<Prisma.$lab_testsPayload>
/**
 * Model announcements
 * 
 */
export type announcements = $Result.DefaultSelection<Prisma.$announcementsPayload>
/**
 * Model voice_notes
 * 
 */
export type voice_notes = $Result.DefaultSelection<Prisma.$voice_notesPayload>
/**
 * Model medical_certificates
 * 
 */
export type medical_certificates = $Result.DefaultSelection<Prisma.$medical_certificatesPayload>
/**
 * Model referral_letters
 * 
 */
export type referral_letters = $Result.DefaultSelection<Prisma.$referral_lettersPayload>
/**
 * Model discharge_summaries
 * 
 */
export type discharge_summaries = $Result.DefaultSelection<Prisma.$discharge_summariesPayload>
/**
 * Model audit_logs
 * 
 */
export type audit_logs = $Result.DefaultSelection<Prisma.$audit_logsPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patients`: Exposes CRUD operations for the **patients** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patients.findMany()
    * ```
    */
  get patients(): Prisma.patientsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.consultations`: Exposes CRUD operations for the **consultations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consultations
    * const consultations = await prisma.consultations.findMany()
    * ```
    */
  get consultations(): Prisma.consultationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vital_signs`: Exposes CRUD operations for the **vital_signs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vital_signs
    * const vital_signs = await prisma.vital_signs.findMany()
    * ```
    */
  get vital_signs(): Prisma.vital_signsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lab_requests`: Exposes CRUD operations for the **lab_requests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lab_requests
    * const lab_requests = await prisma.lab_requests.findMany()
    * ```
    */
  get lab_requests(): Prisma.lab_requestsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lab_results`: Exposes CRUD operations for the **lab_results** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lab_results
    * const lab_results = await prisma.lab_results.findMany()
    * ```
    */
  get lab_results(): Prisma.lab_resultsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prescriptions`: Exposes CRUD operations for the **prescriptions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prescriptions
    * const prescriptions = await prisma.prescriptions.findMany()
    * ```
    */
  get prescriptions(): Prisma.prescriptionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.queue_entries`: Exposes CRUD operations for the **queue_entries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Queue_entries
    * const queue_entries = await prisma.queue_entries.findMany()
    * ```
    */
  get queue_entries(): Prisma.queue_entriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointments`: Exposes CRUD operations for the **appointments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointments.findMany()
    * ```
    */
  get appointments(): Prisma.appointmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admissions`: Exposes CRUD operations for the **admissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admissions
    * const admissions = await prisma.admissions.findMany()
    * ```
    */
  get admissions(): Prisma.admissionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.drugs`: Exposes CRUD operations for the **drugs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drugs
    * const drugs = await prisma.drugs.findMany()
    * ```
    */
  get drugs(): Prisma.drugsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lab_tests`: Exposes CRUD operations for the **lab_tests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lab_tests
    * const lab_tests = await prisma.lab_tests.findMany()
    * ```
    */
  get lab_tests(): Prisma.lab_testsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.announcements`: Exposes CRUD operations for the **announcements** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcements.findMany()
    * ```
    */
  get announcements(): Prisma.announcementsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.voice_notes`: Exposes CRUD operations for the **voice_notes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Voice_notes
    * const voice_notes = await prisma.voice_notes.findMany()
    * ```
    */
  get voice_notes(): Prisma.voice_notesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medical_certificates`: Exposes CRUD operations for the **medical_certificates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medical_certificates
    * const medical_certificates = await prisma.medical_certificates.findMany()
    * ```
    */
  get medical_certificates(): Prisma.medical_certificatesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referral_letters`: Exposes CRUD operations for the **referral_letters** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referral_letters
    * const referral_letters = await prisma.referral_letters.findMany()
    * ```
    */
  get referral_letters(): Prisma.referral_lettersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.discharge_summaries`: Exposes CRUD operations for the **discharge_summaries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Discharge_summaries
    * const discharge_summaries = await prisma.discharge_summaries.findMany()
    * ```
    */
  get discharge_summaries(): Prisma.discharge_summariesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.audit_logs`: Exposes CRUD operations for the **audit_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Audit_logs
    * const audit_logs = await prisma.audit_logs.findMany()
    * ```
    */
  get audit_logs(): Prisma.audit_logsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.4.0
   * Query Engine version: ab56fe763f921d033a6c195e7ddeb3e255bdbb57
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    users: 'users',
    patients: 'patients',
    consultations: 'consultations',
    vital_signs: 'vital_signs',
    lab_requests: 'lab_requests',
    lab_results: 'lab_results',
    prescriptions: 'prescriptions',
    queue_entries: 'queue_entries',
    appointments: 'appointments',
    admissions: 'admissions',
    drugs: 'drugs',
    lab_tests: 'lab_tests',
    announcements: 'announcements',
    voice_notes: 'voice_notes',
    medical_certificates: 'medical_certificates',
    referral_letters: 'referral_letters',
    discharge_summaries: 'discharge_summaries',
    audit_logs: 'audit_logs'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "users" | "patients" | "consultations" | "vital_signs" | "lab_requests" | "lab_results" | "prescriptions" | "queue_entries" | "appointments" | "admissions" | "drugs" | "lab_tests" | "announcements" | "voice_notes" | "medical_certificates" | "referral_letters" | "discharge_summaries" | "audit_logs"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      patients: {
        payload: Prisma.$patientsPayload<ExtArgs>
        fields: Prisma.patientsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.patientsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.patientsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          findFirst: {
            args: Prisma.patientsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.patientsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          findMany: {
            args: Prisma.patientsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>[]
          }
          create: {
            args: Prisma.patientsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          createMany: {
            args: Prisma.patientsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.patientsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>[]
          }
          delete: {
            args: Prisma.patientsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          update: {
            args: Prisma.patientsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          deleteMany: {
            args: Prisma.patientsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.patientsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.patientsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>[]
          }
          upsert: {
            args: Prisma.patientsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          aggregate: {
            args: Prisma.PatientsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatients>
          }
          groupBy: {
            args: Prisma.patientsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientsGroupByOutputType>[]
          }
          count: {
            args: Prisma.patientsCountArgs<ExtArgs>
            result: $Utils.Optional<PatientsCountAggregateOutputType> | number
          }
        }
      }
      consultations: {
        payload: Prisma.$consultationsPayload<ExtArgs>
        fields: Prisma.consultationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.consultationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.consultationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultationsPayload>
          }
          findFirst: {
            args: Prisma.consultationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.consultationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultationsPayload>
          }
          findMany: {
            args: Prisma.consultationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultationsPayload>[]
          }
          create: {
            args: Prisma.consultationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultationsPayload>
          }
          createMany: {
            args: Prisma.consultationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.consultationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultationsPayload>[]
          }
          delete: {
            args: Prisma.consultationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultationsPayload>
          }
          update: {
            args: Prisma.consultationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultationsPayload>
          }
          deleteMany: {
            args: Prisma.consultationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.consultationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.consultationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultationsPayload>[]
          }
          upsert: {
            args: Prisma.consultationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultationsPayload>
          }
          aggregate: {
            args: Prisma.ConsultationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsultations>
          }
          groupBy: {
            args: Prisma.consultationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsultationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.consultationsCountArgs<ExtArgs>
            result: $Utils.Optional<ConsultationsCountAggregateOutputType> | number
          }
        }
      }
      vital_signs: {
        payload: Prisma.$vital_signsPayload<ExtArgs>
        fields: Prisma.vital_signsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vital_signsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vital_signsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vital_signsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vital_signsPayload>
          }
          findFirst: {
            args: Prisma.vital_signsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vital_signsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vital_signsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vital_signsPayload>
          }
          findMany: {
            args: Prisma.vital_signsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vital_signsPayload>[]
          }
          create: {
            args: Prisma.vital_signsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vital_signsPayload>
          }
          createMany: {
            args: Prisma.vital_signsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.vital_signsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vital_signsPayload>[]
          }
          delete: {
            args: Prisma.vital_signsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vital_signsPayload>
          }
          update: {
            args: Prisma.vital_signsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vital_signsPayload>
          }
          deleteMany: {
            args: Prisma.vital_signsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.vital_signsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.vital_signsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vital_signsPayload>[]
          }
          upsert: {
            args: Prisma.vital_signsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vital_signsPayload>
          }
          aggregate: {
            args: Prisma.Vital_signsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVital_signs>
          }
          groupBy: {
            args: Prisma.vital_signsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Vital_signsGroupByOutputType>[]
          }
          count: {
            args: Prisma.vital_signsCountArgs<ExtArgs>
            result: $Utils.Optional<Vital_signsCountAggregateOutputType> | number
          }
        }
      }
      lab_requests: {
        payload: Prisma.$lab_requestsPayload<ExtArgs>
        fields: Prisma.lab_requestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.lab_requestsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_requestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.lab_requestsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_requestsPayload>
          }
          findFirst: {
            args: Prisma.lab_requestsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_requestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.lab_requestsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_requestsPayload>
          }
          findMany: {
            args: Prisma.lab_requestsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_requestsPayload>[]
          }
          create: {
            args: Prisma.lab_requestsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_requestsPayload>
          }
          createMany: {
            args: Prisma.lab_requestsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.lab_requestsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_requestsPayload>[]
          }
          delete: {
            args: Prisma.lab_requestsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_requestsPayload>
          }
          update: {
            args: Prisma.lab_requestsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_requestsPayload>
          }
          deleteMany: {
            args: Prisma.lab_requestsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.lab_requestsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.lab_requestsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_requestsPayload>[]
          }
          upsert: {
            args: Prisma.lab_requestsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_requestsPayload>
          }
          aggregate: {
            args: Prisma.Lab_requestsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLab_requests>
          }
          groupBy: {
            args: Prisma.lab_requestsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Lab_requestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.lab_requestsCountArgs<ExtArgs>
            result: $Utils.Optional<Lab_requestsCountAggregateOutputType> | number
          }
        }
      }
      lab_results: {
        payload: Prisma.$lab_resultsPayload<ExtArgs>
        fields: Prisma.lab_resultsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.lab_resultsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_resultsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.lab_resultsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_resultsPayload>
          }
          findFirst: {
            args: Prisma.lab_resultsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_resultsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.lab_resultsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_resultsPayload>
          }
          findMany: {
            args: Prisma.lab_resultsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_resultsPayload>[]
          }
          create: {
            args: Prisma.lab_resultsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_resultsPayload>
          }
          createMany: {
            args: Prisma.lab_resultsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.lab_resultsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_resultsPayload>[]
          }
          delete: {
            args: Prisma.lab_resultsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_resultsPayload>
          }
          update: {
            args: Prisma.lab_resultsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_resultsPayload>
          }
          deleteMany: {
            args: Prisma.lab_resultsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.lab_resultsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.lab_resultsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_resultsPayload>[]
          }
          upsert: {
            args: Prisma.lab_resultsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_resultsPayload>
          }
          aggregate: {
            args: Prisma.Lab_resultsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLab_results>
          }
          groupBy: {
            args: Prisma.lab_resultsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Lab_resultsGroupByOutputType>[]
          }
          count: {
            args: Prisma.lab_resultsCountArgs<ExtArgs>
            result: $Utils.Optional<Lab_resultsCountAggregateOutputType> | number
          }
        }
      }
      prescriptions: {
        payload: Prisma.$prescriptionsPayload<ExtArgs>
        fields: Prisma.prescriptionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.prescriptionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescriptionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.prescriptionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescriptionsPayload>
          }
          findFirst: {
            args: Prisma.prescriptionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescriptionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.prescriptionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescriptionsPayload>
          }
          findMany: {
            args: Prisma.prescriptionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescriptionsPayload>[]
          }
          create: {
            args: Prisma.prescriptionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescriptionsPayload>
          }
          createMany: {
            args: Prisma.prescriptionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.prescriptionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescriptionsPayload>[]
          }
          delete: {
            args: Prisma.prescriptionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescriptionsPayload>
          }
          update: {
            args: Prisma.prescriptionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescriptionsPayload>
          }
          deleteMany: {
            args: Prisma.prescriptionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.prescriptionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.prescriptionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescriptionsPayload>[]
          }
          upsert: {
            args: Prisma.prescriptionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prescriptionsPayload>
          }
          aggregate: {
            args: Prisma.PrescriptionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescriptions>
          }
          groupBy: {
            args: Prisma.prescriptionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.prescriptionsCountArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionsCountAggregateOutputType> | number
          }
        }
      }
      queue_entries: {
        payload: Prisma.$queue_entriesPayload<ExtArgs>
        fields: Prisma.queue_entriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.queue_entriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$queue_entriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.queue_entriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$queue_entriesPayload>
          }
          findFirst: {
            args: Prisma.queue_entriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$queue_entriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.queue_entriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$queue_entriesPayload>
          }
          findMany: {
            args: Prisma.queue_entriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$queue_entriesPayload>[]
          }
          create: {
            args: Prisma.queue_entriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$queue_entriesPayload>
          }
          createMany: {
            args: Prisma.queue_entriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.queue_entriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$queue_entriesPayload>[]
          }
          delete: {
            args: Prisma.queue_entriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$queue_entriesPayload>
          }
          update: {
            args: Prisma.queue_entriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$queue_entriesPayload>
          }
          deleteMany: {
            args: Prisma.queue_entriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.queue_entriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.queue_entriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$queue_entriesPayload>[]
          }
          upsert: {
            args: Prisma.queue_entriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$queue_entriesPayload>
          }
          aggregate: {
            args: Prisma.Queue_entriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQueue_entries>
          }
          groupBy: {
            args: Prisma.queue_entriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Queue_entriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.queue_entriesCountArgs<ExtArgs>
            result: $Utils.Optional<Queue_entriesCountAggregateOutputType> | number
          }
        }
      }
      appointments: {
        payload: Prisma.$appointmentsPayload<ExtArgs>
        fields: Prisma.appointmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.appointmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.appointmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          findFirst: {
            args: Prisma.appointmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.appointmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          findMany: {
            args: Prisma.appointmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>[]
          }
          create: {
            args: Prisma.appointmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          createMany: {
            args: Prisma.appointmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.appointmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>[]
          }
          delete: {
            args: Prisma.appointmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          update: {
            args: Prisma.appointmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          deleteMany: {
            args: Prisma.appointmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.appointmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.appointmentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>[]
          }
          upsert: {
            args: Prisma.appointmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          aggregate: {
            args: Prisma.AppointmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointments>
          }
          groupBy: {
            args: Prisma.appointmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.appointmentsCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentsCountAggregateOutputType> | number
          }
        }
      }
      admissions: {
        payload: Prisma.$admissionsPayload<ExtArgs>
        fields: Prisma.admissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.admissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.admissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admissionsPayload>
          }
          findFirst: {
            args: Prisma.admissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.admissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admissionsPayload>
          }
          findMany: {
            args: Prisma.admissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admissionsPayload>[]
          }
          create: {
            args: Prisma.admissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admissionsPayload>
          }
          createMany: {
            args: Prisma.admissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.admissionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admissionsPayload>[]
          }
          delete: {
            args: Prisma.admissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admissionsPayload>
          }
          update: {
            args: Prisma.admissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admissionsPayload>
          }
          deleteMany: {
            args: Prisma.admissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.admissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.admissionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admissionsPayload>[]
          }
          upsert: {
            args: Prisma.admissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admissionsPayload>
          }
          aggregate: {
            args: Prisma.AdmissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmissions>
          }
          groupBy: {
            args: Prisma.admissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdmissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.admissionsCountArgs<ExtArgs>
            result: $Utils.Optional<AdmissionsCountAggregateOutputType> | number
          }
        }
      }
      drugs: {
        payload: Prisma.$drugsPayload<ExtArgs>
        fields: Prisma.drugsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.drugsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drugsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.drugsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drugsPayload>
          }
          findFirst: {
            args: Prisma.drugsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drugsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.drugsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drugsPayload>
          }
          findMany: {
            args: Prisma.drugsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drugsPayload>[]
          }
          create: {
            args: Prisma.drugsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drugsPayload>
          }
          createMany: {
            args: Prisma.drugsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.drugsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drugsPayload>[]
          }
          delete: {
            args: Prisma.drugsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drugsPayload>
          }
          update: {
            args: Prisma.drugsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drugsPayload>
          }
          deleteMany: {
            args: Prisma.drugsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.drugsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.drugsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drugsPayload>[]
          }
          upsert: {
            args: Prisma.drugsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drugsPayload>
          }
          aggregate: {
            args: Prisma.DrugsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDrugs>
          }
          groupBy: {
            args: Prisma.drugsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DrugsGroupByOutputType>[]
          }
          count: {
            args: Prisma.drugsCountArgs<ExtArgs>
            result: $Utils.Optional<DrugsCountAggregateOutputType> | number
          }
        }
      }
      lab_tests: {
        payload: Prisma.$lab_testsPayload<ExtArgs>
        fields: Prisma.lab_testsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.lab_testsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_testsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.lab_testsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_testsPayload>
          }
          findFirst: {
            args: Prisma.lab_testsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_testsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.lab_testsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_testsPayload>
          }
          findMany: {
            args: Prisma.lab_testsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_testsPayload>[]
          }
          create: {
            args: Prisma.lab_testsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_testsPayload>
          }
          createMany: {
            args: Prisma.lab_testsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.lab_testsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_testsPayload>[]
          }
          delete: {
            args: Prisma.lab_testsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_testsPayload>
          }
          update: {
            args: Prisma.lab_testsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_testsPayload>
          }
          deleteMany: {
            args: Prisma.lab_testsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.lab_testsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.lab_testsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_testsPayload>[]
          }
          upsert: {
            args: Prisma.lab_testsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lab_testsPayload>
          }
          aggregate: {
            args: Prisma.Lab_testsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLab_tests>
          }
          groupBy: {
            args: Prisma.lab_testsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Lab_testsGroupByOutputType>[]
          }
          count: {
            args: Prisma.lab_testsCountArgs<ExtArgs>
            result: $Utils.Optional<Lab_testsCountAggregateOutputType> | number
          }
        }
      }
      announcements: {
        payload: Prisma.$announcementsPayload<ExtArgs>
        fields: Prisma.announcementsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.announcementsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.announcementsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          findFirst: {
            args: Prisma.announcementsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.announcementsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          findMany: {
            args: Prisma.announcementsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>[]
          }
          create: {
            args: Prisma.announcementsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          createMany: {
            args: Prisma.announcementsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.announcementsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>[]
          }
          delete: {
            args: Prisma.announcementsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          update: {
            args: Prisma.announcementsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          deleteMany: {
            args: Prisma.announcementsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.announcementsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.announcementsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>[]
          }
          upsert: {
            args: Prisma.announcementsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$announcementsPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnouncements>
          }
          groupBy: {
            args: Prisma.announcementsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementsGroupByOutputType>[]
          }
          count: {
            args: Prisma.announcementsCountArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementsCountAggregateOutputType> | number
          }
        }
      }
      voice_notes: {
        payload: Prisma.$voice_notesPayload<ExtArgs>
        fields: Prisma.voice_notesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.voice_notesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voice_notesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.voice_notesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voice_notesPayload>
          }
          findFirst: {
            args: Prisma.voice_notesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voice_notesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.voice_notesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voice_notesPayload>
          }
          findMany: {
            args: Prisma.voice_notesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voice_notesPayload>[]
          }
          create: {
            args: Prisma.voice_notesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voice_notesPayload>
          }
          createMany: {
            args: Prisma.voice_notesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.voice_notesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voice_notesPayload>[]
          }
          delete: {
            args: Prisma.voice_notesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voice_notesPayload>
          }
          update: {
            args: Prisma.voice_notesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voice_notesPayload>
          }
          deleteMany: {
            args: Prisma.voice_notesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.voice_notesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.voice_notesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voice_notesPayload>[]
          }
          upsert: {
            args: Prisma.voice_notesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voice_notesPayload>
          }
          aggregate: {
            args: Prisma.Voice_notesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoice_notes>
          }
          groupBy: {
            args: Prisma.voice_notesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Voice_notesGroupByOutputType>[]
          }
          count: {
            args: Prisma.voice_notesCountArgs<ExtArgs>
            result: $Utils.Optional<Voice_notesCountAggregateOutputType> | number
          }
        }
      }
      medical_certificates: {
        payload: Prisma.$medical_certificatesPayload<ExtArgs>
        fields: Prisma.medical_certificatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.medical_certificatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_certificatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.medical_certificatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_certificatesPayload>
          }
          findFirst: {
            args: Prisma.medical_certificatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_certificatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.medical_certificatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_certificatesPayload>
          }
          findMany: {
            args: Prisma.medical_certificatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_certificatesPayload>[]
          }
          create: {
            args: Prisma.medical_certificatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_certificatesPayload>
          }
          createMany: {
            args: Prisma.medical_certificatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.medical_certificatesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_certificatesPayload>[]
          }
          delete: {
            args: Prisma.medical_certificatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_certificatesPayload>
          }
          update: {
            args: Prisma.medical_certificatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_certificatesPayload>
          }
          deleteMany: {
            args: Prisma.medical_certificatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.medical_certificatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.medical_certificatesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_certificatesPayload>[]
          }
          upsert: {
            args: Prisma.medical_certificatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_certificatesPayload>
          }
          aggregate: {
            args: Prisma.Medical_certificatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedical_certificates>
          }
          groupBy: {
            args: Prisma.medical_certificatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Medical_certificatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.medical_certificatesCountArgs<ExtArgs>
            result: $Utils.Optional<Medical_certificatesCountAggregateOutputType> | number
          }
        }
      }
      referral_letters: {
        payload: Prisma.$referral_lettersPayload<ExtArgs>
        fields: Prisma.referral_lettersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.referral_lettersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_lettersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.referral_lettersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_lettersPayload>
          }
          findFirst: {
            args: Prisma.referral_lettersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_lettersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.referral_lettersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_lettersPayload>
          }
          findMany: {
            args: Prisma.referral_lettersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_lettersPayload>[]
          }
          create: {
            args: Prisma.referral_lettersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_lettersPayload>
          }
          createMany: {
            args: Prisma.referral_lettersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.referral_lettersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_lettersPayload>[]
          }
          delete: {
            args: Prisma.referral_lettersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_lettersPayload>
          }
          update: {
            args: Prisma.referral_lettersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_lettersPayload>
          }
          deleteMany: {
            args: Prisma.referral_lettersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.referral_lettersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.referral_lettersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_lettersPayload>[]
          }
          upsert: {
            args: Prisma.referral_lettersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referral_lettersPayload>
          }
          aggregate: {
            args: Prisma.Referral_lettersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral_letters>
          }
          groupBy: {
            args: Prisma.referral_lettersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Referral_lettersGroupByOutputType>[]
          }
          count: {
            args: Prisma.referral_lettersCountArgs<ExtArgs>
            result: $Utils.Optional<Referral_lettersCountAggregateOutputType> | number
          }
        }
      }
      discharge_summaries: {
        payload: Prisma.$discharge_summariesPayload<ExtArgs>
        fields: Prisma.discharge_summariesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.discharge_summariesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discharge_summariesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.discharge_summariesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discharge_summariesPayload>
          }
          findFirst: {
            args: Prisma.discharge_summariesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discharge_summariesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.discharge_summariesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discharge_summariesPayload>
          }
          findMany: {
            args: Prisma.discharge_summariesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discharge_summariesPayload>[]
          }
          create: {
            args: Prisma.discharge_summariesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discharge_summariesPayload>
          }
          createMany: {
            args: Prisma.discharge_summariesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.discharge_summariesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discharge_summariesPayload>[]
          }
          delete: {
            args: Prisma.discharge_summariesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discharge_summariesPayload>
          }
          update: {
            args: Prisma.discharge_summariesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discharge_summariesPayload>
          }
          deleteMany: {
            args: Prisma.discharge_summariesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.discharge_summariesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.discharge_summariesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discharge_summariesPayload>[]
          }
          upsert: {
            args: Prisma.discharge_summariesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discharge_summariesPayload>
          }
          aggregate: {
            args: Prisma.Discharge_summariesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDischarge_summaries>
          }
          groupBy: {
            args: Prisma.discharge_summariesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Discharge_summariesGroupByOutputType>[]
          }
          count: {
            args: Prisma.discharge_summariesCountArgs<ExtArgs>
            result: $Utils.Optional<Discharge_summariesCountAggregateOutputType> | number
          }
        }
      }
      audit_logs: {
        payload: Prisma.$audit_logsPayload<ExtArgs>
        fields: Prisma.audit_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.audit_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.audit_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          findFirst: {
            args: Prisma.audit_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.audit_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          findMany: {
            args: Prisma.audit_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>[]
          }
          create: {
            args: Prisma.audit_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          createMany: {
            args: Prisma.audit_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.audit_logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>[]
          }
          delete: {
            args: Prisma.audit_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          update: {
            args: Prisma.audit_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          deleteMany: {
            args: Prisma.audit_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.audit_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.audit_logsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>[]
          }
          upsert: {
            args: Prisma.audit_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          aggregate: {
            args: Prisma.Audit_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudit_logs>
          }
          groupBy: {
            args: Prisma.audit_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Audit_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.audit_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Audit_logsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    users?: usersOmit
    patients?: patientsOmit
    consultations?: consultationsOmit
    vital_signs?: vital_signsOmit
    lab_requests?: lab_requestsOmit
    lab_results?: lab_resultsOmit
    prescriptions?: prescriptionsOmit
    queue_entries?: queue_entriesOmit
    appointments?: appointmentsOmit
    admissions?: admissionsOmit
    drugs?: drugsOmit
    lab_tests?: lab_testsOmit
    announcements?: announcementsOmit
    voice_notes?: voice_notesOmit
    medical_certificates?: medical_certificatesOmit
    referral_letters?: referral_lettersOmit
    discharge_summaries?: discharge_summariesOmit
    audit_logs?: audit_logsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    role: string | null
    department: string | null
    initials: string | null
    phone: string | null
    dateOfBirth: Date | null
    isActive: boolean | null
    isFirstLogin: boolean | null
    approvalStatus: string | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    role: string | null
    department: string | null
    initials: string | null
    phone: string | null
    dateOfBirth: Date | null
    isActive: boolean | null
    isFirstLogin: boolean | null
    approvalStatus: string | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    role: number
    department: number
    initials: number
    phone: number
    dateOfBirth: number
    isActive: number
    isFirstLogin: number
    approvalStatus: number
    lastLogin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    department?: true
    initials?: true
    phone?: true
    dateOfBirth?: true
    isActive?: true
    isFirstLogin?: true
    approvalStatus?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    department?: true
    initials?: true
    phone?: true
    dateOfBirth?: true
    isActive?: true
    isFirstLogin?: true
    approvalStatus?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    department?: true
    initials?: true
    phone?: true
    dateOfBirth?: true
    isActive?: true
    isFirstLogin?: true
    approvalStatus?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    email: string
    name: string
    password: string
    role: string
    department: string | null
    initials: string | null
    phone: string | null
    dateOfBirth: Date | null
    isActive: boolean
    isFirstLogin: boolean
    approvalStatus: string
    lastLogin: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    department?: boolean
    initials?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    isActive?: boolean
    isFirstLogin?: boolean
    approvalStatus?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    department?: boolean
    initials?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    isActive?: boolean
    isFirstLogin?: boolean
    approvalStatus?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    department?: boolean
    initials?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    isActive?: boolean
    isFirstLogin?: boolean
    approvalStatus?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    department?: boolean
    initials?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    isActive?: boolean
    isFirstLogin?: boolean
    approvalStatus?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "role" | "department" | "initials" | "phone" | "dateOfBirth" | "isActive" | "isFirstLogin" | "approvalStatus" | "lastLogin" | "createdAt" | "updatedAt", ExtArgs["result"]["users"]>

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      password: string
      role: string
      department: string | null
      initials: string | null
      phone: string | null
      dateOfBirth: Date | null
      isActive: boolean
      isFirstLogin: boolean
      approvalStatus: string
      lastLogin: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly name: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly role: FieldRef<"users", 'String'>
    readonly department: FieldRef<"users", 'String'>
    readonly initials: FieldRef<"users", 'String'>
    readonly phone: FieldRef<"users", 'String'>
    readonly dateOfBirth: FieldRef<"users", 'DateTime'>
    readonly isActive: FieldRef<"users", 'Boolean'>
    readonly isFirstLogin: FieldRef<"users", 'Boolean'>
    readonly approvalStatus: FieldRef<"users", 'String'>
    readonly lastLogin: FieldRef<"users", 'DateTime'>
    readonly createdAt: FieldRef<"users", 'DateTime'>
    readonly updatedAt: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
  }


  /**
   * Model patients
   */

  export type AggregatePatients = {
    _count: PatientsCountAggregateOutputType | null
    _avg: PatientsAvgAggregateOutputType | null
    _sum: PatientsSumAggregateOutputType | null
    _min: PatientsMinAggregateOutputType | null
    _max: PatientsMaxAggregateOutputType | null
  }

  export type PatientsAvgAggregateOutputType = {
    bedNumber: number | null
  }

  export type PatientsSumAggregateOutputType = {
    bedNumber: number | null
  }

  export type PatientsMinAggregateOutputType = {
    id: string | null
    hospitalNumber: string | null
    ruhcCode: string | null
    matricNumber: string | null
    firstName: string | null
    lastName: string | null
    middleName: string | null
    title: string | null
    dateOfBirth: string | null
    gender: string | null
    bloodGroup: string | null
    genotype: string | null
    phone: string | null
    email: string | null
    address: string | null
    city: string | null
    state: string | null
    lga: string | null
    nationality: string | null
    religion: string | null
    occupation: string | null
    maritalStatus: string | null
    nokName: string | null
    nokRelationship: string | null
    nokPhone: string | null
    nokAddress: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    emergencyContactRelationship: string | null
    insuranceNumber: string | null
    insuranceProvider: string | null
    allergies: string | null
    chronicConditions: string | null
    currentMedications: string | null
    currentUnit: string | null
    bedNumber: number | null
    admissionDate: Date | null
    dischargeDate: Date | null
    isActive: boolean | null
    registeredAt: Date | null
    registeredBy: string | null
    lastEditedBy: string | null
    lastEditedAt: Date | null
  }

  export type PatientsMaxAggregateOutputType = {
    id: string | null
    hospitalNumber: string | null
    ruhcCode: string | null
    matricNumber: string | null
    firstName: string | null
    lastName: string | null
    middleName: string | null
    title: string | null
    dateOfBirth: string | null
    gender: string | null
    bloodGroup: string | null
    genotype: string | null
    phone: string | null
    email: string | null
    address: string | null
    city: string | null
    state: string | null
    lga: string | null
    nationality: string | null
    religion: string | null
    occupation: string | null
    maritalStatus: string | null
    nokName: string | null
    nokRelationship: string | null
    nokPhone: string | null
    nokAddress: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    emergencyContactRelationship: string | null
    insuranceNumber: string | null
    insuranceProvider: string | null
    allergies: string | null
    chronicConditions: string | null
    currentMedications: string | null
    currentUnit: string | null
    bedNumber: number | null
    admissionDate: Date | null
    dischargeDate: Date | null
    isActive: boolean | null
    registeredAt: Date | null
    registeredBy: string | null
    lastEditedBy: string | null
    lastEditedAt: Date | null
  }

  export type PatientsCountAggregateOutputType = {
    id: number
    hospitalNumber: number
    ruhcCode: number
    matricNumber: number
    firstName: number
    lastName: number
    middleName: number
    title: number
    dateOfBirth: number
    gender: number
    bloodGroup: number
    genotype: number
    phone: number
    email: number
    address: number
    city: number
    state: number
    lga: number
    nationality: number
    religion: number
    occupation: number
    maritalStatus: number
    nokName: number
    nokRelationship: number
    nokPhone: number
    nokAddress: number
    emergencyContactName: number
    emergencyContactPhone: number
    emergencyContactRelationship: number
    insuranceNumber: number
    insuranceProvider: number
    allergies: number
    chronicConditions: number
    currentMedications: number
    currentUnit: number
    bedNumber: number
    admissionDate: number
    dischargeDate: number
    isActive: number
    registeredAt: number
    registeredBy: number
    lastEditedBy: number
    lastEditedAt: number
    _all: number
  }


  export type PatientsAvgAggregateInputType = {
    bedNumber?: true
  }

  export type PatientsSumAggregateInputType = {
    bedNumber?: true
  }

  export type PatientsMinAggregateInputType = {
    id?: true
    hospitalNumber?: true
    ruhcCode?: true
    matricNumber?: true
    firstName?: true
    lastName?: true
    middleName?: true
    title?: true
    dateOfBirth?: true
    gender?: true
    bloodGroup?: true
    genotype?: true
    phone?: true
    email?: true
    address?: true
    city?: true
    state?: true
    lga?: true
    nationality?: true
    religion?: true
    occupation?: true
    maritalStatus?: true
    nokName?: true
    nokRelationship?: true
    nokPhone?: true
    nokAddress?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    emergencyContactRelationship?: true
    insuranceNumber?: true
    insuranceProvider?: true
    allergies?: true
    chronicConditions?: true
    currentMedications?: true
    currentUnit?: true
    bedNumber?: true
    admissionDate?: true
    dischargeDate?: true
    isActive?: true
    registeredAt?: true
    registeredBy?: true
    lastEditedBy?: true
    lastEditedAt?: true
  }

  export type PatientsMaxAggregateInputType = {
    id?: true
    hospitalNumber?: true
    ruhcCode?: true
    matricNumber?: true
    firstName?: true
    lastName?: true
    middleName?: true
    title?: true
    dateOfBirth?: true
    gender?: true
    bloodGroup?: true
    genotype?: true
    phone?: true
    email?: true
    address?: true
    city?: true
    state?: true
    lga?: true
    nationality?: true
    religion?: true
    occupation?: true
    maritalStatus?: true
    nokName?: true
    nokRelationship?: true
    nokPhone?: true
    nokAddress?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    emergencyContactRelationship?: true
    insuranceNumber?: true
    insuranceProvider?: true
    allergies?: true
    chronicConditions?: true
    currentMedications?: true
    currentUnit?: true
    bedNumber?: true
    admissionDate?: true
    dischargeDate?: true
    isActive?: true
    registeredAt?: true
    registeredBy?: true
    lastEditedBy?: true
    lastEditedAt?: true
  }

  export type PatientsCountAggregateInputType = {
    id?: true
    hospitalNumber?: true
    ruhcCode?: true
    matricNumber?: true
    firstName?: true
    lastName?: true
    middleName?: true
    title?: true
    dateOfBirth?: true
    gender?: true
    bloodGroup?: true
    genotype?: true
    phone?: true
    email?: true
    address?: true
    city?: true
    state?: true
    lga?: true
    nationality?: true
    religion?: true
    occupation?: true
    maritalStatus?: true
    nokName?: true
    nokRelationship?: true
    nokPhone?: true
    nokAddress?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    emergencyContactRelationship?: true
    insuranceNumber?: true
    insuranceProvider?: true
    allergies?: true
    chronicConditions?: true
    currentMedications?: true
    currentUnit?: true
    bedNumber?: true
    admissionDate?: true
    dischargeDate?: true
    isActive?: true
    registeredAt?: true
    registeredBy?: true
    lastEditedBy?: true
    lastEditedAt?: true
    _all?: true
  }

  export type PatientsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patients to aggregate.
     */
    where?: patientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patients to fetch.
     */
    orderBy?: patientsOrderByWithRelationInput | patientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: patientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned patients
    **/
    _count?: true | PatientsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientsMaxAggregateInputType
  }

  export type GetPatientsAggregateType<T extends PatientsAggregateArgs> = {
        [P in keyof T & keyof AggregatePatients]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatients[P]>
      : GetScalarType<T[P], AggregatePatients[P]>
  }




  export type patientsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: patientsWhereInput
    orderBy?: patientsOrderByWithAggregationInput | patientsOrderByWithAggregationInput[]
    by: PatientsScalarFieldEnum[] | PatientsScalarFieldEnum
    having?: patientsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientsCountAggregateInputType | true
    _avg?: PatientsAvgAggregateInputType
    _sum?: PatientsSumAggregateInputType
    _min?: PatientsMinAggregateInputType
    _max?: PatientsMaxAggregateInputType
  }

  export type PatientsGroupByOutputType = {
    id: string
    hospitalNumber: string | null
    ruhcCode: string
    matricNumber: string | null
    firstName: string
    lastName: string
    middleName: string | null
    title: string | null
    dateOfBirth: string | null
    gender: string | null
    bloodGroup: string | null
    genotype: string | null
    phone: string | null
    email: string | null
    address: string | null
    city: string | null
    state: string | null
    lga: string | null
    nationality: string | null
    religion: string | null
    occupation: string | null
    maritalStatus: string | null
    nokName: string | null
    nokRelationship: string | null
    nokPhone: string | null
    nokAddress: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    emergencyContactRelationship: string | null
    insuranceNumber: string | null
    insuranceProvider: string | null
    allergies: string | null
    chronicConditions: string | null
    currentMedications: string | null
    currentUnit: string | null
    bedNumber: number | null
    admissionDate: Date | null
    dischargeDate: Date | null
    isActive: boolean
    registeredAt: Date
    registeredBy: string | null
    lastEditedBy: string | null
    lastEditedAt: Date | null
    _count: PatientsCountAggregateOutputType | null
    _avg: PatientsAvgAggregateOutputType | null
    _sum: PatientsSumAggregateOutputType | null
    _min: PatientsMinAggregateOutputType | null
    _max: PatientsMaxAggregateOutputType | null
  }

  type GetPatientsGroupByPayload<T extends patientsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientsGroupByOutputType[P]>
            : GetScalarType<T[P], PatientsGroupByOutputType[P]>
        }
      >
    >


  export type patientsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hospitalNumber?: boolean
    ruhcCode?: boolean
    matricNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    middleName?: boolean
    title?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bloodGroup?: boolean
    genotype?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    lga?: boolean
    nationality?: boolean
    religion?: boolean
    occupation?: boolean
    maritalStatus?: boolean
    nokName?: boolean
    nokRelationship?: boolean
    nokPhone?: boolean
    nokAddress?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    emergencyContactRelationship?: boolean
    insuranceNumber?: boolean
    insuranceProvider?: boolean
    allergies?: boolean
    chronicConditions?: boolean
    currentMedications?: boolean
    currentUnit?: boolean
    bedNumber?: boolean
    admissionDate?: boolean
    dischargeDate?: boolean
    isActive?: boolean
    registeredAt?: boolean
    registeredBy?: boolean
    lastEditedBy?: boolean
    lastEditedAt?: boolean
  }, ExtArgs["result"]["patients"]>

  export type patientsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hospitalNumber?: boolean
    ruhcCode?: boolean
    matricNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    middleName?: boolean
    title?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bloodGroup?: boolean
    genotype?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    lga?: boolean
    nationality?: boolean
    religion?: boolean
    occupation?: boolean
    maritalStatus?: boolean
    nokName?: boolean
    nokRelationship?: boolean
    nokPhone?: boolean
    nokAddress?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    emergencyContactRelationship?: boolean
    insuranceNumber?: boolean
    insuranceProvider?: boolean
    allergies?: boolean
    chronicConditions?: boolean
    currentMedications?: boolean
    currentUnit?: boolean
    bedNumber?: boolean
    admissionDate?: boolean
    dischargeDate?: boolean
    isActive?: boolean
    registeredAt?: boolean
    registeredBy?: boolean
    lastEditedBy?: boolean
    lastEditedAt?: boolean
  }, ExtArgs["result"]["patients"]>

  export type patientsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hospitalNumber?: boolean
    ruhcCode?: boolean
    matricNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    middleName?: boolean
    title?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bloodGroup?: boolean
    genotype?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    lga?: boolean
    nationality?: boolean
    religion?: boolean
    occupation?: boolean
    maritalStatus?: boolean
    nokName?: boolean
    nokRelationship?: boolean
    nokPhone?: boolean
    nokAddress?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    emergencyContactRelationship?: boolean
    insuranceNumber?: boolean
    insuranceProvider?: boolean
    allergies?: boolean
    chronicConditions?: boolean
    currentMedications?: boolean
    currentUnit?: boolean
    bedNumber?: boolean
    admissionDate?: boolean
    dischargeDate?: boolean
    isActive?: boolean
    registeredAt?: boolean
    registeredBy?: boolean
    lastEditedBy?: boolean
    lastEditedAt?: boolean
  }, ExtArgs["result"]["patients"]>

  export type patientsSelectScalar = {
    id?: boolean
    hospitalNumber?: boolean
    ruhcCode?: boolean
    matricNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    middleName?: boolean
    title?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bloodGroup?: boolean
    genotype?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    lga?: boolean
    nationality?: boolean
    religion?: boolean
    occupation?: boolean
    maritalStatus?: boolean
    nokName?: boolean
    nokRelationship?: boolean
    nokPhone?: boolean
    nokAddress?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    emergencyContactRelationship?: boolean
    insuranceNumber?: boolean
    insuranceProvider?: boolean
    allergies?: boolean
    chronicConditions?: boolean
    currentMedications?: boolean
    currentUnit?: boolean
    bedNumber?: boolean
    admissionDate?: boolean
    dischargeDate?: boolean
    isActive?: boolean
    registeredAt?: boolean
    registeredBy?: boolean
    lastEditedBy?: boolean
    lastEditedAt?: boolean
  }

  export type patientsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hospitalNumber" | "ruhcCode" | "matricNumber" | "firstName" | "lastName" | "middleName" | "title" | "dateOfBirth" | "gender" | "bloodGroup" | "genotype" | "phone" | "email" | "address" | "city" | "state" | "lga" | "nationality" | "religion" | "occupation" | "maritalStatus" | "nokName" | "nokRelationship" | "nokPhone" | "nokAddress" | "emergencyContactName" | "emergencyContactPhone" | "emergencyContactRelationship" | "insuranceNumber" | "insuranceProvider" | "allergies" | "chronicConditions" | "currentMedications" | "currentUnit" | "bedNumber" | "admissionDate" | "dischargeDate" | "isActive" | "registeredAt" | "registeredBy" | "lastEditedBy" | "lastEditedAt", ExtArgs["result"]["patients"]>

  export type $patientsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "patients"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hospitalNumber: string | null
      ruhcCode: string
      matricNumber: string | null
      firstName: string
      lastName: string
      middleName: string | null
      title: string | null
      dateOfBirth: string | null
      gender: string | null
      bloodGroup: string | null
      genotype: string | null
      phone: string | null
      email: string | null
      address: string | null
      city: string | null
      state: string | null
      lga: string | null
      nationality: string | null
      religion: string | null
      occupation: string | null
      maritalStatus: string | null
      nokName: string | null
      nokRelationship: string | null
      nokPhone: string | null
      nokAddress: string | null
      emergencyContactName: string | null
      emergencyContactPhone: string | null
      emergencyContactRelationship: string | null
      insuranceNumber: string | null
      insuranceProvider: string | null
      allergies: string | null
      chronicConditions: string | null
      currentMedications: string | null
      currentUnit: string | null
      bedNumber: number | null
      admissionDate: Date | null
      dischargeDate: Date | null
      isActive: boolean
      registeredAt: Date
      registeredBy: string | null
      lastEditedBy: string | null
      lastEditedAt: Date | null
    }, ExtArgs["result"]["patients"]>
    composites: {}
  }

  type patientsGetPayload<S extends boolean | null | undefined | patientsDefaultArgs> = $Result.GetResult<Prisma.$patientsPayload, S>

  type patientsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<patientsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientsCountAggregateInputType | true
    }

  export interface patientsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['patients'], meta: { name: 'patients' } }
    /**
     * Find zero or one Patients that matches the filter.
     * @param {patientsFindUniqueArgs} args - Arguments to find a Patients
     * @example
     * // Get one Patients
     * const patients = await prisma.patients.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends patientsFindUniqueArgs>(args: SelectSubset<T, patientsFindUniqueArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patients that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {patientsFindUniqueOrThrowArgs} args - Arguments to find a Patients
     * @example
     * // Get one Patients
     * const patients = await prisma.patients.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends patientsFindUniqueOrThrowArgs>(args: SelectSubset<T, patientsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsFindFirstArgs} args - Arguments to find a Patients
     * @example
     * // Get one Patients
     * const patients = await prisma.patients.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends patientsFindFirstArgs>(args?: SelectSubset<T, patientsFindFirstArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patients that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsFindFirstOrThrowArgs} args - Arguments to find a Patients
     * @example
     * // Get one Patients
     * const patients = await prisma.patients.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends patientsFindFirstOrThrowArgs>(args?: SelectSubset<T, patientsFindFirstOrThrowArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patients.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patients.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientsWithIdOnly = await prisma.patients.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends patientsFindManyArgs>(args?: SelectSubset<T, patientsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patients.
     * @param {patientsCreateArgs} args - Arguments to create a Patients.
     * @example
     * // Create one Patients
     * const Patients = await prisma.patients.create({
     *   data: {
     *     // ... data to create a Patients
     *   }
     * })
     * 
     */
    create<T extends patientsCreateArgs>(args: SelectSubset<T, patientsCreateArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patients.
     * @param {patientsCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patients = await prisma.patients.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends patientsCreateManyArgs>(args?: SelectSubset<T, patientsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {patientsCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patients = await prisma.patients.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientsWithIdOnly = await prisma.patients.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends patientsCreateManyAndReturnArgs>(args?: SelectSubset<T, patientsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Patients.
     * @param {patientsDeleteArgs} args - Arguments to delete one Patients.
     * @example
     * // Delete one Patients
     * const Patients = await prisma.patients.delete({
     *   where: {
     *     // ... filter to delete one Patients
     *   }
     * })
     * 
     */
    delete<T extends patientsDeleteArgs>(args: SelectSubset<T, patientsDeleteArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patients.
     * @param {patientsUpdateArgs} args - Arguments to update one Patients.
     * @example
     * // Update one Patients
     * const patients = await prisma.patients.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends patientsUpdateArgs>(args: SelectSubset<T, patientsUpdateArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patients.
     * @param {patientsDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patients.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends patientsDeleteManyArgs>(args?: SelectSubset<T, patientsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patients = await prisma.patients.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends patientsUpdateManyArgs>(args: SelectSubset<T, patientsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients and returns the data updated in the database.
     * @param {patientsUpdateManyAndReturnArgs} args - Arguments to update many Patients.
     * @example
     * // Update many Patients
     * const patients = await prisma.patients.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patients and only return the `id`
     * const patientsWithIdOnly = await prisma.patients.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends patientsUpdateManyAndReturnArgs>(args: SelectSubset<T, patientsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Patients.
     * @param {patientsUpsertArgs} args - Arguments to update or create a Patients.
     * @example
     * // Update or create a Patients
     * const patients = await prisma.patients.upsert({
     *   create: {
     *     // ... data to create a Patients
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patients we want to update
     *   }
     * })
     */
    upsert<T extends patientsUpsertArgs>(args: SelectSubset<T, patientsUpsertArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patients.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends patientsCountArgs>(
      args?: Subset<T, patientsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientsAggregateArgs>(args: Subset<T, PatientsAggregateArgs>): Prisma.PrismaPromise<GetPatientsAggregateType<T>>

    /**
     * Group by Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends patientsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: patientsGroupByArgs['orderBy'] }
        : { orderBy?: patientsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, patientsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the patients model
   */
  readonly fields: patientsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for patients.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__patientsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the patients model
   */
  interface patientsFieldRefs {
    readonly id: FieldRef<"patients", 'String'>
    readonly hospitalNumber: FieldRef<"patients", 'String'>
    readonly ruhcCode: FieldRef<"patients", 'String'>
    readonly matricNumber: FieldRef<"patients", 'String'>
    readonly firstName: FieldRef<"patients", 'String'>
    readonly lastName: FieldRef<"patients", 'String'>
    readonly middleName: FieldRef<"patients", 'String'>
    readonly title: FieldRef<"patients", 'String'>
    readonly dateOfBirth: FieldRef<"patients", 'String'>
    readonly gender: FieldRef<"patients", 'String'>
    readonly bloodGroup: FieldRef<"patients", 'String'>
    readonly genotype: FieldRef<"patients", 'String'>
    readonly phone: FieldRef<"patients", 'String'>
    readonly email: FieldRef<"patients", 'String'>
    readonly address: FieldRef<"patients", 'String'>
    readonly city: FieldRef<"patients", 'String'>
    readonly state: FieldRef<"patients", 'String'>
    readonly lga: FieldRef<"patients", 'String'>
    readonly nationality: FieldRef<"patients", 'String'>
    readonly religion: FieldRef<"patients", 'String'>
    readonly occupation: FieldRef<"patients", 'String'>
    readonly maritalStatus: FieldRef<"patients", 'String'>
    readonly nokName: FieldRef<"patients", 'String'>
    readonly nokRelationship: FieldRef<"patients", 'String'>
    readonly nokPhone: FieldRef<"patients", 'String'>
    readonly nokAddress: FieldRef<"patients", 'String'>
    readonly emergencyContactName: FieldRef<"patients", 'String'>
    readonly emergencyContactPhone: FieldRef<"patients", 'String'>
    readonly emergencyContactRelationship: FieldRef<"patients", 'String'>
    readonly insuranceNumber: FieldRef<"patients", 'String'>
    readonly insuranceProvider: FieldRef<"patients", 'String'>
    readonly allergies: FieldRef<"patients", 'String'>
    readonly chronicConditions: FieldRef<"patients", 'String'>
    readonly currentMedications: FieldRef<"patients", 'String'>
    readonly currentUnit: FieldRef<"patients", 'String'>
    readonly bedNumber: FieldRef<"patients", 'Int'>
    readonly admissionDate: FieldRef<"patients", 'DateTime'>
    readonly dischargeDate: FieldRef<"patients", 'DateTime'>
    readonly isActive: FieldRef<"patients", 'Boolean'>
    readonly registeredAt: FieldRef<"patients", 'DateTime'>
    readonly registeredBy: FieldRef<"patients", 'String'>
    readonly lastEditedBy: FieldRef<"patients", 'String'>
    readonly lastEditedAt: FieldRef<"patients", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * patients findUnique
   */
  export type patientsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Filter, which patients to fetch.
     */
    where: patientsWhereUniqueInput
  }

  /**
   * patients findUniqueOrThrow
   */
  export type patientsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Filter, which patients to fetch.
     */
    where: patientsWhereUniqueInput
  }

  /**
   * patients findFirst
   */
  export type patientsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Filter, which patients to fetch.
     */
    where?: patientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patients to fetch.
     */
    orderBy?: patientsOrderByWithRelationInput | patientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patients.
     */
    cursor?: patientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patients.
     */
    distinct?: PatientsScalarFieldEnum | PatientsScalarFieldEnum[]
  }

  /**
   * patients findFirstOrThrow
   */
  export type patientsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Filter, which patients to fetch.
     */
    where?: patientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patients to fetch.
     */
    orderBy?: patientsOrderByWithRelationInput | patientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patients.
     */
    cursor?: patientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patients.
     */
    distinct?: PatientsScalarFieldEnum | PatientsScalarFieldEnum[]
  }

  /**
   * patients findMany
   */
  export type patientsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Filter, which patients to fetch.
     */
    where?: patientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patients to fetch.
     */
    orderBy?: patientsOrderByWithRelationInput | patientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing patients.
     */
    cursor?: patientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patients.
     */
    skip?: number
    distinct?: PatientsScalarFieldEnum | PatientsScalarFieldEnum[]
  }

  /**
   * patients create
   */
  export type patientsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * The data needed to create a patients.
     */
    data: XOR<patientsCreateInput, patientsUncheckedCreateInput>
  }

  /**
   * patients createMany
   */
  export type patientsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many patients.
     */
    data: patientsCreateManyInput | patientsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * patients createManyAndReturn
   */
  export type patientsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * The data used to create many patients.
     */
    data: patientsCreateManyInput | patientsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * patients update
   */
  export type patientsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * The data needed to update a patients.
     */
    data: XOR<patientsUpdateInput, patientsUncheckedUpdateInput>
    /**
     * Choose, which patients to update.
     */
    where: patientsWhereUniqueInput
  }

  /**
   * patients updateMany
   */
  export type patientsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update patients.
     */
    data: XOR<patientsUpdateManyMutationInput, patientsUncheckedUpdateManyInput>
    /**
     * Filter which patients to update
     */
    where?: patientsWhereInput
    /**
     * Limit how many patients to update.
     */
    limit?: number
  }

  /**
   * patients updateManyAndReturn
   */
  export type patientsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * The data used to update patients.
     */
    data: XOR<patientsUpdateManyMutationInput, patientsUncheckedUpdateManyInput>
    /**
     * Filter which patients to update
     */
    where?: patientsWhereInput
    /**
     * Limit how many patients to update.
     */
    limit?: number
  }

  /**
   * patients upsert
   */
  export type patientsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * The filter to search for the patients to update in case it exists.
     */
    where: patientsWhereUniqueInput
    /**
     * In case the patients found by the `where` argument doesn't exist, create a new patients with this data.
     */
    create: XOR<patientsCreateInput, patientsUncheckedCreateInput>
    /**
     * In case the patients was found with the provided `where` argument, update it with this data.
     */
    update: XOR<patientsUpdateInput, patientsUncheckedUpdateInput>
  }

  /**
   * patients delete
   */
  export type patientsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Filter which patients to delete.
     */
    where: patientsWhereUniqueInput
  }

  /**
   * patients deleteMany
   */
  export type patientsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patients to delete
     */
    where?: patientsWhereInput
    /**
     * Limit how many patients to delete.
     */
    limit?: number
  }

  /**
   * patients without action
   */
  export type patientsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
  }


  /**
   * Model consultations
   */

  export type AggregateConsultations = {
    _count: ConsultationsCountAggregateOutputType | null
    _min: ConsultationsMinAggregateOutputType | null
    _max: ConsultationsMaxAggregateOutputType | null
  }

  export type ConsultationsMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    doctorId: string | null
    doctorName: string | null
    status: string | null
    chiefComplaint: string | null
    historyOfPresentIllness: string | null
    pastMedicalHistory: string | null
    signsAndSymptoms: string | null
    bloodPressureSystolic: string | null
    bloodPressureDiastolic: string | null
    temperature: string | null
    pulse: string | null
    respiratoryRate: string | null
    weight: string | null
    height: string | null
    oxygenSaturation: string | null
    generalExamination: string | null
    systemExamination: string | null
    scanFindings: string | null
    provisionalDiagnosis: string | null
    finalDiagnosis: string | null
    treatmentPlan: string | null
    referralTo: string | null
    referralNotes: string | null
    sendBackNotes: string | null
    sentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConsultationsMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    doctorId: string | null
    doctorName: string | null
    status: string | null
    chiefComplaint: string | null
    historyOfPresentIllness: string | null
    pastMedicalHistory: string | null
    signsAndSymptoms: string | null
    bloodPressureSystolic: string | null
    bloodPressureDiastolic: string | null
    temperature: string | null
    pulse: string | null
    respiratoryRate: string | null
    weight: string | null
    height: string | null
    oxygenSaturation: string | null
    generalExamination: string | null
    systemExamination: string | null
    scanFindings: string | null
    provisionalDiagnosis: string | null
    finalDiagnosis: string | null
    treatmentPlan: string | null
    referralTo: string | null
    referralNotes: string | null
    sendBackNotes: string | null
    sentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConsultationsCountAggregateOutputType = {
    id: number
    patientId: number
    patient: number
    doctorId: number
    doctorName: number
    status: number
    chiefComplaint: number
    historyOfPresentIllness: number
    pastMedicalHistory: number
    signsAndSymptoms: number
    bloodPressureSystolic: number
    bloodPressureDiastolic: number
    temperature: number
    pulse: number
    respiratoryRate: number
    weight: number
    height: number
    oxygenSaturation: number
    generalExamination: number
    systemExamination: number
    investigationsRequested: number
    scanRequested: number
    scanFindings: number
    provisionalDiagnosis: number
    finalDiagnosis: number
    treatmentPlan: number
    prescriptions: number
    referralTo: number
    referralNotes: number
    sendBackTo: number
    sendBackNotes: number
    sentAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConsultationsMinAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    doctorName?: true
    status?: true
    chiefComplaint?: true
    historyOfPresentIllness?: true
    pastMedicalHistory?: true
    signsAndSymptoms?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    temperature?: true
    pulse?: true
    respiratoryRate?: true
    weight?: true
    height?: true
    oxygenSaturation?: true
    generalExamination?: true
    systemExamination?: true
    scanFindings?: true
    provisionalDiagnosis?: true
    finalDiagnosis?: true
    treatmentPlan?: true
    referralTo?: true
    referralNotes?: true
    sendBackNotes?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConsultationsMaxAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    doctorName?: true
    status?: true
    chiefComplaint?: true
    historyOfPresentIllness?: true
    pastMedicalHistory?: true
    signsAndSymptoms?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    temperature?: true
    pulse?: true
    respiratoryRate?: true
    weight?: true
    height?: true
    oxygenSaturation?: true
    generalExamination?: true
    systemExamination?: true
    scanFindings?: true
    provisionalDiagnosis?: true
    finalDiagnosis?: true
    treatmentPlan?: true
    referralTo?: true
    referralNotes?: true
    sendBackNotes?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConsultationsCountAggregateInputType = {
    id?: true
    patientId?: true
    patient?: true
    doctorId?: true
    doctorName?: true
    status?: true
    chiefComplaint?: true
    historyOfPresentIllness?: true
    pastMedicalHistory?: true
    signsAndSymptoms?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    temperature?: true
    pulse?: true
    respiratoryRate?: true
    weight?: true
    height?: true
    oxygenSaturation?: true
    generalExamination?: true
    systemExamination?: true
    investigationsRequested?: true
    scanRequested?: true
    scanFindings?: true
    provisionalDiagnosis?: true
    finalDiagnosis?: true
    treatmentPlan?: true
    prescriptions?: true
    referralTo?: true
    referralNotes?: true
    sendBackTo?: true
    sendBackNotes?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConsultationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consultations to aggregate.
     */
    where?: consultationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultations to fetch.
     */
    orderBy?: consultationsOrderByWithRelationInput | consultationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: consultationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned consultations
    **/
    _count?: true | ConsultationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsultationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsultationsMaxAggregateInputType
  }

  export type GetConsultationsAggregateType<T extends ConsultationsAggregateArgs> = {
        [P in keyof T & keyof AggregateConsultations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsultations[P]>
      : GetScalarType<T[P], AggregateConsultations[P]>
  }




  export type consultationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consultationsWhereInput
    orderBy?: consultationsOrderByWithAggregationInput | consultationsOrderByWithAggregationInput[]
    by: ConsultationsScalarFieldEnum[] | ConsultationsScalarFieldEnum
    having?: consultationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsultationsCountAggregateInputType | true
    _min?: ConsultationsMinAggregateInputType
    _max?: ConsultationsMaxAggregateInputType
  }

  export type ConsultationsGroupByOutputType = {
    id: string
    patientId: string | null
    patient: JsonValue | null
    doctorId: string | null
    doctorName: string | null
    status: string
    chiefComplaint: string | null
    historyOfPresentIllness: string | null
    pastMedicalHistory: string | null
    signsAndSymptoms: string | null
    bloodPressureSystolic: string | null
    bloodPressureDiastolic: string | null
    temperature: string | null
    pulse: string | null
    respiratoryRate: string | null
    weight: string | null
    height: string | null
    oxygenSaturation: string | null
    generalExamination: string | null
    systemExamination: string | null
    investigationsRequested: JsonValue | null
    scanRequested: JsonValue | null
    scanFindings: string | null
    provisionalDiagnosis: string | null
    finalDiagnosis: string | null
    treatmentPlan: string | null
    prescriptions: JsonValue | null
    referralTo: string | null
    referralNotes: string | null
    sendBackTo: JsonValue | null
    sendBackNotes: string | null
    sentAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ConsultationsCountAggregateOutputType | null
    _min: ConsultationsMinAggregateOutputType | null
    _max: ConsultationsMaxAggregateOutputType | null
  }

  type GetConsultationsGroupByPayload<T extends consultationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsultationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsultationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsultationsGroupByOutputType[P]>
            : GetScalarType<T[P], ConsultationsGroupByOutputType[P]>
        }
      >
    >


  export type consultationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    doctorId?: boolean
    doctorName?: boolean
    status?: boolean
    chiefComplaint?: boolean
    historyOfPresentIllness?: boolean
    pastMedicalHistory?: boolean
    signsAndSymptoms?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    temperature?: boolean
    pulse?: boolean
    respiratoryRate?: boolean
    weight?: boolean
    height?: boolean
    oxygenSaturation?: boolean
    generalExamination?: boolean
    systemExamination?: boolean
    investigationsRequested?: boolean
    scanRequested?: boolean
    scanFindings?: boolean
    provisionalDiagnosis?: boolean
    finalDiagnosis?: boolean
    treatmentPlan?: boolean
    prescriptions?: boolean
    referralTo?: boolean
    referralNotes?: boolean
    sendBackTo?: boolean
    sendBackNotes?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["consultations"]>

  export type consultationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    doctorId?: boolean
    doctorName?: boolean
    status?: boolean
    chiefComplaint?: boolean
    historyOfPresentIllness?: boolean
    pastMedicalHistory?: boolean
    signsAndSymptoms?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    temperature?: boolean
    pulse?: boolean
    respiratoryRate?: boolean
    weight?: boolean
    height?: boolean
    oxygenSaturation?: boolean
    generalExamination?: boolean
    systemExamination?: boolean
    investigationsRequested?: boolean
    scanRequested?: boolean
    scanFindings?: boolean
    provisionalDiagnosis?: boolean
    finalDiagnosis?: boolean
    treatmentPlan?: boolean
    prescriptions?: boolean
    referralTo?: boolean
    referralNotes?: boolean
    sendBackTo?: boolean
    sendBackNotes?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["consultations"]>

  export type consultationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    doctorId?: boolean
    doctorName?: boolean
    status?: boolean
    chiefComplaint?: boolean
    historyOfPresentIllness?: boolean
    pastMedicalHistory?: boolean
    signsAndSymptoms?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    temperature?: boolean
    pulse?: boolean
    respiratoryRate?: boolean
    weight?: boolean
    height?: boolean
    oxygenSaturation?: boolean
    generalExamination?: boolean
    systemExamination?: boolean
    investigationsRequested?: boolean
    scanRequested?: boolean
    scanFindings?: boolean
    provisionalDiagnosis?: boolean
    finalDiagnosis?: boolean
    treatmentPlan?: boolean
    prescriptions?: boolean
    referralTo?: boolean
    referralNotes?: boolean
    sendBackTo?: boolean
    sendBackNotes?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["consultations"]>

  export type consultationsSelectScalar = {
    id?: boolean
    patientId?: boolean
    patient?: boolean
    doctorId?: boolean
    doctorName?: boolean
    status?: boolean
    chiefComplaint?: boolean
    historyOfPresentIllness?: boolean
    pastMedicalHistory?: boolean
    signsAndSymptoms?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    temperature?: boolean
    pulse?: boolean
    respiratoryRate?: boolean
    weight?: boolean
    height?: boolean
    oxygenSaturation?: boolean
    generalExamination?: boolean
    systemExamination?: boolean
    investigationsRequested?: boolean
    scanRequested?: boolean
    scanFindings?: boolean
    provisionalDiagnosis?: boolean
    finalDiagnosis?: boolean
    treatmentPlan?: boolean
    prescriptions?: boolean
    referralTo?: boolean
    referralNotes?: boolean
    sendBackTo?: boolean
    sendBackNotes?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type consultationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "patient" | "doctorId" | "doctorName" | "status" | "chiefComplaint" | "historyOfPresentIllness" | "pastMedicalHistory" | "signsAndSymptoms" | "bloodPressureSystolic" | "bloodPressureDiastolic" | "temperature" | "pulse" | "respiratoryRate" | "weight" | "height" | "oxygenSaturation" | "generalExamination" | "systemExamination" | "investigationsRequested" | "scanRequested" | "scanFindings" | "provisionalDiagnosis" | "finalDiagnosis" | "treatmentPlan" | "prescriptions" | "referralTo" | "referralNotes" | "sendBackTo" | "sendBackNotes" | "sentAt" | "createdAt" | "updatedAt", ExtArgs["result"]["consultations"]>

  export type $consultationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "consultations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string | null
      patient: Prisma.JsonValue | null
      doctorId: string | null
      doctorName: string | null
      status: string
      chiefComplaint: string | null
      historyOfPresentIllness: string | null
      pastMedicalHistory: string | null
      signsAndSymptoms: string | null
      bloodPressureSystolic: string | null
      bloodPressureDiastolic: string | null
      temperature: string | null
      pulse: string | null
      respiratoryRate: string | null
      weight: string | null
      height: string | null
      oxygenSaturation: string | null
      generalExamination: string | null
      systemExamination: string | null
      investigationsRequested: Prisma.JsonValue | null
      scanRequested: Prisma.JsonValue | null
      scanFindings: string | null
      provisionalDiagnosis: string | null
      finalDiagnosis: string | null
      treatmentPlan: string | null
      prescriptions: Prisma.JsonValue | null
      referralTo: string | null
      referralNotes: string | null
      sendBackTo: Prisma.JsonValue | null
      sendBackNotes: string | null
      sentAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["consultations"]>
    composites: {}
  }

  type consultationsGetPayload<S extends boolean | null | undefined | consultationsDefaultArgs> = $Result.GetResult<Prisma.$consultationsPayload, S>

  type consultationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<consultationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConsultationsCountAggregateInputType | true
    }

  export interface consultationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['consultations'], meta: { name: 'consultations' } }
    /**
     * Find zero or one Consultations that matches the filter.
     * @param {consultationsFindUniqueArgs} args - Arguments to find a Consultations
     * @example
     * // Get one Consultations
     * const consultations = await prisma.consultations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends consultationsFindUniqueArgs>(args: SelectSubset<T, consultationsFindUniqueArgs<ExtArgs>>): Prisma__consultationsClient<$Result.GetResult<Prisma.$consultationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Consultations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {consultationsFindUniqueOrThrowArgs} args - Arguments to find a Consultations
     * @example
     * // Get one Consultations
     * const consultations = await prisma.consultations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends consultationsFindUniqueOrThrowArgs>(args: SelectSubset<T, consultationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__consultationsClient<$Result.GetResult<Prisma.$consultationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consultations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultationsFindFirstArgs} args - Arguments to find a Consultations
     * @example
     * // Get one Consultations
     * const consultations = await prisma.consultations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends consultationsFindFirstArgs>(args?: SelectSubset<T, consultationsFindFirstArgs<ExtArgs>>): Prisma__consultationsClient<$Result.GetResult<Prisma.$consultationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consultations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultationsFindFirstOrThrowArgs} args - Arguments to find a Consultations
     * @example
     * // Get one Consultations
     * const consultations = await prisma.consultations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends consultationsFindFirstOrThrowArgs>(args?: SelectSubset<T, consultationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__consultationsClient<$Result.GetResult<Prisma.$consultationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Consultations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consultations
     * const consultations = await prisma.consultations.findMany()
     * 
     * // Get first 10 Consultations
     * const consultations = await prisma.consultations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consultationsWithIdOnly = await prisma.consultations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends consultationsFindManyArgs>(args?: SelectSubset<T, consultationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consultationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Consultations.
     * @param {consultationsCreateArgs} args - Arguments to create a Consultations.
     * @example
     * // Create one Consultations
     * const Consultations = await prisma.consultations.create({
     *   data: {
     *     // ... data to create a Consultations
     *   }
     * })
     * 
     */
    create<T extends consultationsCreateArgs>(args: SelectSubset<T, consultationsCreateArgs<ExtArgs>>): Prisma__consultationsClient<$Result.GetResult<Prisma.$consultationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Consultations.
     * @param {consultationsCreateManyArgs} args - Arguments to create many Consultations.
     * @example
     * // Create many Consultations
     * const consultations = await prisma.consultations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends consultationsCreateManyArgs>(args?: SelectSubset<T, consultationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Consultations and returns the data saved in the database.
     * @param {consultationsCreateManyAndReturnArgs} args - Arguments to create many Consultations.
     * @example
     * // Create many Consultations
     * const consultations = await prisma.consultations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Consultations and only return the `id`
     * const consultationsWithIdOnly = await prisma.consultations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends consultationsCreateManyAndReturnArgs>(args?: SelectSubset<T, consultationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consultationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Consultations.
     * @param {consultationsDeleteArgs} args - Arguments to delete one Consultations.
     * @example
     * // Delete one Consultations
     * const Consultations = await prisma.consultations.delete({
     *   where: {
     *     // ... filter to delete one Consultations
     *   }
     * })
     * 
     */
    delete<T extends consultationsDeleteArgs>(args: SelectSubset<T, consultationsDeleteArgs<ExtArgs>>): Prisma__consultationsClient<$Result.GetResult<Prisma.$consultationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Consultations.
     * @param {consultationsUpdateArgs} args - Arguments to update one Consultations.
     * @example
     * // Update one Consultations
     * const consultations = await prisma.consultations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends consultationsUpdateArgs>(args: SelectSubset<T, consultationsUpdateArgs<ExtArgs>>): Prisma__consultationsClient<$Result.GetResult<Prisma.$consultationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Consultations.
     * @param {consultationsDeleteManyArgs} args - Arguments to filter Consultations to delete.
     * @example
     * // Delete a few Consultations
     * const { count } = await prisma.consultations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends consultationsDeleteManyArgs>(args?: SelectSubset<T, consultationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consultations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consultations
     * const consultations = await prisma.consultations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends consultationsUpdateManyArgs>(args: SelectSubset<T, consultationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consultations and returns the data updated in the database.
     * @param {consultationsUpdateManyAndReturnArgs} args - Arguments to update many Consultations.
     * @example
     * // Update many Consultations
     * const consultations = await prisma.consultations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Consultations and only return the `id`
     * const consultationsWithIdOnly = await prisma.consultations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends consultationsUpdateManyAndReturnArgs>(args: SelectSubset<T, consultationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consultationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Consultations.
     * @param {consultationsUpsertArgs} args - Arguments to update or create a Consultations.
     * @example
     * // Update or create a Consultations
     * const consultations = await prisma.consultations.upsert({
     *   create: {
     *     // ... data to create a Consultations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consultations we want to update
     *   }
     * })
     */
    upsert<T extends consultationsUpsertArgs>(args: SelectSubset<T, consultationsUpsertArgs<ExtArgs>>): Prisma__consultationsClient<$Result.GetResult<Prisma.$consultationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Consultations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultationsCountArgs} args - Arguments to filter Consultations to count.
     * @example
     * // Count the number of Consultations
     * const count = await prisma.consultations.count({
     *   where: {
     *     // ... the filter for the Consultations we want to count
     *   }
     * })
    **/
    count<T extends consultationsCountArgs>(
      args?: Subset<T, consultationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsultationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consultations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsultationsAggregateArgs>(args: Subset<T, ConsultationsAggregateArgs>): Prisma.PrismaPromise<GetConsultationsAggregateType<T>>

    /**
     * Group by Consultations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends consultationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: consultationsGroupByArgs['orderBy'] }
        : { orderBy?: consultationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, consultationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsultationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the consultations model
   */
  readonly fields: consultationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for consultations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__consultationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the consultations model
   */
  interface consultationsFieldRefs {
    readonly id: FieldRef<"consultations", 'String'>
    readonly patientId: FieldRef<"consultations", 'String'>
    readonly patient: FieldRef<"consultations", 'Json'>
    readonly doctorId: FieldRef<"consultations", 'String'>
    readonly doctorName: FieldRef<"consultations", 'String'>
    readonly status: FieldRef<"consultations", 'String'>
    readonly chiefComplaint: FieldRef<"consultations", 'String'>
    readonly historyOfPresentIllness: FieldRef<"consultations", 'String'>
    readonly pastMedicalHistory: FieldRef<"consultations", 'String'>
    readonly signsAndSymptoms: FieldRef<"consultations", 'String'>
    readonly bloodPressureSystolic: FieldRef<"consultations", 'String'>
    readonly bloodPressureDiastolic: FieldRef<"consultations", 'String'>
    readonly temperature: FieldRef<"consultations", 'String'>
    readonly pulse: FieldRef<"consultations", 'String'>
    readonly respiratoryRate: FieldRef<"consultations", 'String'>
    readonly weight: FieldRef<"consultations", 'String'>
    readonly height: FieldRef<"consultations", 'String'>
    readonly oxygenSaturation: FieldRef<"consultations", 'String'>
    readonly generalExamination: FieldRef<"consultations", 'String'>
    readonly systemExamination: FieldRef<"consultations", 'String'>
    readonly investigationsRequested: FieldRef<"consultations", 'Json'>
    readonly scanRequested: FieldRef<"consultations", 'Json'>
    readonly scanFindings: FieldRef<"consultations", 'String'>
    readonly provisionalDiagnosis: FieldRef<"consultations", 'String'>
    readonly finalDiagnosis: FieldRef<"consultations", 'String'>
    readonly treatmentPlan: FieldRef<"consultations", 'String'>
    readonly prescriptions: FieldRef<"consultations", 'Json'>
    readonly referralTo: FieldRef<"consultations", 'String'>
    readonly referralNotes: FieldRef<"consultations", 'String'>
    readonly sendBackTo: FieldRef<"consultations", 'Json'>
    readonly sendBackNotes: FieldRef<"consultations", 'String'>
    readonly sentAt: FieldRef<"consultations", 'DateTime'>
    readonly createdAt: FieldRef<"consultations", 'DateTime'>
    readonly updatedAt: FieldRef<"consultations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * consultations findUnique
   */
  export type consultationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultations
     */
    select?: consultationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultations
     */
    omit?: consultationsOmit<ExtArgs> | null
    /**
     * Filter, which consultations to fetch.
     */
    where: consultationsWhereUniqueInput
  }

  /**
   * consultations findUniqueOrThrow
   */
  export type consultationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultations
     */
    select?: consultationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultations
     */
    omit?: consultationsOmit<ExtArgs> | null
    /**
     * Filter, which consultations to fetch.
     */
    where: consultationsWhereUniqueInput
  }

  /**
   * consultations findFirst
   */
  export type consultationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultations
     */
    select?: consultationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultations
     */
    omit?: consultationsOmit<ExtArgs> | null
    /**
     * Filter, which consultations to fetch.
     */
    where?: consultationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultations to fetch.
     */
    orderBy?: consultationsOrderByWithRelationInput | consultationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consultations.
     */
    cursor?: consultationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consultations.
     */
    distinct?: ConsultationsScalarFieldEnum | ConsultationsScalarFieldEnum[]
  }

  /**
   * consultations findFirstOrThrow
   */
  export type consultationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultations
     */
    select?: consultationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultations
     */
    omit?: consultationsOmit<ExtArgs> | null
    /**
     * Filter, which consultations to fetch.
     */
    where?: consultationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultations to fetch.
     */
    orderBy?: consultationsOrderByWithRelationInput | consultationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consultations.
     */
    cursor?: consultationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consultations.
     */
    distinct?: ConsultationsScalarFieldEnum | ConsultationsScalarFieldEnum[]
  }

  /**
   * consultations findMany
   */
  export type consultationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultations
     */
    select?: consultationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultations
     */
    omit?: consultationsOmit<ExtArgs> | null
    /**
     * Filter, which consultations to fetch.
     */
    where?: consultationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultations to fetch.
     */
    orderBy?: consultationsOrderByWithRelationInput | consultationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing consultations.
     */
    cursor?: consultationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultations.
     */
    skip?: number
    distinct?: ConsultationsScalarFieldEnum | ConsultationsScalarFieldEnum[]
  }

  /**
   * consultations create
   */
  export type consultationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultations
     */
    select?: consultationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultations
     */
    omit?: consultationsOmit<ExtArgs> | null
    /**
     * The data needed to create a consultations.
     */
    data: XOR<consultationsCreateInput, consultationsUncheckedCreateInput>
  }

  /**
   * consultations createMany
   */
  export type consultationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many consultations.
     */
    data: consultationsCreateManyInput | consultationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * consultations createManyAndReturn
   */
  export type consultationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultations
     */
    select?: consultationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the consultations
     */
    omit?: consultationsOmit<ExtArgs> | null
    /**
     * The data used to create many consultations.
     */
    data: consultationsCreateManyInput | consultationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * consultations update
   */
  export type consultationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultations
     */
    select?: consultationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultations
     */
    omit?: consultationsOmit<ExtArgs> | null
    /**
     * The data needed to update a consultations.
     */
    data: XOR<consultationsUpdateInput, consultationsUncheckedUpdateInput>
    /**
     * Choose, which consultations to update.
     */
    where: consultationsWhereUniqueInput
  }

  /**
   * consultations updateMany
   */
  export type consultationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update consultations.
     */
    data: XOR<consultationsUpdateManyMutationInput, consultationsUncheckedUpdateManyInput>
    /**
     * Filter which consultations to update
     */
    where?: consultationsWhereInput
    /**
     * Limit how many consultations to update.
     */
    limit?: number
  }

  /**
   * consultations updateManyAndReturn
   */
  export type consultationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultations
     */
    select?: consultationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the consultations
     */
    omit?: consultationsOmit<ExtArgs> | null
    /**
     * The data used to update consultations.
     */
    data: XOR<consultationsUpdateManyMutationInput, consultationsUncheckedUpdateManyInput>
    /**
     * Filter which consultations to update
     */
    where?: consultationsWhereInput
    /**
     * Limit how many consultations to update.
     */
    limit?: number
  }

  /**
   * consultations upsert
   */
  export type consultationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultations
     */
    select?: consultationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultations
     */
    omit?: consultationsOmit<ExtArgs> | null
    /**
     * The filter to search for the consultations to update in case it exists.
     */
    where: consultationsWhereUniqueInput
    /**
     * In case the consultations found by the `where` argument doesn't exist, create a new consultations with this data.
     */
    create: XOR<consultationsCreateInput, consultationsUncheckedCreateInput>
    /**
     * In case the consultations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<consultationsUpdateInput, consultationsUncheckedUpdateInput>
  }

  /**
   * consultations delete
   */
  export type consultationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultations
     */
    select?: consultationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultations
     */
    omit?: consultationsOmit<ExtArgs> | null
    /**
     * Filter which consultations to delete.
     */
    where: consultationsWhereUniqueInput
  }

  /**
   * consultations deleteMany
   */
  export type consultationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consultations to delete
     */
    where?: consultationsWhereInput
    /**
     * Limit how many consultations to delete.
     */
    limit?: number
  }

  /**
   * consultations without action
   */
  export type consultationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultations
     */
    select?: consultationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultations
     */
    omit?: consultationsOmit<ExtArgs> | null
  }


  /**
   * Model vital_signs
   */

  export type AggregateVital_signs = {
    _count: Vital_signsCountAggregateOutputType | null
    _min: Vital_signsMinAggregateOutputType | null
    _max: Vital_signsMaxAggregateOutputType | null
  }

  export type Vital_signsMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    recordedBy: string | null
    bloodPressureSystolic: string | null
    bloodPressureDiastolic: string | null
    temperature: string | null
    pulse: string | null
    respiratoryRate: string | null
    weight: string | null
    height: string | null
    oxygenSaturation: string | null
    painScore: string | null
    notes: string | null
    recordedAt: Date | null
  }

  export type Vital_signsMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    recordedBy: string | null
    bloodPressureSystolic: string | null
    bloodPressureDiastolic: string | null
    temperature: string | null
    pulse: string | null
    respiratoryRate: string | null
    weight: string | null
    height: string | null
    oxygenSaturation: string | null
    painScore: string | null
    notes: string | null
    recordedAt: Date | null
  }

  export type Vital_signsCountAggregateOutputType = {
    id: number
    patientId: number
    patient: number
    recordedBy: number
    bloodPressureSystolic: number
    bloodPressureDiastolic: number
    temperature: number
    pulse: number
    respiratoryRate: number
    weight: number
    height: number
    oxygenSaturation: number
    painScore: number
    notes: number
    recordedAt: number
    _all: number
  }


  export type Vital_signsMinAggregateInputType = {
    id?: true
    patientId?: true
    recordedBy?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    temperature?: true
    pulse?: true
    respiratoryRate?: true
    weight?: true
    height?: true
    oxygenSaturation?: true
    painScore?: true
    notes?: true
    recordedAt?: true
  }

  export type Vital_signsMaxAggregateInputType = {
    id?: true
    patientId?: true
    recordedBy?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    temperature?: true
    pulse?: true
    respiratoryRate?: true
    weight?: true
    height?: true
    oxygenSaturation?: true
    painScore?: true
    notes?: true
    recordedAt?: true
  }

  export type Vital_signsCountAggregateInputType = {
    id?: true
    patientId?: true
    patient?: true
    recordedBy?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    temperature?: true
    pulse?: true
    respiratoryRate?: true
    weight?: true
    height?: true
    oxygenSaturation?: true
    painScore?: true
    notes?: true
    recordedAt?: true
    _all?: true
  }

  export type Vital_signsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vital_signs to aggregate.
     */
    where?: vital_signsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vital_signs to fetch.
     */
    orderBy?: vital_signsOrderByWithRelationInput | vital_signsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vital_signsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vital_signs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vital_signs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vital_signs
    **/
    _count?: true | Vital_signsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Vital_signsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Vital_signsMaxAggregateInputType
  }

  export type GetVital_signsAggregateType<T extends Vital_signsAggregateArgs> = {
        [P in keyof T & keyof AggregateVital_signs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVital_signs[P]>
      : GetScalarType<T[P], AggregateVital_signs[P]>
  }




  export type vital_signsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vital_signsWhereInput
    orderBy?: vital_signsOrderByWithAggregationInput | vital_signsOrderByWithAggregationInput[]
    by: Vital_signsScalarFieldEnum[] | Vital_signsScalarFieldEnum
    having?: vital_signsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Vital_signsCountAggregateInputType | true
    _min?: Vital_signsMinAggregateInputType
    _max?: Vital_signsMaxAggregateInputType
  }

  export type Vital_signsGroupByOutputType = {
    id: string
    patientId: string | null
    patient: JsonValue | null
    recordedBy: string | null
    bloodPressureSystolic: string | null
    bloodPressureDiastolic: string | null
    temperature: string | null
    pulse: string | null
    respiratoryRate: string | null
    weight: string | null
    height: string | null
    oxygenSaturation: string | null
    painScore: string | null
    notes: string | null
    recordedAt: Date
    _count: Vital_signsCountAggregateOutputType | null
    _min: Vital_signsMinAggregateOutputType | null
    _max: Vital_signsMaxAggregateOutputType | null
  }

  type GetVital_signsGroupByPayload<T extends vital_signsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Vital_signsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Vital_signsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Vital_signsGroupByOutputType[P]>
            : GetScalarType<T[P], Vital_signsGroupByOutputType[P]>
        }
      >
    >


  export type vital_signsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    recordedBy?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    temperature?: boolean
    pulse?: boolean
    respiratoryRate?: boolean
    weight?: boolean
    height?: boolean
    oxygenSaturation?: boolean
    painScore?: boolean
    notes?: boolean
    recordedAt?: boolean
  }, ExtArgs["result"]["vital_signs"]>

  export type vital_signsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    recordedBy?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    temperature?: boolean
    pulse?: boolean
    respiratoryRate?: boolean
    weight?: boolean
    height?: boolean
    oxygenSaturation?: boolean
    painScore?: boolean
    notes?: boolean
    recordedAt?: boolean
  }, ExtArgs["result"]["vital_signs"]>

  export type vital_signsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    recordedBy?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    temperature?: boolean
    pulse?: boolean
    respiratoryRate?: boolean
    weight?: boolean
    height?: boolean
    oxygenSaturation?: boolean
    painScore?: boolean
    notes?: boolean
    recordedAt?: boolean
  }, ExtArgs["result"]["vital_signs"]>

  export type vital_signsSelectScalar = {
    id?: boolean
    patientId?: boolean
    patient?: boolean
    recordedBy?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    temperature?: boolean
    pulse?: boolean
    respiratoryRate?: boolean
    weight?: boolean
    height?: boolean
    oxygenSaturation?: boolean
    painScore?: boolean
    notes?: boolean
    recordedAt?: boolean
  }

  export type vital_signsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "patient" | "recordedBy" | "bloodPressureSystolic" | "bloodPressureDiastolic" | "temperature" | "pulse" | "respiratoryRate" | "weight" | "height" | "oxygenSaturation" | "painScore" | "notes" | "recordedAt", ExtArgs["result"]["vital_signs"]>

  export type $vital_signsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vital_signs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string | null
      patient: Prisma.JsonValue | null
      recordedBy: string | null
      bloodPressureSystolic: string | null
      bloodPressureDiastolic: string | null
      temperature: string | null
      pulse: string | null
      respiratoryRate: string | null
      weight: string | null
      height: string | null
      oxygenSaturation: string | null
      painScore: string | null
      notes: string | null
      recordedAt: Date
    }, ExtArgs["result"]["vital_signs"]>
    composites: {}
  }

  type vital_signsGetPayload<S extends boolean | null | undefined | vital_signsDefaultArgs> = $Result.GetResult<Prisma.$vital_signsPayload, S>

  type vital_signsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<vital_signsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Vital_signsCountAggregateInputType | true
    }

  export interface vital_signsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vital_signs'], meta: { name: 'vital_signs' } }
    /**
     * Find zero or one Vital_signs that matches the filter.
     * @param {vital_signsFindUniqueArgs} args - Arguments to find a Vital_signs
     * @example
     * // Get one Vital_signs
     * const vital_signs = await prisma.vital_signs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends vital_signsFindUniqueArgs>(args: SelectSubset<T, vital_signsFindUniqueArgs<ExtArgs>>): Prisma__vital_signsClient<$Result.GetResult<Prisma.$vital_signsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vital_signs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {vital_signsFindUniqueOrThrowArgs} args - Arguments to find a Vital_signs
     * @example
     * // Get one Vital_signs
     * const vital_signs = await prisma.vital_signs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends vital_signsFindUniqueOrThrowArgs>(args: SelectSubset<T, vital_signsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__vital_signsClient<$Result.GetResult<Prisma.$vital_signsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vital_signs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vital_signsFindFirstArgs} args - Arguments to find a Vital_signs
     * @example
     * // Get one Vital_signs
     * const vital_signs = await prisma.vital_signs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends vital_signsFindFirstArgs>(args?: SelectSubset<T, vital_signsFindFirstArgs<ExtArgs>>): Prisma__vital_signsClient<$Result.GetResult<Prisma.$vital_signsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vital_signs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vital_signsFindFirstOrThrowArgs} args - Arguments to find a Vital_signs
     * @example
     * // Get one Vital_signs
     * const vital_signs = await prisma.vital_signs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends vital_signsFindFirstOrThrowArgs>(args?: SelectSubset<T, vital_signsFindFirstOrThrowArgs<ExtArgs>>): Prisma__vital_signsClient<$Result.GetResult<Prisma.$vital_signsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vital_signs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vital_signsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vital_signs
     * const vital_signs = await prisma.vital_signs.findMany()
     * 
     * // Get first 10 Vital_signs
     * const vital_signs = await prisma.vital_signs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vital_signsWithIdOnly = await prisma.vital_signs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends vital_signsFindManyArgs>(args?: SelectSubset<T, vital_signsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vital_signsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vital_signs.
     * @param {vital_signsCreateArgs} args - Arguments to create a Vital_signs.
     * @example
     * // Create one Vital_signs
     * const Vital_signs = await prisma.vital_signs.create({
     *   data: {
     *     // ... data to create a Vital_signs
     *   }
     * })
     * 
     */
    create<T extends vital_signsCreateArgs>(args: SelectSubset<T, vital_signsCreateArgs<ExtArgs>>): Prisma__vital_signsClient<$Result.GetResult<Prisma.$vital_signsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vital_signs.
     * @param {vital_signsCreateManyArgs} args - Arguments to create many Vital_signs.
     * @example
     * // Create many Vital_signs
     * const vital_signs = await prisma.vital_signs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends vital_signsCreateManyArgs>(args?: SelectSubset<T, vital_signsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vital_signs and returns the data saved in the database.
     * @param {vital_signsCreateManyAndReturnArgs} args - Arguments to create many Vital_signs.
     * @example
     * // Create many Vital_signs
     * const vital_signs = await prisma.vital_signs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vital_signs and only return the `id`
     * const vital_signsWithIdOnly = await prisma.vital_signs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends vital_signsCreateManyAndReturnArgs>(args?: SelectSubset<T, vital_signsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vital_signsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vital_signs.
     * @param {vital_signsDeleteArgs} args - Arguments to delete one Vital_signs.
     * @example
     * // Delete one Vital_signs
     * const Vital_signs = await prisma.vital_signs.delete({
     *   where: {
     *     // ... filter to delete one Vital_signs
     *   }
     * })
     * 
     */
    delete<T extends vital_signsDeleteArgs>(args: SelectSubset<T, vital_signsDeleteArgs<ExtArgs>>): Prisma__vital_signsClient<$Result.GetResult<Prisma.$vital_signsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vital_signs.
     * @param {vital_signsUpdateArgs} args - Arguments to update one Vital_signs.
     * @example
     * // Update one Vital_signs
     * const vital_signs = await prisma.vital_signs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends vital_signsUpdateArgs>(args: SelectSubset<T, vital_signsUpdateArgs<ExtArgs>>): Prisma__vital_signsClient<$Result.GetResult<Prisma.$vital_signsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vital_signs.
     * @param {vital_signsDeleteManyArgs} args - Arguments to filter Vital_signs to delete.
     * @example
     * // Delete a few Vital_signs
     * const { count } = await prisma.vital_signs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends vital_signsDeleteManyArgs>(args?: SelectSubset<T, vital_signsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vital_signs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vital_signsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vital_signs
     * const vital_signs = await prisma.vital_signs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends vital_signsUpdateManyArgs>(args: SelectSubset<T, vital_signsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vital_signs and returns the data updated in the database.
     * @param {vital_signsUpdateManyAndReturnArgs} args - Arguments to update many Vital_signs.
     * @example
     * // Update many Vital_signs
     * const vital_signs = await prisma.vital_signs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vital_signs and only return the `id`
     * const vital_signsWithIdOnly = await prisma.vital_signs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends vital_signsUpdateManyAndReturnArgs>(args: SelectSubset<T, vital_signsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vital_signsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vital_signs.
     * @param {vital_signsUpsertArgs} args - Arguments to update or create a Vital_signs.
     * @example
     * // Update or create a Vital_signs
     * const vital_signs = await prisma.vital_signs.upsert({
     *   create: {
     *     // ... data to create a Vital_signs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vital_signs we want to update
     *   }
     * })
     */
    upsert<T extends vital_signsUpsertArgs>(args: SelectSubset<T, vital_signsUpsertArgs<ExtArgs>>): Prisma__vital_signsClient<$Result.GetResult<Prisma.$vital_signsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vital_signs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vital_signsCountArgs} args - Arguments to filter Vital_signs to count.
     * @example
     * // Count the number of Vital_signs
     * const count = await prisma.vital_signs.count({
     *   where: {
     *     // ... the filter for the Vital_signs we want to count
     *   }
     * })
    **/
    count<T extends vital_signsCountArgs>(
      args?: Subset<T, vital_signsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Vital_signsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vital_signs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vital_signsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Vital_signsAggregateArgs>(args: Subset<T, Vital_signsAggregateArgs>): Prisma.PrismaPromise<GetVital_signsAggregateType<T>>

    /**
     * Group by Vital_signs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vital_signsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vital_signsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vital_signsGroupByArgs['orderBy'] }
        : { orderBy?: vital_signsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vital_signsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVital_signsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vital_signs model
   */
  readonly fields: vital_signsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vital_signs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vital_signsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the vital_signs model
   */
  interface vital_signsFieldRefs {
    readonly id: FieldRef<"vital_signs", 'String'>
    readonly patientId: FieldRef<"vital_signs", 'String'>
    readonly patient: FieldRef<"vital_signs", 'Json'>
    readonly recordedBy: FieldRef<"vital_signs", 'String'>
    readonly bloodPressureSystolic: FieldRef<"vital_signs", 'String'>
    readonly bloodPressureDiastolic: FieldRef<"vital_signs", 'String'>
    readonly temperature: FieldRef<"vital_signs", 'String'>
    readonly pulse: FieldRef<"vital_signs", 'String'>
    readonly respiratoryRate: FieldRef<"vital_signs", 'String'>
    readonly weight: FieldRef<"vital_signs", 'String'>
    readonly height: FieldRef<"vital_signs", 'String'>
    readonly oxygenSaturation: FieldRef<"vital_signs", 'String'>
    readonly painScore: FieldRef<"vital_signs", 'String'>
    readonly notes: FieldRef<"vital_signs", 'String'>
    readonly recordedAt: FieldRef<"vital_signs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * vital_signs findUnique
   */
  export type vital_signsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vital_signs
     */
    select?: vital_signsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vital_signs
     */
    omit?: vital_signsOmit<ExtArgs> | null
    /**
     * Filter, which vital_signs to fetch.
     */
    where: vital_signsWhereUniqueInput
  }

  /**
   * vital_signs findUniqueOrThrow
   */
  export type vital_signsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vital_signs
     */
    select?: vital_signsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vital_signs
     */
    omit?: vital_signsOmit<ExtArgs> | null
    /**
     * Filter, which vital_signs to fetch.
     */
    where: vital_signsWhereUniqueInput
  }

  /**
   * vital_signs findFirst
   */
  export type vital_signsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vital_signs
     */
    select?: vital_signsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vital_signs
     */
    omit?: vital_signsOmit<ExtArgs> | null
    /**
     * Filter, which vital_signs to fetch.
     */
    where?: vital_signsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vital_signs to fetch.
     */
    orderBy?: vital_signsOrderByWithRelationInput | vital_signsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vital_signs.
     */
    cursor?: vital_signsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vital_signs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vital_signs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vital_signs.
     */
    distinct?: Vital_signsScalarFieldEnum | Vital_signsScalarFieldEnum[]
  }

  /**
   * vital_signs findFirstOrThrow
   */
  export type vital_signsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vital_signs
     */
    select?: vital_signsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vital_signs
     */
    omit?: vital_signsOmit<ExtArgs> | null
    /**
     * Filter, which vital_signs to fetch.
     */
    where?: vital_signsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vital_signs to fetch.
     */
    orderBy?: vital_signsOrderByWithRelationInput | vital_signsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vital_signs.
     */
    cursor?: vital_signsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vital_signs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vital_signs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vital_signs.
     */
    distinct?: Vital_signsScalarFieldEnum | Vital_signsScalarFieldEnum[]
  }

  /**
   * vital_signs findMany
   */
  export type vital_signsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vital_signs
     */
    select?: vital_signsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vital_signs
     */
    omit?: vital_signsOmit<ExtArgs> | null
    /**
     * Filter, which vital_signs to fetch.
     */
    where?: vital_signsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vital_signs to fetch.
     */
    orderBy?: vital_signsOrderByWithRelationInput | vital_signsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vital_signs.
     */
    cursor?: vital_signsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vital_signs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vital_signs.
     */
    skip?: number
    distinct?: Vital_signsScalarFieldEnum | Vital_signsScalarFieldEnum[]
  }

  /**
   * vital_signs create
   */
  export type vital_signsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vital_signs
     */
    select?: vital_signsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vital_signs
     */
    omit?: vital_signsOmit<ExtArgs> | null
    /**
     * The data needed to create a vital_signs.
     */
    data: XOR<vital_signsCreateInput, vital_signsUncheckedCreateInput>
  }

  /**
   * vital_signs createMany
   */
  export type vital_signsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vital_signs.
     */
    data: vital_signsCreateManyInput | vital_signsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * vital_signs createManyAndReturn
   */
  export type vital_signsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vital_signs
     */
    select?: vital_signsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the vital_signs
     */
    omit?: vital_signsOmit<ExtArgs> | null
    /**
     * The data used to create many vital_signs.
     */
    data: vital_signsCreateManyInput | vital_signsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * vital_signs update
   */
  export type vital_signsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vital_signs
     */
    select?: vital_signsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vital_signs
     */
    omit?: vital_signsOmit<ExtArgs> | null
    /**
     * The data needed to update a vital_signs.
     */
    data: XOR<vital_signsUpdateInput, vital_signsUncheckedUpdateInput>
    /**
     * Choose, which vital_signs to update.
     */
    where: vital_signsWhereUniqueInput
  }

  /**
   * vital_signs updateMany
   */
  export type vital_signsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vital_signs.
     */
    data: XOR<vital_signsUpdateManyMutationInput, vital_signsUncheckedUpdateManyInput>
    /**
     * Filter which vital_signs to update
     */
    where?: vital_signsWhereInput
    /**
     * Limit how many vital_signs to update.
     */
    limit?: number
  }

  /**
   * vital_signs updateManyAndReturn
   */
  export type vital_signsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vital_signs
     */
    select?: vital_signsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the vital_signs
     */
    omit?: vital_signsOmit<ExtArgs> | null
    /**
     * The data used to update vital_signs.
     */
    data: XOR<vital_signsUpdateManyMutationInput, vital_signsUncheckedUpdateManyInput>
    /**
     * Filter which vital_signs to update
     */
    where?: vital_signsWhereInput
    /**
     * Limit how many vital_signs to update.
     */
    limit?: number
  }

  /**
   * vital_signs upsert
   */
  export type vital_signsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vital_signs
     */
    select?: vital_signsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vital_signs
     */
    omit?: vital_signsOmit<ExtArgs> | null
    /**
     * The filter to search for the vital_signs to update in case it exists.
     */
    where: vital_signsWhereUniqueInput
    /**
     * In case the vital_signs found by the `where` argument doesn't exist, create a new vital_signs with this data.
     */
    create: XOR<vital_signsCreateInput, vital_signsUncheckedCreateInput>
    /**
     * In case the vital_signs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vital_signsUpdateInput, vital_signsUncheckedUpdateInput>
  }

  /**
   * vital_signs delete
   */
  export type vital_signsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vital_signs
     */
    select?: vital_signsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vital_signs
     */
    omit?: vital_signsOmit<ExtArgs> | null
    /**
     * Filter which vital_signs to delete.
     */
    where: vital_signsWhereUniqueInput
  }

  /**
   * vital_signs deleteMany
   */
  export type vital_signsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vital_signs to delete
     */
    where?: vital_signsWhereInput
    /**
     * Limit how many vital_signs to delete.
     */
    limit?: number
  }

  /**
   * vital_signs without action
   */
  export type vital_signsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vital_signs
     */
    select?: vital_signsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vital_signs
     */
    omit?: vital_signsOmit<ExtArgs> | null
  }


  /**
   * Model lab_requests
   */

  export type AggregateLab_requests = {
    _count: Lab_requestsCountAggregateOutputType | null
    _min: Lab_requestsMinAggregateOutputType | null
    _max: Lab_requestsMaxAggregateOutputType | null
  }

  export type Lab_requestsMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    requestedBy: string | null
    status: string | null
    notes: string | null
    requestedAt: Date | null
    completedAt: Date | null
  }

  export type Lab_requestsMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    requestedBy: string | null
    status: string | null
    notes: string | null
    requestedAt: Date | null
    completedAt: Date | null
  }

  export type Lab_requestsCountAggregateOutputType = {
    id: number
    patientId: number
    patient: number
    requestedBy: number
    tests: number
    status: number
    notes: number
    requestedAt: number
    completedAt: number
    _all: number
  }


  export type Lab_requestsMinAggregateInputType = {
    id?: true
    patientId?: true
    requestedBy?: true
    status?: true
    notes?: true
    requestedAt?: true
    completedAt?: true
  }

  export type Lab_requestsMaxAggregateInputType = {
    id?: true
    patientId?: true
    requestedBy?: true
    status?: true
    notes?: true
    requestedAt?: true
    completedAt?: true
  }

  export type Lab_requestsCountAggregateInputType = {
    id?: true
    patientId?: true
    patient?: true
    requestedBy?: true
    tests?: true
    status?: true
    notes?: true
    requestedAt?: true
    completedAt?: true
    _all?: true
  }

  export type Lab_requestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lab_requests to aggregate.
     */
    where?: lab_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_requests to fetch.
     */
    orderBy?: lab_requestsOrderByWithRelationInput | lab_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lab_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lab_requests
    **/
    _count?: true | Lab_requestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lab_requestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lab_requestsMaxAggregateInputType
  }

  export type GetLab_requestsAggregateType<T extends Lab_requestsAggregateArgs> = {
        [P in keyof T & keyof AggregateLab_requests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLab_requests[P]>
      : GetScalarType<T[P], AggregateLab_requests[P]>
  }




  export type lab_requestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lab_requestsWhereInput
    orderBy?: lab_requestsOrderByWithAggregationInput | lab_requestsOrderByWithAggregationInput[]
    by: Lab_requestsScalarFieldEnum[] | Lab_requestsScalarFieldEnum
    having?: lab_requestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lab_requestsCountAggregateInputType | true
    _min?: Lab_requestsMinAggregateInputType
    _max?: Lab_requestsMaxAggregateInputType
  }

  export type Lab_requestsGroupByOutputType = {
    id: string
    patientId: string | null
    patient: JsonValue | null
    requestedBy: string | null
    tests: JsonValue | null
    status: string
    notes: string | null
    requestedAt: Date
    completedAt: Date | null
    _count: Lab_requestsCountAggregateOutputType | null
    _min: Lab_requestsMinAggregateOutputType | null
    _max: Lab_requestsMaxAggregateOutputType | null
  }

  type GetLab_requestsGroupByPayload<T extends lab_requestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lab_requestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lab_requestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lab_requestsGroupByOutputType[P]>
            : GetScalarType<T[P], Lab_requestsGroupByOutputType[P]>
        }
      >
    >


  export type lab_requestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    requestedBy?: boolean
    tests?: boolean
    status?: boolean
    notes?: boolean
    requestedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["lab_requests"]>

  export type lab_requestsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    requestedBy?: boolean
    tests?: boolean
    status?: boolean
    notes?: boolean
    requestedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["lab_requests"]>

  export type lab_requestsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    requestedBy?: boolean
    tests?: boolean
    status?: boolean
    notes?: boolean
    requestedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["lab_requests"]>

  export type lab_requestsSelectScalar = {
    id?: boolean
    patientId?: boolean
    patient?: boolean
    requestedBy?: boolean
    tests?: boolean
    status?: boolean
    notes?: boolean
    requestedAt?: boolean
    completedAt?: boolean
  }

  export type lab_requestsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "patient" | "requestedBy" | "tests" | "status" | "notes" | "requestedAt" | "completedAt", ExtArgs["result"]["lab_requests"]>

  export type $lab_requestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lab_requests"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string | null
      patient: Prisma.JsonValue | null
      requestedBy: string | null
      tests: Prisma.JsonValue | null
      status: string
      notes: string | null
      requestedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["lab_requests"]>
    composites: {}
  }

  type lab_requestsGetPayload<S extends boolean | null | undefined | lab_requestsDefaultArgs> = $Result.GetResult<Prisma.$lab_requestsPayload, S>

  type lab_requestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<lab_requestsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Lab_requestsCountAggregateInputType | true
    }

  export interface lab_requestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lab_requests'], meta: { name: 'lab_requests' } }
    /**
     * Find zero or one Lab_requests that matches the filter.
     * @param {lab_requestsFindUniqueArgs} args - Arguments to find a Lab_requests
     * @example
     * // Get one Lab_requests
     * const lab_requests = await prisma.lab_requests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends lab_requestsFindUniqueArgs>(args: SelectSubset<T, lab_requestsFindUniqueArgs<ExtArgs>>): Prisma__lab_requestsClient<$Result.GetResult<Prisma.$lab_requestsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lab_requests that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {lab_requestsFindUniqueOrThrowArgs} args - Arguments to find a Lab_requests
     * @example
     * // Get one Lab_requests
     * const lab_requests = await prisma.lab_requests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends lab_requestsFindUniqueOrThrowArgs>(args: SelectSubset<T, lab_requestsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__lab_requestsClient<$Result.GetResult<Prisma.$lab_requestsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lab_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_requestsFindFirstArgs} args - Arguments to find a Lab_requests
     * @example
     * // Get one Lab_requests
     * const lab_requests = await prisma.lab_requests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends lab_requestsFindFirstArgs>(args?: SelectSubset<T, lab_requestsFindFirstArgs<ExtArgs>>): Prisma__lab_requestsClient<$Result.GetResult<Prisma.$lab_requestsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lab_requests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_requestsFindFirstOrThrowArgs} args - Arguments to find a Lab_requests
     * @example
     * // Get one Lab_requests
     * const lab_requests = await prisma.lab_requests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends lab_requestsFindFirstOrThrowArgs>(args?: SelectSubset<T, lab_requestsFindFirstOrThrowArgs<ExtArgs>>): Prisma__lab_requestsClient<$Result.GetResult<Prisma.$lab_requestsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lab_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_requestsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lab_requests
     * const lab_requests = await prisma.lab_requests.findMany()
     * 
     * // Get first 10 Lab_requests
     * const lab_requests = await prisma.lab_requests.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lab_requestsWithIdOnly = await prisma.lab_requests.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends lab_requestsFindManyArgs>(args?: SelectSubset<T, lab_requestsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lab_requestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lab_requests.
     * @param {lab_requestsCreateArgs} args - Arguments to create a Lab_requests.
     * @example
     * // Create one Lab_requests
     * const Lab_requests = await prisma.lab_requests.create({
     *   data: {
     *     // ... data to create a Lab_requests
     *   }
     * })
     * 
     */
    create<T extends lab_requestsCreateArgs>(args: SelectSubset<T, lab_requestsCreateArgs<ExtArgs>>): Prisma__lab_requestsClient<$Result.GetResult<Prisma.$lab_requestsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lab_requests.
     * @param {lab_requestsCreateManyArgs} args - Arguments to create many Lab_requests.
     * @example
     * // Create many Lab_requests
     * const lab_requests = await prisma.lab_requests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends lab_requestsCreateManyArgs>(args?: SelectSubset<T, lab_requestsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lab_requests and returns the data saved in the database.
     * @param {lab_requestsCreateManyAndReturnArgs} args - Arguments to create many Lab_requests.
     * @example
     * // Create many Lab_requests
     * const lab_requests = await prisma.lab_requests.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lab_requests and only return the `id`
     * const lab_requestsWithIdOnly = await prisma.lab_requests.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends lab_requestsCreateManyAndReturnArgs>(args?: SelectSubset<T, lab_requestsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lab_requestsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lab_requests.
     * @param {lab_requestsDeleteArgs} args - Arguments to delete one Lab_requests.
     * @example
     * // Delete one Lab_requests
     * const Lab_requests = await prisma.lab_requests.delete({
     *   where: {
     *     // ... filter to delete one Lab_requests
     *   }
     * })
     * 
     */
    delete<T extends lab_requestsDeleteArgs>(args: SelectSubset<T, lab_requestsDeleteArgs<ExtArgs>>): Prisma__lab_requestsClient<$Result.GetResult<Prisma.$lab_requestsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lab_requests.
     * @param {lab_requestsUpdateArgs} args - Arguments to update one Lab_requests.
     * @example
     * // Update one Lab_requests
     * const lab_requests = await prisma.lab_requests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends lab_requestsUpdateArgs>(args: SelectSubset<T, lab_requestsUpdateArgs<ExtArgs>>): Prisma__lab_requestsClient<$Result.GetResult<Prisma.$lab_requestsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lab_requests.
     * @param {lab_requestsDeleteManyArgs} args - Arguments to filter Lab_requests to delete.
     * @example
     * // Delete a few Lab_requests
     * const { count } = await prisma.lab_requests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends lab_requestsDeleteManyArgs>(args?: SelectSubset<T, lab_requestsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lab_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_requestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lab_requests
     * const lab_requests = await prisma.lab_requests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends lab_requestsUpdateManyArgs>(args: SelectSubset<T, lab_requestsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lab_requests and returns the data updated in the database.
     * @param {lab_requestsUpdateManyAndReturnArgs} args - Arguments to update many Lab_requests.
     * @example
     * // Update many Lab_requests
     * const lab_requests = await prisma.lab_requests.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lab_requests and only return the `id`
     * const lab_requestsWithIdOnly = await prisma.lab_requests.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends lab_requestsUpdateManyAndReturnArgs>(args: SelectSubset<T, lab_requestsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lab_requestsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lab_requests.
     * @param {lab_requestsUpsertArgs} args - Arguments to update or create a Lab_requests.
     * @example
     * // Update or create a Lab_requests
     * const lab_requests = await prisma.lab_requests.upsert({
     *   create: {
     *     // ... data to create a Lab_requests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lab_requests we want to update
     *   }
     * })
     */
    upsert<T extends lab_requestsUpsertArgs>(args: SelectSubset<T, lab_requestsUpsertArgs<ExtArgs>>): Prisma__lab_requestsClient<$Result.GetResult<Prisma.$lab_requestsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lab_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_requestsCountArgs} args - Arguments to filter Lab_requests to count.
     * @example
     * // Count the number of Lab_requests
     * const count = await prisma.lab_requests.count({
     *   where: {
     *     // ... the filter for the Lab_requests we want to count
     *   }
     * })
    **/
    count<T extends lab_requestsCountArgs>(
      args?: Subset<T, lab_requestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lab_requestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lab_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lab_requestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lab_requestsAggregateArgs>(args: Subset<T, Lab_requestsAggregateArgs>): Prisma.PrismaPromise<GetLab_requestsAggregateType<T>>

    /**
     * Group by Lab_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_requestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lab_requestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lab_requestsGroupByArgs['orderBy'] }
        : { orderBy?: lab_requestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lab_requestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLab_requestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lab_requests model
   */
  readonly fields: lab_requestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lab_requests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__lab_requestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the lab_requests model
   */
  interface lab_requestsFieldRefs {
    readonly id: FieldRef<"lab_requests", 'String'>
    readonly patientId: FieldRef<"lab_requests", 'String'>
    readonly patient: FieldRef<"lab_requests", 'Json'>
    readonly requestedBy: FieldRef<"lab_requests", 'String'>
    readonly tests: FieldRef<"lab_requests", 'Json'>
    readonly status: FieldRef<"lab_requests", 'String'>
    readonly notes: FieldRef<"lab_requests", 'String'>
    readonly requestedAt: FieldRef<"lab_requests", 'DateTime'>
    readonly completedAt: FieldRef<"lab_requests", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * lab_requests findUnique
   */
  export type lab_requestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_requests
     */
    select?: lab_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_requests
     */
    omit?: lab_requestsOmit<ExtArgs> | null
    /**
     * Filter, which lab_requests to fetch.
     */
    where: lab_requestsWhereUniqueInput
  }

  /**
   * lab_requests findUniqueOrThrow
   */
  export type lab_requestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_requests
     */
    select?: lab_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_requests
     */
    omit?: lab_requestsOmit<ExtArgs> | null
    /**
     * Filter, which lab_requests to fetch.
     */
    where: lab_requestsWhereUniqueInput
  }

  /**
   * lab_requests findFirst
   */
  export type lab_requestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_requests
     */
    select?: lab_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_requests
     */
    omit?: lab_requestsOmit<ExtArgs> | null
    /**
     * Filter, which lab_requests to fetch.
     */
    where?: lab_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_requests to fetch.
     */
    orderBy?: lab_requestsOrderByWithRelationInput | lab_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lab_requests.
     */
    cursor?: lab_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lab_requests.
     */
    distinct?: Lab_requestsScalarFieldEnum | Lab_requestsScalarFieldEnum[]
  }

  /**
   * lab_requests findFirstOrThrow
   */
  export type lab_requestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_requests
     */
    select?: lab_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_requests
     */
    omit?: lab_requestsOmit<ExtArgs> | null
    /**
     * Filter, which lab_requests to fetch.
     */
    where?: lab_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_requests to fetch.
     */
    orderBy?: lab_requestsOrderByWithRelationInput | lab_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lab_requests.
     */
    cursor?: lab_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lab_requests.
     */
    distinct?: Lab_requestsScalarFieldEnum | Lab_requestsScalarFieldEnum[]
  }

  /**
   * lab_requests findMany
   */
  export type lab_requestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_requests
     */
    select?: lab_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_requests
     */
    omit?: lab_requestsOmit<ExtArgs> | null
    /**
     * Filter, which lab_requests to fetch.
     */
    where?: lab_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_requests to fetch.
     */
    orderBy?: lab_requestsOrderByWithRelationInput | lab_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lab_requests.
     */
    cursor?: lab_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_requests.
     */
    skip?: number
    distinct?: Lab_requestsScalarFieldEnum | Lab_requestsScalarFieldEnum[]
  }

  /**
   * lab_requests create
   */
  export type lab_requestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_requests
     */
    select?: lab_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_requests
     */
    omit?: lab_requestsOmit<ExtArgs> | null
    /**
     * The data needed to create a lab_requests.
     */
    data: XOR<lab_requestsCreateInput, lab_requestsUncheckedCreateInput>
  }

  /**
   * lab_requests createMany
   */
  export type lab_requestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lab_requests.
     */
    data: lab_requestsCreateManyInput | lab_requestsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lab_requests createManyAndReturn
   */
  export type lab_requestsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_requests
     */
    select?: lab_requestsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the lab_requests
     */
    omit?: lab_requestsOmit<ExtArgs> | null
    /**
     * The data used to create many lab_requests.
     */
    data: lab_requestsCreateManyInput | lab_requestsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lab_requests update
   */
  export type lab_requestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_requests
     */
    select?: lab_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_requests
     */
    omit?: lab_requestsOmit<ExtArgs> | null
    /**
     * The data needed to update a lab_requests.
     */
    data: XOR<lab_requestsUpdateInput, lab_requestsUncheckedUpdateInput>
    /**
     * Choose, which lab_requests to update.
     */
    where: lab_requestsWhereUniqueInput
  }

  /**
   * lab_requests updateMany
   */
  export type lab_requestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lab_requests.
     */
    data: XOR<lab_requestsUpdateManyMutationInput, lab_requestsUncheckedUpdateManyInput>
    /**
     * Filter which lab_requests to update
     */
    where?: lab_requestsWhereInput
    /**
     * Limit how many lab_requests to update.
     */
    limit?: number
  }

  /**
   * lab_requests updateManyAndReturn
   */
  export type lab_requestsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_requests
     */
    select?: lab_requestsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the lab_requests
     */
    omit?: lab_requestsOmit<ExtArgs> | null
    /**
     * The data used to update lab_requests.
     */
    data: XOR<lab_requestsUpdateManyMutationInput, lab_requestsUncheckedUpdateManyInput>
    /**
     * Filter which lab_requests to update
     */
    where?: lab_requestsWhereInput
    /**
     * Limit how many lab_requests to update.
     */
    limit?: number
  }

  /**
   * lab_requests upsert
   */
  export type lab_requestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_requests
     */
    select?: lab_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_requests
     */
    omit?: lab_requestsOmit<ExtArgs> | null
    /**
     * The filter to search for the lab_requests to update in case it exists.
     */
    where: lab_requestsWhereUniqueInput
    /**
     * In case the lab_requests found by the `where` argument doesn't exist, create a new lab_requests with this data.
     */
    create: XOR<lab_requestsCreateInput, lab_requestsUncheckedCreateInput>
    /**
     * In case the lab_requests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lab_requestsUpdateInput, lab_requestsUncheckedUpdateInput>
  }

  /**
   * lab_requests delete
   */
  export type lab_requestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_requests
     */
    select?: lab_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_requests
     */
    omit?: lab_requestsOmit<ExtArgs> | null
    /**
     * Filter which lab_requests to delete.
     */
    where: lab_requestsWhereUniqueInput
  }

  /**
   * lab_requests deleteMany
   */
  export type lab_requestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lab_requests to delete
     */
    where?: lab_requestsWhereInput
    /**
     * Limit how many lab_requests to delete.
     */
    limit?: number
  }

  /**
   * lab_requests without action
   */
  export type lab_requestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_requests
     */
    select?: lab_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_requests
     */
    omit?: lab_requestsOmit<ExtArgs> | null
  }


  /**
   * Model lab_results
   */

  export type AggregateLab_results = {
    _count: Lab_resultsCountAggregateOutputType | null
    _min: Lab_resultsMinAggregateOutputType | null
    _max: Lab_resultsMaxAggregateOutputType | null
  }

  export type Lab_resultsMinAggregateOutputType = {
    id: string | null
    requestId: string | null
    patientId: string | null
    testName: string | null
    result: string | null
    notes: string | null
    performedBy: string | null
    createdAt: Date | null
  }

  export type Lab_resultsMaxAggregateOutputType = {
    id: string | null
    requestId: string | null
    patientId: string | null
    testName: string | null
    result: string | null
    notes: string | null
    performedBy: string | null
    createdAt: Date | null
  }

  export type Lab_resultsCountAggregateOutputType = {
    id: number
    requestId: number
    patientId: number
    patient: number
    testName: number
    result: number
    notes: number
    performedBy: number
    createdAt: number
    _all: number
  }


  export type Lab_resultsMinAggregateInputType = {
    id?: true
    requestId?: true
    patientId?: true
    testName?: true
    result?: true
    notes?: true
    performedBy?: true
    createdAt?: true
  }

  export type Lab_resultsMaxAggregateInputType = {
    id?: true
    requestId?: true
    patientId?: true
    testName?: true
    result?: true
    notes?: true
    performedBy?: true
    createdAt?: true
  }

  export type Lab_resultsCountAggregateInputType = {
    id?: true
    requestId?: true
    patientId?: true
    patient?: true
    testName?: true
    result?: true
    notes?: true
    performedBy?: true
    createdAt?: true
    _all?: true
  }

  export type Lab_resultsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lab_results to aggregate.
     */
    where?: lab_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_results to fetch.
     */
    orderBy?: lab_resultsOrderByWithRelationInput | lab_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lab_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lab_results
    **/
    _count?: true | Lab_resultsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lab_resultsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lab_resultsMaxAggregateInputType
  }

  export type GetLab_resultsAggregateType<T extends Lab_resultsAggregateArgs> = {
        [P in keyof T & keyof AggregateLab_results]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLab_results[P]>
      : GetScalarType<T[P], AggregateLab_results[P]>
  }




  export type lab_resultsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lab_resultsWhereInput
    orderBy?: lab_resultsOrderByWithAggregationInput | lab_resultsOrderByWithAggregationInput[]
    by: Lab_resultsScalarFieldEnum[] | Lab_resultsScalarFieldEnum
    having?: lab_resultsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lab_resultsCountAggregateInputType | true
    _min?: Lab_resultsMinAggregateInputType
    _max?: Lab_resultsMaxAggregateInputType
  }

  export type Lab_resultsGroupByOutputType = {
    id: string
    requestId: string | null
    patientId: string | null
    patient: JsonValue | null
    testName: string | null
    result: string | null
    notes: string | null
    performedBy: string | null
    createdAt: Date
    _count: Lab_resultsCountAggregateOutputType | null
    _min: Lab_resultsMinAggregateOutputType | null
    _max: Lab_resultsMaxAggregateOutputType | null
  }

  type GetLab_resultsGroupByPayload<T extends lab_resultsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lab_resultsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lab_resultsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lab_resultsGroupByOutputType[P]>
            : GetScalarType<T[P], Lab_resultsGroupByOutputType[P]>
        }
      >
    >


  export type lab_resultsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    patientId?: boolean
    patient?: boolean
    testName?: boolean
    result?: boolean
    notes?: boolean
    performedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["lab_results"]>

  export type lab_resultsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    patientId?: boolean
    patient?: boolean
    testName?: boolean
    result?: boolean
    notes?: boolean
    performedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["lab_results"]>

  export type lab_resultsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    patientId?: boolean
    patient?: boolean
    testName?: boolean
    result?: boolean
    notes?: boolean
    performedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["lab_results"]>

  export type lab_resultsSelectScalar = {
    id?: boolean
    requestId?: boolean
    patientId?: boolean
    patient?: boolean
    testName?: boolean
    result?: boolean
    notes?: boolean
    performedBy?: boolean
    createdAt?: boolean
  }

  export type lab_resultsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requestId" | "patientId" | "patient" | "testName" | "result" | "notes" | "performedBy" | "createdAt", ExtArgs["result"]["lab_results"]>

  export type $lab_resultsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lab_results"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requestId: string | null
      patientId: string | null
      patient: Prisma.JsonValue | null
      testName: string | null
      result: string | null
      notes: string | null
      performedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["lab_results"]>
    composites: {}
  }

  type lab_resultsGetPayload<S extends boolean | null | undefined | lab_resultsDefaultArgs> = $Result.GetResult<Prisma.$lab_resultsPayload, S>

  type lab_resultsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<lab_resultsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Lab_resultsCountAggregateInputType | true
    }

  export interface lab_resultsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lab_results'], meta: { name: 'lab_results' } }
    /**
     * Find zero or one Lab_results that matches the filter.
     * @param {lab_resultsFindUniqueArgs} args - Arguments to find a Lab_results
     * @example
     * // Get one Lab_results
     * const lab_results = await prisma.lab_results.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends lab_resultsFindUniqueArgs>(args: SelectSubset<T, lab_resultsFindUniqueArgs<ExtArgs>>): Prisma__lab_resultsClient<$Result.GetResult<Prisma.$lab_resultsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lab_results that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {lab_resultsFindUniqueOrThrowArgs} args - Arguments to find a Lab_results
     * @example
     * // Get one Lab_results
     * const lab_results = await prisma.lab_results.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends lab_resultsFindUniqueOrThrowArgs>(args: SelectSubset<T, lab_resultsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__lab_resultsClient<$Result.GetResult<Prisma.$lab_resultsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lab_results that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_resultsFindFirstArgs} args - Arguments to find a Lab_results
     * @example
     * // Get one Lab_results
     * const lab_results = await prisma.lab_results.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends lab_resultsFindFirstArgs>(args?: SelectSubset<T, lab_resultsFindFirstArgs<ExtArgs>>): Prisma__lab_resultsClient<$Result.GetResult<Prisma.$lab_resultsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lab_results that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_resultsFindFirstOrThrowArgs} args - Arguments to find a Lab_results
     * @example
     * // Get one Lab_results
     * const lab_results = await prisma.lab_results.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends lab_resultsFindFirstOrThrowArgs>(args?: SelectSubset<T, lab_resultsFindFirstOrThrowArgs<ExtArgs>>): Prisma__lab_resultsClient<$Result.GetResult<Prisma.$lab_resultsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lab_results that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_resultsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lab_results
     * const lab_results = await prisma.lab_results.findMany()
     * 
     * // Get first 10 Lab_results
     * const lab_results = await prisma.lab_results.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lab_resultsWithIdOnly = await prisma.lab_results.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends lab_resultsFindManyArgs>(args?: SelectSubset<T, lab_resultsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lab_resultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lab_results.
     * @param {lab_resultsCreateArgs} args - Arguments to create a Lab_results.
     * @example
     * // Create one Lab_results
     * const Lab_results = await prisma.lab_results.create({
     *   data: {
     *     // ... data to create a Lab_results
     *   }
     * })
     * 
     */
    create<T extends lab_resultsCreateArgs>(args: SelectSubset<T, lab_resultsCreateArgs<ExtArgs>>): Prisma__lab_resultsClient<$Result.GetResult<Prisma.$lab_resultsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lab_results.
     * @param {lab_resultsCreateManyArgs} args - Arguments to create many Lab_results.
     * @example
     * // Create many Lab_results
     * const lab_results = await prisma.lab_results.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends lab_resultsCreateManyArgs>(args?: SelectSubset<T, lab_resultsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lab_results and returns the data saved in the database.
     * @param {lab_resultsCreateManyAndReturnArgs} args - Arguments to create many Lab_results.
     * @example
     * // Create many Lab_results
     * const lab_results = await prisma.lab_results.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lab_results and only return the `id`
     * const lab_resultsWithIdOnly = await prisma.lab_results.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends lab_resultsCreateManyAndReturnArgs>(args?: SelectSubset<T, lab_resultsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lab_resultsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lab_results.
     * @param {lab_resultsDeleteArgs} args - Arguments to delete one Lab_results.
     * @example
     * // Delete one Lab_results
     * const Lab_results = await prisma.lab_results.delete({
     *   where: {
     *     // ... filter to delete one Lab_results
     *   }
     * })
     * 
     */
    delete<T extends lab_resultsDeleteArgs>(args: SelectSubset<T, lab_resultsDeleteArgs<ExtArgs>>): Prisma__lab_resultsClient<$Result.GetResult<Prisma.$lab_resultsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lab_results.
     * @param {lab_resultsUpdateArgs} args - Arguments to update one Lab_results.
     * @example
     * // Update one Lab_results
     * const lab_results = await prisma.lab_results.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends lab_resultsUpdateArgs>(args: SelectSubset<T, lab_resultsUpdateArgs<ExtArgs>>): Prisma__lab_resultsClient<$Result.GetResult<Prisma.$lab_resultsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lab_results.
     * @param {lab_resultsDeleteManyArgs} args - Arguments to filter Lab_results to delete.
     * @example
     * // Delete a few Lab_results
     * const { count } = await prisma.lab_results.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends lab_resultsDeleteManyArgs>(args?: SelectSubset<T, lab_resultsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lab_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_resultsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lab_results
     * const lab_results = await prisma.lab_results.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends lab_resultsUpdateManyArgs>(args: SelectSubset<T, lab_resultsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lab_results and returns the data updated in the database.
     * @param {lab_resultsUpdateManyAndReturnArgs} args - Arguments to update many Lab_results.
     * @example
     * // Update many Lab_results
     * const lab_results = await prisma.lab_results.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lab_results and only return the `id`
     * const lab_resultsWithIdOnly = await prisma.lab_results.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends lab_resultsUpdateManyAndReturnArgs>(args: SelectSubset<T, lab_resultsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lab_resultsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lab_results.
     * @param {lab_resultsUpsertArgs} args - Arguments to update or create a Lab_results.
     * @example
     * // Update or create a Lab_results
     * const lab_results = await prisma.lab_results.upsert({
     *   create: {
     *     // ... data to create a Lab_results
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lab_results we want to update
     *   }
     * })
     */
    upsert<T extends lab_resultsUpsertArgs>(args: SelectSubset<T, lab_resultsUpsertArgs<ExtArgs>>): Prisma__lab_resultsClient<$Result.GetResult<Prisma.$lab_resultsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lab_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_resultsCountArgs} args - Arguments to filter Lab_results to count.
     * @example
     * // Count the number of Lab_results
     * const count = await prisma.lab_results.count({
     *   where: {
     *     // ... the filter for the Lab_results we want to count
     *   }
     * })
    **/
    count<T extends lab_resultsCountArgs>(
      args?: Subset<T, lab_resultsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lab_resultsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lab_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lab_resultsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lab_resultsAggregateArgs>(args: Subset<T, Lab_resultsAggregateArgs>): Prisma.PrismaPromise<GetLab_resultsAggregateType<T>>

    /**
     * Group by Lab_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_resultsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lab_resultsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lab_resultsGroupByArgs['orderBy'] }
        : { orderBy?: lab_resultsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lab_resultsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLab_resultsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lab_results model
   */
  readonly fields: lab_resultsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lab_results.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__lab_resultsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the lab_results model
   */
  interface lab_resultsFieldRefs {
    readonly id: FieldRef<"lab_results", 'String'>
    readonly requestId: FieldRef<"lab_results", 'String'>
    readonly patientId: FieldRef<"lab_results", 'String'>
    readonly patient: FieldRef<"lab_results", 'Json'>
    readonly testName: FieldRef<"lab_results", 'String'>
    readonly result: FieldRef<"lab_results", 'String'>
    readonly notes: FieldRef<"lab_results", 'String'>
    readonly performedBy: FieldRef<"lab_results", 'String'>
    readonly createdAt: FieldRef<"lab_results", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * lab_results findUnique
   */
  export type lab_resultsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_results
     */
    select?: lab_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_results
     */
    omit?: lab_resultsOmit<ExtArgs> | null
    /**
     * Filter, which lab_results to fetch.
     */
    where: lab_resultsWhereUniqueInput
  }

  /**
   * lab_results findUniqueOrThrow
   */
  export type lab_resultsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_results
     */
    select?: lab_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_results
     */
    omit?: lab_resultsOmit<ExtArgs> | null
    /**
     * Filter, which lab_results to fetch.
     */
    where: lab_resultsWhereUniqueInput
  }

  /**
   * lab_results findFirst
   */
  export type lab_resultsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_results
     */
    select?: lab_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_results
     */
    omit?: lab_resultsOmit<ExtArgs> | null
    /**
     * Filter, which lab_results to fetch.
     */
    where?: lab_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_results to fetch.
     */
    orderBy?: lab_resultsOrderByWithRelationInput | lab_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lab_results.
     */
    cursor?: lab_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lab_results.
     */
    distinct?: Lab_resultsScalarFieldEnum | Lab_resultsScalarFieldEnum[]
  }

  /**
   * lab_results findFirstOrThrow
   */
  export type lab_resultsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_results
     */
    select?: lab_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_results
     */
    omit?: lab_resultsOmit<ExtArgs> | null
    /**
     * Filter, which lab_results to fetch.
     */
    where?: lab_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_results to fetch.
     */
    orderBy?: lab_resultsOrderByWithRelationInput | lab_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lab_results.
     */
    cursor?: lab_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lab_results.
     */
    distinct?: Lab_resultsScalarFieldEnum | Lab_resultsScalarFieldEnum[]
  }

  /**
   * lab_results findMany
   */
  export type lab_resultsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_results
     */
    select?: lab_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_results
     */
    omit?: lab_resultsOmit<ExtArgs> | null
    /**
     * Filter, which lab_results to fetch.
     */
    where?: lab_resultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_results to fetch.
     */
    orderBy?: lab_resultsOrderByWithRelationInput | lab_resultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lab_results.
     */
    cursor?: lab_resultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_results.
     */
    skip?: number
    distinct?: Lab_resultsScalarFieldEnum | Lab_resultsScalarFieldEnum[]
  }

  /**
   * lab_results create
   */
  export type lab_resultsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_results
     */
    select?: lab_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_results
     */
    omit?: lab_resultsOmit<ExtArgs> | null
    /**
     * The data needed to create a lab_results.
     */
    data: XOR<lab_resultsCreateInput, lab_resultsUncheckedCreateInput>
  }

  /**
   * lab_results createMany
   */
  export type lab_resultsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lab_results.
     */
    data: lab_resultsCreateManyInput | lab_resultsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lab_results createManyAndReturn
   */
  export type lab_resultsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_results
     */
    select?: lab_resultsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the lab_results
     */
    omit?: lab_resultsOmit<ExtArgs> | null
    /**
     * The data used to create many lab_results.
     */
    data: lab_resultsCreateManyInput | lab_resultsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lab_results update
   */
  export type lab_resultsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_results
     */
    select?: lab_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_results
     */
    omit?: lab_resultsOmit<ExtArgs> | null
    /**
     * The data needed to update a lab_results.
     */
    data: XOR<lab_resultsUpdateInput, lab_resultsUncheckedUpdateInput>
    /**
     * Choose, which lab_results to update.
     */
    where: lab_resultsWhereUniqueInput
  }

  /**
   * lab_results updateMany
   */
  export type lab_resultsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lab_results.
     */
    data: XOR<lab_resultsUpdateManyMutationInput, lab_resultsUncheckedUpdateManyInput>
    /**
     * Filter which lab_results to update
     */
    where?: lab_resultsWhereInput
    /**
     * Limit how many lab_results to update.
     */
    limit?: number
  }

  /**
   * lab_results updateManyAndReturn
   */
  export type lab_resultsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_results
     */
    select?: lab_resultsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the lab_results
     */
    omit?: lab_resultsOmit<ExtArgs> | null
    /**
     * The data used to update lab_results.
     */
    data: XOR<lab_resultsUpdateManyMutationInput, lab_resultsUncheckedUpdateManyInput>
    /**
     * Filter which lab_results to update
     */
    where?: lab_resultsWhereInput
    /**
     * Limit how many lab_results to update.
     */
    limit?: number
  }

  /**
   * lab_results upsert
   */
  export type lab_resultsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_results
     */
    select?: lab_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_results
     */
    omit?: lab_resultsOmit<ExtArgs> | null
    /**
     * The filter to search for the lab_results to update in case it exists.
     */
    where: lab_resultsWhereUniqueInput
    /**
     * In case the lab_results found by the `where` argument doesn't exist, create a new lab_results with this data.
     */
    create: XOR<lab_resultsCreateInput, lab_resultsUncheckedCreateInput>
    /**
     * In case the lab_results was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lab_resultsUpdateInput, lab_resultsUncheckedUpdateInput>
  }

  /**
   * lab_results delete
   */
  export type lab_resultsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_results
     */
    select?: lab_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_results
     */
    omit?: lab_resultsOmit<ExtArgs> | null
    /**
     * Filter which lab_results to delete.
     */
    where: lab_resultsWhereUniqueInput
  }

  /**
   * lab_results deleteMany
   */
  export type lab_resultsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lab_results to delete
     */
    where?: lab_resultsWhereInput
    /**
     * Limit how many lab_results to delete.
     */
    limit?: number
  }

  /**
   * lab_results without action
   */
  export type lab_resultsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_results
     */
    select?: lab_resultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_results
     */
    omit?: lab_resultsOmit<ExtArgs> | null
  }


  /**
   * Model prescriptions
   */

  export type AggregatePrescriptions = {
    _count: PrescriptionsCountAggregateOutputType | null
    _min: PrescriptionsMinAggregateOutputType | null
    _max: PrescriptionsMaxAggregateOutputType | null
  }

  export type PrescriptionsMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    prescribedBy: string | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    dispensedAt: Date | null
  }

  export type PrescriptionsMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    prescribedBy: string | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    dispensedAt: Date | null
  }

  export type PrescriptionsCountAggregateOutputType = {
    id: number
    patientId: number
    patient: number
    prescribedBy: number
    medications: number
    status: number
    notes: number
    createdAt: number
    dispensedAt: number
    _all: number
  }


  export type PrescriptionsMinAggregateInputType = {
    id?: true
    patientId?: true
    prescribedBy?: true
    status?: true
    notes?: true
    createdAt?: true
    dispensedAt?: true
  }

  export type PrescriptionsMaxAggregateInputType = {
    id?: true
    patientId?: true
    prescribedBy?: true
    status?: true
    notes?: true
    createdAt?: true
    dispensedAt?: true
  }

  export type PrescriptionsCountAggregateInputType = {
    id?: true
    patientId?: true
    patient?: true
    prescribedBy?: true
    medications?: true
    status?: true
    notes?: true
    createdAt?: true
    dispensedAt?: true
    _all?: true
  }

  export type PrescriptionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prescriptions to aggregate.
     */
    where?: prescriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prescriptions to fetch.
     */
    orderBy?: prescriptionsOrderByWithRelationInput | prescriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: prescriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned prescriptions
    **/
    _count?: true | PrescriptionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionsMaxAggregateInputType
  }

  export type GetPrescriptionsAggregateType<T extends PrescriptionsAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescriptions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescriptions[P]>
      : GetScalarType<T[P], AggregatePrescriptions[P]>
  }




  export type prescriptionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prescriptionsWhereInput
    orderBy?: prescriptionsOrderByWithAggregationInput | prescriptionsOrderByWithAggregationInput[]
    by: PrescriptionsScalarFieldEnum[] | PrescriptionsScalarFieldEnum
    having?: prescriptionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionsCountAggregateInputType | true
    _min?: PrescriptionsMinAggregateInputType
    _max?: PrescriptionsMaxAggregateInputType
  }

  export type PrescriptionsGroupByOutputType = {
    id: string
    patientId: string | null
    patient: JsonValue | null
    prescribedBy: string | null
    medications: JsonValue | null
    status: string
    notes: string | null
    createdAt: Date
    dispensedAt: Date | null
    _count: PrescriptionsCountAggregateOutputType | null
    _min: PrescriptionsMinAggregateOutputType | null
    _max: PrescriptionsMaxAggregateOutputType | null
  }

  type GetPrescriptionsGroupByPayload<T extends prescriptionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionsGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionsGroupByOutputType[P]>
        }
      >
    >


  export type prescriptionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    prescribedBy?: boolean
    medications?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    dispensedAt?: boolean
  }, ExtArgs["result"]["prescriptions"]>

  export type prescriptionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    prescribedBy?: boolean
    medications?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    dispensedAt?: boolean
  }, ExtArgs["result"]["prescriptions"]>

  export type prescriptionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    prescribedBy?: boolean
    medications?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    dispensedAt?: boolean
  }, ExtArgs["result"]["prescriptions"]>

  export type prescriptionsSelectScalar = {
    id?: boolean
    patientId?: boolean
    patient?: boolean
    prescribedBy?: boolean
    medications?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    dispensedAt?: boolean
  }

  export type prescriptionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "patient" | "prescribedBy" | "medications" | "status" | "notes" | "createdAt" | "dispensedAt", ExtArgs["result"]["prescriptions"]>

  export type $prescriptionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "prescriptions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string | null
      patient: Prisma.JsonValue | null
      prescribedBy: string | null
      medications: Prisma.JsonValue | null
      status: string
      notes: string | null
      createdAt: Date
      dispensedAt: Date | null
    }, ExtArgs["result"]["prescriptions"]>
    composites: {}
  }

  type prescriptionsGetPayload<S extends boolean | null | undefined | prescriptionsDefaultArgs> = $Result.GetResult<Prisma.$prescriptionsPayload, S>

  type prescriptionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<prescriptionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrescriptionsCountAggregateInputType | true
    }

  export interface prescriptionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['prescriptions'], meta: { name: 'prescriptions' } }
    /**
     * Find zero or one Prescriptions that matches the filter.
     * @param {prescriptionsFindUniqueArgs} args - Arguments to find a Prescriptions
     * @example
     * // Get one Prescriptions
     * const prescriptions = await prisma.prescriptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends prescriptionsFindUniqueArgs>(args: SelectSubset<T, prescriptionsFindUniqueArgs<ExtArgs>>): Prisma__prescriptionsClient<$Result.GetResult<Prisma.$prescriptionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Prescriptions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {prescriptionsFindUniqueOrThrowArgs} args - Arguments to find a Prescriptions
     * @example
     * // Get one Prescriptions
     * const prescriptions = await prisma.prescriptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends prescriptionsFindUniqueOrThrowArgs>(args: SelectSubset<T, prescriptionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__prescriptionsClient<$Result.GetResult<Prisma.$prescriptionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescriptionsFindFirstArgs} args - Arguments to find a Prescriptions
     * @example
     * // Get one Prescriptions
     * const prescriptions = await prisma.prescriptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends prescriptionsFindFirstArgs>(args?: SelectSubset<T, prescriptionsFindFirstArgs<ExtArgs>>): Prisma__prescriptionsClient<$Result.GetResult<Prisma.$prescriptionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prescriptions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescriptionsFindFirstOrThrowArgs} args - Arguments to find a Prescriptions
     * @example
     * // Get one Prescriptions
     * const prescriptions = await prisma.prescriptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends prescriptionsFindFirstOrThrowArgs>(args?: SelectSubset<T, prescriptionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__prescriptionsClient<$Result.GetResult<Prisma.$prescriptionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Prescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescriptionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prescriptions
     * const prescriptions = await prisma.prescriptions.findMany()
     * 
     * // Get first 10 Prescriptions
     * const prescriptions = await prisma.prescriptions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionsWithIdOnly = await prisma.prescriptions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends prescriptionsFindManyArgs>(args?: SelectSubset<T, prescriptionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prescriptionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Prescriptions.
     * @param {prescriptionsCreateArgs} args - Arguments to create a Prescriptions.
     * @example
     * // Create one Prescriptions
     * const Prescriptions = await prisma.prescriptions.create({
     *   data: {
     *     // ... data to create a Prescriptions
     *   }
     * })
     * 
     */
    create<T extends prescriptionsCreateArgs>(args: SelectSubset<T, prescriptionsCreateArgs<ExtArgs>>): Prisma__prescriptionsClient<$Result.GetResult<Prisma.$prescriptionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Prescriptions.
     * @param {prescriptionsCreateManyArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescriptions = await prisma.prescriptions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends prescriptionsCreateManyArgs>(args?: SelectSubset<T, prescriptionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prescriptions and returns the data saved in the database.
     * @param {prescriptionsCreateManyAndReturnArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescriptions = await prisma.prescriptions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prescriptions and only return the `id`
     * const prescriptionsWithIdOnly = await prisma.prescriptions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends prescriptionsCreateManyAndReturnArgs>(args?: SelectSubset<T, prescriptionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prescriptionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Prescriptions.
     * @param {prescriptionsDeleteArgs} args - Arguments to delete one Prescriptions.
     * @example
     * // Delete one Prescriptions
     * const Prescriptions = await prisma.prescriptions.delete({
     *   where: {
     *     // ... filter to delete one Prescriptions
     *   }
     * })
     * 
     */
    delete<T extends prescriptionsDeleteArgs>(args: SelectSubset<T, prescriptionsDeleteArgs<ExtArgs>>): Prisma__prescriptionsClient<$Result.GetResult<Prisma.$prescriptionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Prescriptions.
     * @param {prescriptionsUpdateArgs} args - Arguments to update one Prescriptions.
     * @example
     * // Update one Prescriptions
     * const prescriptions = await prisma.prescriptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends prescriptionsUpdateArgs>(args: SelectSubset<T, prescriptionsUpdateArgs<ExtArgs>>): Prisma__prescriptionsClient<$Result.GetResult<Prisma.$prescriptionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Prescriptions.
     * @param {prescriptionsDeleteManyArgs} args - Arguments to filter Prescriptions to delete.
     * @example
     * // Delete a few Prescriptions
     * const { count } = await prisma.prescriptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends prescriptionsDeleteManyArgs>(args?: SelectSubset<T, prescriptionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescriptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prescriptions
     * const prescriptions = await prisma.prescriptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends prescriptionsUpdateManyArgs>(args: SelectSubset<T, prescriptionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions and returns the data updated in the database.
     * @param {prescriptionsUpdateManyAndReturnArgs} args - Arguments to update many Prescriptions.
     * @example
     * // Update many Prescriptions
     * const prescriptions = await prisma.prescriptions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Prescriptions and only return the `id`
     * const prescriptionsWithIdOnly = await prisma.prescriptions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends prescriptionsUpdateManyAndReturnArgs>(args: SelectSubset<T, prescriptionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prescriptionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Prescriptions.
     * @param {prescriptionsUpsertArgs} args - Arguments to update or create a Prescriptions.
     * @example
     * // Update or create a Prescriptions
     * const prescriptions = await prisma.prescriptions.upsert({
     *   create: {
     *     // ... data to create a Prescriptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prescriptions we want to update
     *   }
     * })
     */
    upsert<T extends prescriptionsUpsertArgs>(args: SelectSubset<T, prescriptionsUpsertArgs<ExtArgs>>): Prisma__prescriptionsClient<$Result.GetResult<Prisma.$prescriptionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescriptionsCountArgs} args - Arguments to filter Prescriptions to count.
     * @example
     * // Count the number of Prescriptions
     * const count = await prisma.prescriptions.count({
     *   where: {
     *     // ... the filter for the Prescriptions we want to count
     *   }
     * })
    **/
    count<T extends prescriptionsCountArgs>(
      args?: Subset<T, prescriptionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionsAggregateArgs>(args: Subset<T, PrescriptionsAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionsAggregateType<T>>

    /**
     * Group by Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prescriptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends prescriptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: prescriptionsGroupByArgs['orderBy'] }
        : { orderBy?: prescriptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, prescriptionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the prescriptions model
   */
  readonly fields: prescriptionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for prescriptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__prescriptionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the prescriptions model
   */
  interface prescriptionsFieldRefs {
    readonly id: FieldRef<"prescriptions", 'String'>
    readonly patientId: FieldRef<"prescriptions", 'String'>
    readonly patient: FieldRef<"prescriptions", 'Json'>
    readonly prescribedBy: FieldRef<"prescriptions", 'String'>
    readonly medications: FieldRef<"prescriptions", 'Json'>
    readonly status: FieldRef<"prescriptions", 'String'>
    readonly notes: FieldRef<"prescriptions", 'String'>
    readonly createdAt: FieldRef<"prescriptions", 'DateTime'>
    readonly dispensedAt: FieldRef<"prescriptions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * prescriptions findUnique
   */
  export type prescriptionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescriptions
     */
    select?: prescriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prescriptions
     */
    omit?: prescriptionsOmit<ExtArgs> | null
    /**
     * Filter, which prescriptions to fetch.
     */
    where: prescriptionsWhereUniqueInput
  }

  /**
   * prescriptions findUniqueOrThrow
   */
  export type prescriptionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescriptions
     */
    select?: prescriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prescriptions
     */
    omit?: prescriptionsOmit<ExtArgs> | null
    /**
     * Filter, which prescriptions to fetch.
     */
    where: prescriptionsWhereUniqueInput
  }

  /**
   * prescriptions findFirst
   */
  export type prescriptionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescriptions
     */
    select?: prescriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prescriptions
     */
    omit?: prescriptionsOmit<ExtArgs> | null
    /**
     * Filter, which prescriptions to fetch.
     */
    where?: prescriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prescriptions to fetch.
     */
    orderBy?: prescriptionsOrderByWithRelationInput | prescriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prescriptions.
     */
    cursor?: prescriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prescriptions.
     */
    distinct?: PrescriptionsScalarFieldEnum | PrescriptionsScalarFieldEnum[]
  }

  /**
   * prescriptions findFirstOrThrow
   */
  export type prescriptionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescriptions
     */
    select?: prescriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prescriptions
     */
    omit?: prescriptionsOmit<ExtArgs> | null
    /**
     * Filter, which prescriptions to fetch.
     */
    where?: prescriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prescriptions to fetch.
     */
    orderBy?: prescriptionsOrderByWithRelationInput | prescriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prescriptions.
     */
    cursor?: prescriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prescriptions.
     */
    distinct?: PrescriptionsScalarFieldEnum | PrescriptionsScalarFieldEnum[]
  }

  /**
   * prescriptions findMany
   */
  export type prescriptionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescriptions
     */
    select?: prescriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prescriptions
     */
    omit?: prescriptionsOmit<ExtArgs> | null
    /**
     * Filter, which prescriptions to fetch.
     */
    where?: prescriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prescriptions to fetch.
     */
    orderBy?: prescriptionsOrderByWithRelationInput | prescriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing prescriptions.
     */
    cursor?: prescriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prescriptions.
     */
    skip?: number
    distinct?: PrescriptionsScalarFieldEnum | PrescriptionsScalarFieldEnum[]
  }

  /**
   * prescriptions create
   */
  export type prescriptionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescriptions
     */
    select?: prescriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prescriptions
     */
    omit?: prescriptionsOmit<ExtArgs> | null
    /**
     * The data needed to create a prescriptions.
     */
    data: XOR<prescriptionsCreateInput, prescriptionsUncheckedCreateInput>
  }

  /**
   * prescriptions createMany
   */
  export type prescriptionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many prescriptions.
     */
    data: prescriptionsCreateManyInput | prescriptionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * prescriptions createManyAndReturn
   */
  export type prescriptionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescriptions
     */
    select?: prescriptionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the prescriptions
     */
    omit?: prescriptionsOmit<ExtArgs> | null
    /**
     * The data used to create many prescriptions.
     */
    data: prescriptionsCreateManyInput | prescriptionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * prescriptions update
   */
  export type prescriptionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescriptions
     */
    select?: prescriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prescriptions
     */
    omit?: prescriptionsOmit<ExtArgs> | null
    /**
     * The data needed to update a prescriptions.
     */
    data: XOR<prescriptionsUpdateInput, prescriptionsUncheckedUpdateInput>
    /**
     * Choose, which prescriptions to update.
     */
    where: prescriptionsWhereUniqueInput
  }

  /**
   * prescriptions updateMany
   */
  export type prescriptionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update prescriptions.
     */
    data: XOR<prescriptionsUpdateManyMutationInput, prescriptionsUncheckedUpdateManyInput>
    /**
     * Filter which prescriptions to update
     */
    where?: prescriptionsWhereInput
    /**
     * Limit how many prescriptions to update.
     */
    limit?: number
  }

  /**
   * prescriptions updateManyAndReturn
   */
  export type prescriptionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescriptions
     */
    select?: prescriptionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the prescriptions
     */
    omit?: prescriptionsOmit<ExtArgs> | null
    /**
     * The data used to update prescriptions.
     */
    data: XOR<prescriptionsUpdateManyMutationInput, prescriptionsUncheckedUpdateManyInput>
    /**
     * Filter which prescriptions to update
     */
    where?: prescriptionsWhereInput
    /**
     * Limit how many prescriptions to update.
     */
    limit?: number
  }

  /**
   * prescriptions upsert
   */
  export type prescriptionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescriptions
     */
    select?: prescriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prescriptions
     */
    omit?: prescriptionsOmit<ExtArgs> | null
    /**
     * The filter to search for the prescriptions to update in case it exists.
     */
    where: prescriptionsWhereUniqueInput
    /**
     * In case the prescriptions found by the `where` argument doesn't exist, create a new prescriptions with this data.
     */
    create: XOR<prescriptionsCreateInput, prescriptionsUncheckedCreateInput>
    /**
     * In case the prescriptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<prescriptionsUpdateInput, prescriptionsUncheckedUpdateInput>
  }

  /**
   * prescriptions delete
   */
  export type prescriptionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescriptions
     */
    select?: prescriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prescriptions
     */
    omit?: prescriptionsOmit<ExtArgs> | null
    /**
     * Filter which prescriptions to delete.
     */
    where: prescriptionsWhereUniqueInput
  }

  /**
   * prescriptions deleteMany
   */
  export type prescriptionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prescriptions to delete
     */
    where?: prescriptionsWhereInput
    /**
     * Limit how many prescriptions to delete.
     */
    limit?: number
  }

  /**
   * prescriptions without action
   */
  export type prescriptionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prescriptions
     */
    select?: prescriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prescriptions
     */
    omit?: prescriptionsOmit<ExtArgs> | null
  }


  /**
   * Model queue_entries
   */

  export type AggregateQueue_entries = {
    _count: Queue_entriesCountAggregateOutputType | null
    _avg: Queue_entriesAvgAggregateOutputType | null
    _sum: Queue_entriesSumAggregateOutputType | null
    _min: Queue_entriesMinAggregateOutputType | null
    _max: Queue_entriesMaxAggregateOutputType | null
  }

  export type Queue_entriesAvgAggregateOutputType = {
    priority: number | null
  }

  export type Queue_entriesSumAggregateOutputType = {
    priority: number | null
  }

  export type Queue_entriesMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    unit: string | null
    status: string | null
    priority: number | null
    notes: string | null
    checkedInAt: Date | null
    seenAt: Date | null
  }

  export type Queue_entriesMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    unit: string | null
    status: string | null
    priority: number | null
    notes: string | null
    checkedInAt: Date | null
    seenAt: Date | null
  }

  export type Queue_entriesCountAggregateOutputType = {
    id: number
    patientId: number
    patient: number
    unit: number
    status: number
    priority: number
    notes: number
    checkedInAt: number
    seenAt: number
    _all: number
  }


  export type Queue_entriesAvgAggregateInputType = {
    priority?: true
  }

  export type Queue_entriesSumAggregateInputType = {
    priority?: true
  }

  export type Queue_entriesMinAggregateInputType = {
    id?: true
    patientId?: true
    unit?: true
    status?: true
    priority?: true
    notes?: true
    checkedInAt?: true
    seenAt?: true
  }

  export type Queue_entriesMaxAggregateInputType = {
    id?: true
    patientId?: true
    unit?: true
    status?: true
    priority?: true
    notes?: true
    checkedInAt?: true
    seenAt?: true
  }

  export type Queue_entriesCountAggregateInputType = {
    id?: true
    patientId?: true
    patient?: true
    unit?: true
    status?: true
    priority?: true
    notes?: true
    checkedInAt?: true
    seenAt?: true
    _all?: true
  }

  export type Queue_entriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which queue_entries to aggregate.
     */
    where?: queue_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of queue_entries to fetch.
     */
    orderBy?: queue_entriesOrderByWithRelationInput | queue_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: queue_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` queue_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` queue_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned queue_entries
    **/
    _count?: true | Queue_entriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Queue_entriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Queue_entriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Queue_entriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Queue_entriesMaxAggregateInputType
  }

  export type GetQueue_entriesAggregateType<T extends Queue_entriesAggregateArgs> = {
        [P in keyof T & keyof AggregateQueue_entries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQueue_entries[P]>
      : GetScalarType<T[P], AggregateQueue_entries[P]>
  }




  export type queue_entriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: queue_entriesWhereInput
    orderBy?: queue_entriesOrderByWithAggregationInput | queue_entriesOrderByWithAggregationInput[]
    by: Queue_entriesScalarFieldEnum[] | Queue_entriesScalarFieldEnum
    having?: queue_entriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Queue_entriesCountAggregateInputType | true
    _avg?: Queue_entriesAvgAggregateInputType
    _sum?: Queue_entriesSumAggregateInputType
    _min?: Queue_entriesMinAggregateInputType
    _max?: Queue_entriesMaxAggregateInputType
  }

  export type Queue_entriesGroupByOutputType = {
    id: string
    patientId: string | null
    patient: JsonValue | null
    unit: string | null
    status: string
    priority: number
    notes: string | null
    checkedInAt: Date
    seenAt: Date | null
    _count: Queue_entriesCountAggregateOutputType | null
    _avg: Queue_entriesAvgAggregateOutputType | null
    _sum: Queue_entriesSumAggregateOutputType | null
    _min: Queue_entriesMinAggregateOutputType | null
    _max: Queue_entriesMaxAggregateOutputType | null
  }

  type GetQueue_entriesGroupByPayload<T extends queue_entriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Queue_entriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Queue_entriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Queue_entriesGroupByOutputType[P]>
            : GetScalarType<T[P], Queue_entriesGroupByOutputType[P]>
        }
      >
    >


  export type queue_entriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    unit?: boolean
    status?: boolean
    priority?: boolean
    notes?: boolean
    checkedInAt?: boolean
    seenAt?: boolean
  }, ExtArgs["result"]["queue_entries"]>

  export type queue_entriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    unit?: boolean
    status?: boolean
    priority?: boolean
    notes?: boolean
    checkedInAt?: boolean
    seenAt?: boolean
  }, ExtArgs["result"]["queue_entries"]>

  export type queue_entriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    unit?: boolean
    status?: boolean
    priority?: boolean
    notes?: boolean
    checkedInAt?: boolean
    seenAt?: boolean
  }, ExtArgs["result"]["queue_entries"]>

  export type queue_entriesSelectScalar = {
    id?: boolean
    patientId?: boolean
    patient?: boolean
    unit?: boolean
    status?: boolean
    priority?: boolean
    notes?: boolean
    checkedInAt?: boolean
    seenAt?: boolean
  }

  export type queue_entriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "patient" | "unit" | "status" | "priority" | "notes" | "checkedInAt" | "seenAt", ExtArgs["result"]["queue_entries"]>

  export type $queue_entriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "queue_entries"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string | null
      patient: Prisma.JsonValue | null
      unit: string | null
      status: string
      priority: number
      notes: string | null
      checkedInAt: Date
      seenAt: Date | null
    }, ExtArgs["result"]["queue_entries"]>
    composites: {}
  }

  type queue_entriesGetPayload<S extends boolean | null | undefined | queue_entriesDefaultArgs> = $Result.GetResult<Prisma.$queue_entriesPayload, S>

  type queue_entriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<queue_entriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Queue_entriesCountAggregateInputType | true
    }

  export interface queue_entriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['queue_entries'], meta: { name: 'queue_entries' } }
    /**
     * Find zero or one Queue_entries that matches the filter.
     * @param {queue_entriesFindUniqueArgs} args - Arguments to find a Queue_entries
     * @example
     * // Get one Queue_entries
     * const queue_entries = await prisma.queue_entries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends queue_entriesFindUniqueArgs>(args: SelectSubset<T, queue_entriesFindUniqueArgs<ExtArgs>>): Prisma__queue_entriesClient<$Result.GetResult<Prisma.$queue_entriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Queue_entries that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {queue_entriesFindUniqueOrThrowArgs} args - Arguments to find a Queue_entries
     * @example
     * // Get one Queue_entries
     * const queue_entries = await prisma.queue_entries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends queue_entriesFindUniqueOrThrowArgs>(args: SelectSubset<T, queue_entriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__queue_entriesClient<$Result.GetResult<Prisma.$queue_entriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Queue_entries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {queue_entriesFindFirstArgs} args - Arguments to find a Queue_entries
     * @example
     * // Get one Queue_entries
     * const queue_entries = await prisma.queue_entries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends queue_entriesFindFirstArgs>(args?: SelectSubset<T, queue_entriesFindFirstArgs<ExtArgs>>): Prisma__queue_entriesClient<$Result.GetResult<Prisma.$queue_entriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Queue_entries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {queue_entriesFindFirstOrThrowArgs} args - Arguments to find a Queue_entries
     * @example
     * // Get one Queue_entries
     * const queue_entries = await prisma.queue_entries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends queue_entriesFindFirstOrThrowArgs>(args?: SelectSubset<T, queue_entriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__queue_entriesClient<$Result.GetResult<Prisma.$queue_entriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Queue_entries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {queue_entriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Queue_entries
     * const queue_entries = await prisma.queue_entries.findMany()
     * 
     * // Get first 10 Queue_entries
     * const queue_entries = await prisma.queue_entries.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const queue_entriesWithIdOnly = await prisma.queue_entries.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends queue_entriesFindManyArgs>(args?: SelectSubset<T, queue_entriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$queue_entriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Queue_entries.
     * @param {queue_entriesCreateArgs} args - Arguments to create a Queue_entries.
     * @example
     * // Create one Queue_entries
     * const Queue_entries = await prisma.queue_entries.create({
     *   data: {
     *     // ... data to create a Queue_entries
     *   }
     * })
     * 
     */
    create<T extends queue_entriesCreateArgs>(args: SelectSubset<T, queue_entriesCreateArgs<ExtArgs>>): Prisma__queue_entriesClient<$Result.GetResult<Prisma.$queue_entriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Queue_entries.
     * @param {queue_entriesCreateManyArgs} args - Arguments to create many Queue_entries.
     * @example
     * // Create many Queue_entries
     * const queue_entries = await prisma.queue_entries.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends queue_entriesCreateManyArgs>(args?: SelectSubset<T, queue_entriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Queue_entries and returns the data saved in the database.
     * @param {queue_entriesCreateManyAndReturnArgs} args - Arguments to create many Queue_entries.
     * @example
     * // Create many Queue_entries
     * const queue_entries = await prisma.queue_entries.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Queue_entries and only return the `id`
     * const queue_entriesWithIdOnly = await prisma.queue_entries.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends queue_entriesCreateManyAndReturnArgs>(args?: SelectSubset<T, queue_entriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$queue_entriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Queue_entries.
     * @param {queue_entriesDeleteArgs} args - Arguments to delete one Queue_entries.
     * @example
     * // Delete one Queue_entries
     * const Queue_entries = await prisma.queue_entries.delete({
     *   where: {
     *     // ... filter to delete one Queue_entries
     *   }
     * })
     * 
     */
    delete<T extends queue_entriesDeleteArgs>(args: SelectSubset<T, queue_entriesDeleteArgs<ExtArgs>>): Prisma__queue_entriesClient<$Result.GetResult<Prisma.$queue_entriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Queue_entries.
     * @param {queue_entriesUpdateArgs} args - Arguments to update one Queue_entries.
     * @example
     * // Update one Queue_entries
     * const queue_entries = await prisma.queue_entries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends queue_entriesUpdateArgs>(args: SelectSubset<T, queue_entriesUpdateArgs<ExtArgs>>): Prisma__queue_entriesClient<$Result.GetResult<Prisma.$queue_entriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Queue_entries.
     * @param {queue_entriesDeleteManyArgs} args - Arguments to filter Queue_entries to delete.
     * @example
     * // Delete a few Queue_entries
     * const { count } = await prisma.queue_entries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends queue_entriesDeleteManyArgs>(args?: SelectSubset<T, queue_entriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Queue_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {queue_entriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Queue_entries
     * const queue_entries = await prisma.queue_entries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends queue_entriesUpdateManyArgs>(args: SelectSubset<T, queue_entriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Queue_entries and returns the data updated in the database.
     * @param {queue_entriesUpdateManyAndReturnArgs} args - Arguments to update many Queue_entries.
     * @example
     * // Update many Queue_entries
     * const queue_entries = await prisma.queue_entries.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Queue_entries and only return the `id`
     * const queue_entriesWithIdOnly = await prisma.queue_entries.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends queue_entriesUpdateManyAndReturnArgs>(args: SelectSubset<T, queue_entriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$queue_entriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Queue_entries.
     * @param {queue_entriesUpsertArgs} args - Arguments to update or create a Queue_entries.
     * @example
     * // Update or create a Queue_entries
     * const queue_entries = await prisma.queue_entries.upsert({
     *   create: {
     *     // ... data to create a Queue_entries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Queue_entries we want to update
     *   }
     * })
     */
    upsert<T extends queue_entriesUpsertArgs>(args: SelectSubset<T, queue_entriesUpsertArgs<ExtArgs>>): Prisma__queue_entriesClient<$Result.GetResult<Prisma.$queue_entriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Queue_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {queue_entriesCountArgs} args - Arguments to filter Queue_entries to count.
     * @example
     * // Count the number of Queue_entries
     * const count = await prisma.queue_entries.count({
     *   where: {
     *     // ... the filter for the Queue_entries we want to count
     *   }
     * })
    **/
    count<T extends queue_entriesCountArgs>(
      args?: Subset<T, queue_entriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Queue_entriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Queue_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Queue_entriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Queue_entriesAggregateArgs>(args: Subset<T, Queue_entriesAggregateArgs>): Prisma.PrismaPromise<GetQueue_entriesAggregateType<T>>

    /**
     * Group by Queue_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {queue_entriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends queue_entriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: queue_entriesGroupByArgs['orderBy'] }
        : { orderBy?: queue_entriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, queue_entriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQueue_entriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the queue_entries model
   */
  readonly fields: queue_entriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for queue_entries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__queue_entriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the queue_entries model
   */
  interface queue_entriesFieldRefs {
    readonly id: FieldRef<"queue_entries", 'String'>
    readonly patientId: FieldRef<"queue_entries", 'String'>
    readonly patient: FieldRef<"queue_entries", 'Json'>
    readonly unit: FieldRef<"queue_entries", 'String'>
    readonly status: FieldRef<"queue_entries", 'String'>
    readonly priority: FieldRef<"queue_entries", 'Int'>
    readonly notes: FieldRef<"queue_entries", 'String'>
    readonly checkedInAt: FieldRef<"queue_entries", 'DateTime'>
    readonly seenAt: FieldRef<"queue_entries", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * queue_entries findUnique
   */
  export type queue_entriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queue_entries
     */
    select?: queue_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the queue_entries
     */
    omit?: queue_entriesOmit<ExtArgs> | null
    /**
     * Filter, which queue_entries to fetch.
     */
    where: queue_entriesWhereUniqueInput
  }

  /**
   * queue_entries findUniqueOrThrow
   */
  export type queue_entriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queue_entries
     */
    select?: queue_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the queue_entries
     */
    omit?: queue_entriesOmit<ExtArgs> | null
    /**
     * Filter, which queue_entries to fetch.
     */
    where: queue_entriesWhereUniqueInput
  }

  /**
   * queue_entries findFirst
   */
  export type queue_entriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queue_entries
     */
    select?: queue_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the queue_entries
     */
    omit?: queue_entriesOmit<ExtArgs> | null
    /**
     * Filter, which queue_entries to fetch.
     */
    where?: queue_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of queue_entries to fetch.
     */
    orderBy?: queue_entriesOrderByWithRelationInput | queue_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for queue_entries.
     */
    cursor?: queue_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` queue_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` queue_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of queue_entries.
     */
    distinct?: Queue_entriesScalarFieldEnum | Queue_entriesScalarFieldEnum[]
  }

  /**
   * queue_entries findFirstOrThrow
   */
  export type queue_entriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queue_entries
     */
    select?: queue_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the queue_entries
     */
    omit?: queue_entriesOmit<ExtArgs> | null
    /**
     * Filter, which queue_entries to fetch.
     */
    where?: queue_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of queue_entries to fetch.
     */
    orderBy?: queue_entriesOrderByWithRelationInput | queue_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for queue_entries.
     */
    cursor?: queue_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` queue_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` queue_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of queue_entries.
     */
    distinct?: Queue_entriesScalarFieldEnum | Queue_entriesScalarFieldEnum[]
  }

  /**
   * queue_entries findMany
   */
  export type queue_entriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queue_entries
     */
    select?: queue_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the queue_entries
     */
    omit?: queue_entriesOmit<ExtArgs> | null
    /**
     * Filter, which queue_entries to fetch.
     */
    where?: queue_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of queue_entries to fetch.
     */
    orderBy?: queue_entriesOrderByWithRelationInput | queue_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing queue_entries.
     */
    cursor?: queue_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` queue_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` queue_entries.
     */
    skip?: number
    distinct?: Queue_entriesScalarFieldEnum | Queue_entriesScalarFieldEnum[]
  }

  /**
   * queue_entries create
   */
  export type queue_entriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queue_entries
     */
    select?: queue_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the queue_entries
     */
    omit?: queue_entriesOmit<ExtArgs> | null
    /**
     * The data needed to create a queue_entries.
     */
    data: XOR<queue_entriesCreateInput, queue_entriesUncheckedCreateInput>
  }

  /**
   * queue_entries createMany
   */
  export type queue_entriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many queue_entries.
     */
    data: queue_entriesCreateManyInput | queue_entriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * queue_entries createManyAndReturn
   */
  export type queue_entriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queue_entries
     */
    select?: queue_entriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the queue_entries
     */
    omit?: queue_entriesOmit<ExtArgs> | null
    /**
     * The data used to create many queue_entries.
     */
    data: queue_entriesCreateManyInput | queue_entriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * queue_entries update
   */
  export type queue_entriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queue_entries
     */
    select?: queue_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the queue_entries
     */
    omit?: queue_entriesOmit<ExtArgs> | null
    /**
     * The data needed to update a queue_entries.
     */
    data: XOR<queue_entriesUpdateInput, queue_entriesUncheckedUpdateInput>
    /**
     * Choose, which queue_entries to update.
     */
    where: queue_entriesWhereUniqueInput
  }

  /**
   * queue_entries updateMany
   */
  export type queue_entriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update queue_entries.
     */
    data: XOR<queue_entriesUpdateManyMutationInput, queue_entriesUncheckedUpdateManyInput>
    /**
     * Filter which queue_entries to update
     */
    where?: queue_entriesWhereInput
    /**
     * Limit how many queue_entries to update.
     */
    limit?: number
  }

  /**
   * queue_entries updateManyAndReturn
   */
  export type queue_entriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queue_entries
     */
    select?: queue_entriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the queue_entries
     */
    omit?: queue_entriesOmit<ExtArgs> | null
    /**
     * The data used to update queue_entries.
     */
    data: XOR<queue_entriesUpdateManyMutationInput, queue_entriesUncheckedUpdateManyInput>
    /**
     * Filter which queue_entries to update
     */
    where?: queue_entriesWhereInput
    /**
     * Limit how many queue_entries to update.
     */
    limit?: number
  }

  /**
   * queue_entries upsert
   */
  export type queue_entriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queue_entries
     */
    select?: queue_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the queue_entries
     */
    omit?: queue_entriesOmit<ExtArgs> | null
    /**
     * The filter to search for the queue_entries to update in case it exists.
     */
    where: queue_entriesWhereUniqueInput
    /**
     * In case the queue_entries found by the `where` argument doesn't exist, create a new queue_entries with this data.
     */
    create: XOR<queue_entriesCreateInput, queue_entriesUncheckedCreateInput>
    /**
     * In case the queue_entries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<queue_entriesUpdateInput, queue_entriesUncheckedUpdateInput>
  }

  /**
   * queue_entries delete
   */
  export type queue_entriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queue_entries
     */
    select?: queue_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the queue_entries
     */
    omit?: queue_entriesOmit<ExtArgs> | null
    /**
     * Filter which queue_entries to delete.
     */
    where: queue_entriesWhereUniqueInput
  }

  /**
   * queue_entries deleteMany
   */
  export type queue_entriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which queue_entries to delete
     */
    where?: queue_entriesWhereInput
    /**
     * Limit how many queue_entries to delete.
     */
    limit?: number
  }

  /**
   * queue_entries without action
   */
  export type queue_entriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the queue_entries
     */
    select?: queue_entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the queue_entries
     */
    omit?: queue_entriesOmit<ExtArgs> | null
  }


  /**
   * Model appointments
   */

  export type AggregateAppointments = {
    _count: AppointmentsCountAggregateOutputType | null
    _min: AppointmentsMinAggregateOutputType | null
    _max: AppointmentsMaxAggregateOutputType | null
  }

  export type AppointmentsMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    doctorId: string | null
    doctorName: string | null
    type: string | null
    reason: string | null
    appointmentDate: string | null
    startTime: string | null
    endTime: string | null
    status: string | null
    notes: string | null
    initials: string | null
    createdAt: Date | null
  }

  export type AppointmentsMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    doctorId: string | null
    doctorName: string | null
    type: string | null
    reason: string | null
    appointmentDate: string | null
    startTime: string | null
    endTime: string | null
    status: string | null
    notes: string | null
    initials: string | null
    createdAt: Date | null
  }

  export type AppointmentsCountAggregateOutputType = {
    id: number
    patientId: number
    patient: number
    doctorId: number
    doctorName: number
    type: number
    reason: number
    appointmentDate: number
    startTime: number
    endTime: number
    status: number
    notes: number
    initials: number
    createdAt: number
    _all: number
  }


  export type AppointmentsMinAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    doctorName?: true
    type?: true
    reason?: true
    appointmentDate?: true
    startTime?: true
    endTime?: true
    status?: true
    notes?: true
    initials?: true
    createdAt?: true
  }

  export type AppointmentsMaxAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    doctorName?: true
    type?: true
    reason?: true
    appointmentDate?: true
    startTime?: true
    endTime?: true
    status?: true
    notes?: true
    initials?: true
    createdAt?: true
  }

  export type AppointmentsCountAggregateInputType = {
    id?: true
    patientId?: true
    patient?: true
    doctorId?: true
    doctorName?: true
    type?: true
    reason?: true
    appointmentDate?: true
    startTime?: true
    endTime?: true
    status?: true
    notes?: true
    initials?: true
    createdAt?: true
    _all?: true
  }

  export type AppointmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which appointments to aggregate.
     */
    where?: appointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: appointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned appointments
    **/
    _count?: true | AppointmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentsMaxAggregateInputType
  }

  export type GetAppointmentsAggregateType<T extends AppointmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointments[P]>
      : GetScalarType<T[P], AggregateAppointments[P]>
  }




  export type appointmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appointmentsWhereInput
    orderBy?: appointmentsOrderByWithAggregationInput | appointmentsOrderByWithAggregationInput[]
    by: AppointmentsScalarFieldEnum[] | AppointmentsScalarFieldEnum
    having?: appointmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentsCountAggregateInputType | true
    _min?: AppointmentsMinAggregateInputType
    _max?: AppointmentsMaxAggregateInputType
  }

  export type AppointmentsGroupByOutputType = {
    id: string
    patientId: string | null
    patient: JsonValue | null
    doctorId: string | null
    doctorName: string | null
    type: string | null
    reason: string | null
    appointmentDate: string | null
    startTime: string | null
    endTime: string | null
    status: string
    notes: string | null
    initials: string | null
    createdAt: Date
    _count: AppointmentsCountAggregateOutputType | null
    _min: AppointmentsMinAggregateOutputType | null
    _max: AppointmentsMaxAggregateOutputType | null
  }

  type GetAppointmentsGroupByPayload<T extends appointmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentsGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentsGroupByOutputType[P]>
        }
      >
    >


  export type appointmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    doctorId?: boolean
    doctorName?: boolean
    type?: boolean
    reason?: boolean
    appointmentDate?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    notes?: boolean
    initials?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["appointments"]>

  export type appointmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    doctorId?: boolean
    doctorName?: boolean
    type?: boolean
    reason?: boolean
    appointmentDate?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    notes?: boolean
    initials?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["appointments"]>

  export type appointmentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    doctorId?: boolean
    doctorName?: boolean
    type?: boolean
    reason?: boolean
    appointmentDate?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    notes?: boolean
    initials?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["appointments"]>

  export type appointmentsSelectScalar = {
    id?: boolean
    patientId?: boolean
    patient?: boolean
    doctorId?: boolean
    doctorName?: boolean
    type?: boolean
    reason?: boolean
    appointmentDate?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    notes?: boolean
    initials?: boolean
    createdAt?: boolean
  }

  export type appointmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "patient" | "doctorId" | "doctorName" | "type" | "reason" | "appointmentDate" | "startTime" | "endTime" | "status" | "notes" | "initials" | "createdAt", ExtArgs["result"]["appointments"]>

  export type $appointmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "appointments"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string | null
      patient: Prisma.JsonValue | null
      doctorId: string | null
      doctorName: string | null
      type: string | null
      reason: string | null
      appointmentDate: string | null
      startTime: string | null
      endTime: string | null
      status: string
      notes: string | null
      initials: string | null
      createdAt: Date
    }, ExtArgs["result"]["appointments"]>
    composites: {}
  }

  type appointmentsGetPayload<S extends boolean | null | undefined | appointmentsDefaultArgs> = $Result.GetResult<Prisma.$appointmentsPayload, S>

  type appointmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<appointmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentsCountAggregateInputType | true
    }

  export interface appointmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['appointments'], meta: { name: 'appointments' } }
    /**
     * Find zero or one Appointments that matches the filter.
     * @param {appointmentsFindUniqueArgs} args - Arguments to find a Appointments
     * @example
     * // Get one Appointments
     * const appointments = await prisma.appointments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends appointmentsFindUniqueArgs>(args: SelectSubset<T, appointmentsFindUniqueArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Appointments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {appointmentsFindUniqueOrThrowArgs} args - Arguments to find a Appointments
     * @example
     * // Get one Appointments
     * const appointments = await prisma.appointments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends appointmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, appointmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsFindFirstArgs} args - Arguments to find a Appointments
     * @example
     * // Get one Appointments
     * const appointments = await prisma.appointments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends appointmentsFindFirstArgs>(args?: SelectSubset<T, appointmentsFindFirstArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsFindFirstOrThrowArgs} args - Arguments to find a Appointments
     * @example
     * // Get one Appointments
     * const appointments = await prisma.appointments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends appointmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, appointmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointments.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentsWithIdOnly = await prisma.appointments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends appointmentsFindManyArgs>(args?: SelectSubset<T, appointmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Appointments.
     * @param {appointmentsCreateArgs} args - Arguments to create a Appointments.
     * @example
     * // Create one Appointments
     * const Appointments = await prisma.appointments.create({
     *   data: {
     *     // ... data to create a Appointments
     *   }
     * })
     * 
     */
    create<T extends appointmentsCreateArgs>(args: SelectSubset<T, appointmentsCreateArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Appointments.
     * @param {appointmentsCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointments = await prisma.appointments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends appointmentsCreateManyArgs>(args?: SelectSubset<T, appointmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {appointmentsCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointments = await prisma.appointments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentsWithIdOnly = await prisma.appointments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends appointmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, appointmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Appointments.
     * @param {appointmentsDeleteArgs} args - Arguments to delete one Appointments.
     * @example
     * // Delete one Appointments
     * const Appointments = await prisma.appointments.delete({
     *   where: {
     *     // ... filter to delete one Appointments
     *   }
     * })
     * 
     */
    delete<T extends appointmentsDeleteArgs>(args: SelectSubset<T, appointmentsDeleteArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Appointments.
     * @param {appointmentsUpdateArgs} args - Arguments to update one Appointments.
     * @example
     * // Update one Appointments
     * const appointments = await prisma.appointments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends appointmentsUpdateArgs>(args: SelectSubset<T, appointmentsUpdateArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Appointments.
     * @param {appointmentsDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends appointmentsDeleteManyArgs>(args?: SelectSubset<T, appointmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointments = await prisma.appointments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends appointmentsUpdateManyArgs>(args: SelectSubset<T, appointmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments and returns the data updated in the database.
     * @param {appointmentsUpdateManyAndReturnArgs} args - Arguments to update many Appointments.
     * @example
     * // Update many Appointments
     * const appointments = await prisma.appointments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Appointments and only return the `id`
     * const appointmentsWithIdOnly = await prisma.appointments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends appointmentsUpdateManyAndReturnArgs>(args: SelectSubset<T, appointmentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Appointments.
     * @param {appointmentsUpsertArgs} args - Arguments to update or create a Appointments.
     * @example
     * // Update or create a Appointments
     * const appointments = await prisma.appointments.upsert({
     *   create: {
     *     // ... data to create a Appointments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointments we want to update
     *   }
     * })
     */
    upsert<T extends appointmentsUpsertArgs>(args: SelectSubset<T, appointmentsUpsertArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointments.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends appointmentsCountArgs>(
      args?: Subset<T, appointmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentsAggregateArgs>(args: Subset<T, AppointmentsAggregateArgs>): Prisma.PrismaPromise<GetAppointmentsAggregateType<T>>

    /**
     * Group by Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends appointmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: appointmentsGroupByArgs['orderBy'] }
        : { orderBy?: appointmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, appointmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the appointments model
   */
  readonly fields: appointmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for appointments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__appointmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the appointments model
   */
  interface appointmentsFieldRefs {
    readonly id: FieldRef<"appointments", 'String'>
    readonly patientId: FieldRef<"appointments", 'String'>
    readonly patient: FieldRef<"appointments", 'Json'>
    readonly doctorId: FieldRef<"appointments", 'String'>
    readonly doctorName: FieldRef<"appointments", 'String'>
    readonly type: FieldRef<"appointments", 'String'>
    readonly reason: FieldRef<"appointments", 'String'>
    readonly appointmentDate: FieldRef<"appointments", 'String'>
    readonly startTime: FieldRef<"appointments", 'String'>
    readonly endTime: FieldRef<"appointments", 'String'>
    readonly status: FieldRef<"appointments", 'String'>
    readonly notes: FieldRef<"appointments", 'String'>
    readonly initials: FieldRef<"appointments", 'String'>
    readonly createdAt: FieldRef<"appointments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * appointments findUnique
   */
  export type appointmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Filter, which appointments to fetch.
     */
    where: appointmentsWhereUniqueInput
  }

  /**
   * appointments findUniqueOrThrow
   */
  export type appointmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Filter, which appointments to fetch.
     */
    where: appointmentsWhereUniqueInput
  }

  /**
   * appointments findFirst
   */
  export type appointmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Filter, which appointments to fetch.
     */
    where?: appointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for appointments.
     */
    cursor?: appointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of appointments.
     */
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * appointments findFirstOrThrow
   */
  export type appointmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Filter, which appointments to fetch.
     */
    where?: appointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for appointments.
     */
    cursor?: appointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of appointments.
     */
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * appointments findMany
   */
  export type appointmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Filter, which appointments to fetch.
     */
    where?: appointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing appointments.
     */
    cursor?: appointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * appointments create
   */
  export type appointmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * The data needed to create a appointments.
     */
    data: XOR<appointmentsCreateInput, appointmentsUncheckedCreateInput>
  }

  /**
   * appointments createMany
   */
  export type appointmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many appointments.
     */
    data: appointmentsCreateManyInput | appointmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * appointments createManyAndReturn
   */
  export type appointmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * The data used to create many appointments.
     */
    data: appointmentsCreateManyInput | appointmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * appointments update
   */
  export type appointmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * The data needed to update a appointments.
     */
    data: XOR<appointmentsUpdateInput, appointmentsUncheckedUpdateInput>
    /**
     * Choose, which appointments to update.
     */
    where: appointmentsWhereUniqueInput
  }

  /**
   * appointments updateMany
   */
  export type appointmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update appointments.
     */
    data: XOR<appointmentsUpdateManyMutationInput, appointmentsUncheckedUpdateManyInput>
    /**
     * Filter which appointments to update
     */
    where?: appointmentsWhereInput
    /**
     * Limit how many appointments to update.
     */
    limit?: number
  }

  /**
   * appointments updateManyAndReturn
   */
  export type appointmentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * The data used to update appointments.
     */
    data: XOR<appointmentsUpdateManyMutationInput, appointmentsUncheckedUpdateManyInput>
    /**
     * Filter which appointments to update
     */
    where?: appointmentsWhereInput
    /**
     * Limit how many appointments to update.
     */
    limit?: number
  }

  /**
   * appointments upsert
   */
  export type appointmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * The filter to search for the appointments to update in case it exists.
     */
    where: appointmentsWhereUniqueInput
    /**
     * In case the appointments found by the `where` argument doesn't exist, create a new appointments with this data.
     */
    create: XOR<appointmentsCreateInput, appointmentsUncheckedCreateInput>
    /**
     * In case the appointments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<appointmentsUpdateInput, appointmentsUncheckedUpdateInput>
  }

  /**
   * appointments delete
   */
  export type appointmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Filter which appointments to delete.
     */
    where: appointmentsWhereUniqueInput
  }

  /**
   * appointments deleteMany
   */
  export type appointmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which appointments to delete
     */
    where?: appointmentsWhereInput
    /**
     * Limit how many appointments to delete.
     */
    limit?: number
  }

  /**
   * appointments without action
   */
  export type appointmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
  }


  /**
   * Model admissions
   */

  export type AggregateAdmissions = {
    _count: AdmissionsCountAggregateOutputType | null
    _avg: AdmissionsAvgAggregateOutputType | null
    _sum: AdmissionsSumAggregateOutputType | null
    _min: AdmissionsMinAggregateOutputType | null
    _max: AdmissionsMaxAggregateOutputType | null
  }

  export type AdmissionsAvgAggregateOutputType = {
    bedNumber: number | null
  }

  export type AdmissionsSumAggregateOutputType = {
    bedNumber: number | null
  }

  export type AdmissionsMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    unit: string | null
    bedNumber: number | null
    reason: string | null
    status: string | null
    admittedAt: Date | null
    dischargedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdmissionsMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    unit: string | null
    bedNumber: number | null
    reason: string | null
    status: string | null
    admittedAt: Date | null
    dischargedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdmissionsCountAggregateOutputType = {
    id: number
    patientId: number
    patient: number
    unit: number
    bedNumber: number
    reason: number
    status: number
    admittedAt: number
    dischargedAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdmissionsAvgAggregateInputType = {
    bedNumber?: true
  }

  export type AdmissionsSumAggregateInputType = {
    bedNumber?: true
  }

  export type AdmissionsMinAggregateInputType = {
    id?: true
    patientId?: true
    unit?: true
    bedNumber?: true
    reason?: true
    status?: true
    admittedAt?: true
    dischargedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdmissionsMaxAggregateInputType = {
    id?: true
    patientId?: true
    unit?: true
    bedNumber?: true
    reason?: true
    status?: true
    admittedAt?: true
    dischargedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdmissionsCountAggregateInputType = {
    id?: true
    patientId?: true
    patient?: true
    unit?: true
    bedNumber?: true
    reason?: true
    status?: true
    admittedAt?: true
    dischargedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdmissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admissions to aggregate.
     */
    where?: admissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admissions to fetch.
     */
    orderBy?: admissionsOrderByWithRelationInput | admissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: admissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admissions
    **/
    _count?: true | AdmissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdmissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdmissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdmissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdmissionsMaxAggregateInputType
  }

  export type GetAdmissionsAggregateType<T extends AdmissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmissions[P]>
      : GetScalarType<T[P], AggregateAdmissions[P]>
  }




  export type admissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: admissionsWhereInput
    orderBy?: admissionsOrderByWithAggregationInput | admissionsOrderByWithAggregationInput[]
    by: AdmissionsScalarFieldEnum[] | AdmissionsScalarFieldEnum
    having?: admissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdmissionsCountAggregateInputType | true
    _avg?: AdmissionsAvgAggregateInputType
    _sum?: AdmissionsSumAggregateInputType
    _min?: AdmissionsMinAggregateInputType
    _max?: AdmissionsMaxAggregateInputType
  }

  export type AdmissionsGroupByOutputType = {
    id: string
    patientId: string | null
    patient: JsonValue | null
    unit: string | null
    bedNumber: number | null
    reason: string | null
    status: string
    admittedAt: Date
    dischargedAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: AdmissionsCountAggregateOutputType | null
    _avg: AdmissionsAvgAggregateOutputType | null
    _sum: AdmissionsSumAggregateOutputType | null
    _min: AdmissionsMinAggregateOutputType | null
    _max: AdmissionsMaxAggregateOutputType | null
  }

  type GetAdmissionsGroupByPayload<T extends admissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdmissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdmissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdmissionsGroupByOutputType[P]>
            : GetScalarType<T[P], AdmissionsGroupByOutputType[P]>
        }
      >
    >


  export type admissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    unit?: boolean
    bedNumber?: boolean
    reason?: boolean
    status?: boolean
    admittedAt?: boolean
    dischargedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["admissions"]>

  export type admissionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    unit?: boolean
    bedNumber?: boolean
    reason?: boolean
    status?: boolean
    admittedAt?: boolean
    dischargedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["admissions"]>

  export type admissionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    unit?: boolean
    bedNumber?: boolean
    reason?: boolean
    status?: boolean
    admittedAt?: boolean
    dischargedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["admissions"]>

  export type admissionsSelectScalar = {
    id?: boolean
    patientId?: boolean
    patient?: boolean
    unit?: boolean
    bedNumber?: boolean
    reason?: boolean
    status?: boolean
    admittedAt?: boolean
    dischargedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type admissionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "patient" | "unit" | "bedNumber" | "reason" | "status" | "admittedAt" | "dischargedAt" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["admissions"]>

  export type $admissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admissions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string | null
      patient: Prisma.JsonValue | null
      unit: string | null
      bedNumber: number | null
      reason: string | null
      status: string
      admittedAt: Date
      dischargedAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admissions"]>
    composites: {}
  }

  type admissionsGetPayload<S extends boolean | null | undefined | admissionsDefaultArgs> = $Result.GetResult<Prisma.$admissionsPayload, S>

  type admissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<admissionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdmissionsCountAggregateInputType | true
    }

  export interface admissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admissions'], meta: { name: 'admissions' } }
    /**
     * Find zero or one Admissions that matches the filter.
     * @param {admissionsFindUniqueArgs} args - Arguments to find a Admissions
     * @example
     * // Get one Admissions
     * const admissions = await prisma.admissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends admissionsFindUniqueArgs>(args: SelectSubset<T, admissionsFindUniqueArgs<ExtArgs>>): Prisma__admissionsClient<$Result.GetResult<Prisma.$admissionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admissions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {admissionsFindUniqueOrThrowArgs} args - Arguments to find a Admissions
     * @example
     * // Get one Admissions
     * const admissions = await prisma.admissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends admissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, admissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__admissionsClient<$Result.GetResult<Prisma.$admissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admissionsFindFirstArgs} args - Arguments to find a Admissions
     * @example
     * // Get one Admissions
     * const admissions = await prisma.admissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends admissionsFindFirstArgs>(args?: SelectSubset<T, admissionsFindFirstArgs<ExtArgs>>): Prisma__admissionsClient<$Result.GetResult<Prisma.$admissionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admissionsFindFirstOrThrowArgs} args - Arguments to find a Admissions
     * @example
     * // Get one Admissions
     * const admissions = await prisma.admissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends admissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, admissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__admissionsClient<$Result.GetResult<Prisma.$admissionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admissions
     * const admissions = await prisma.admissions.findMany()
     * 
     * // Get first 10 Admissions
     * const admissions = await prisma.admissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admissionsWithIdOnly = await prisma.admissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends admissionsFindManyArgs>(args?: SelectSubset<T, admissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admissions.
     * @param {admissionsCreateArgs} args - Arguments to create a Admissions.
     * @example
     * // Create one Admissions
     * const Admissions = await prisma.admissions.create({
     *   data: {
     *     // ... data to create a Admissions
     *   }
     * })
     * 
     */
    create<T extends admissionsCreateArgs>(args: SelectSubset<T, admissionsCreateArgs<ExtArgs>>): Prisma__admissionsClient<$Result.GetResult<Prisma.$admissionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admissions.
     * @param {admissionsCreateManyArgs} args - Arguments to create many Admissions.
     * @example
     * // Create many Admissions
     * const admissions = await prisma.admissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends admissionsCreateManyArgs>(args?: SelectSubset<T, admissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admissions and returns the data saved in the database.
     * @param {admissionsCreateManyAndReturnArgs} args - Arguments to create many Admissions.
     * @example
     * // Create many Admissions
     * const admissions = await prisma.admissions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admissions and only return the `id`
     * const admissionsWithIdOnly = await prisma.admissions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends admissionsCreateManyAndReturnArgs>(args?: SelectSubset<T, admissionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admissionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admissions.
     * @param {admissionsDeleteArgs} args - Arguments to delete one Admissions.
     * @example
     * // Delete one Admissions
     * const Admissions = await prisma.admissions.delete({
     *   where: {
     *     // ... filter to delete one Admissions
     *   }
     * })
     * 
     */
    delete<T extends admissionsDeleteArgs>(args: SelectSubset<T, admissionsDeleteArgs<ExtArgs>>): Prisma__admissionsClient<$Result.GetResult<Prisma.$admissionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admissions.
     * @param {admissionsUpdateArgs} args - Arguments to update one Admissions.
     * @example
     * // Update one Admissions
     * const admissions = await prisma.admissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends admissionsUpdateArgs>(args: SelectSubset<T, admissionsUpdateArgs<ExtArgs>>): Prisma__admissionsClient<$Result.GetResult<Prisma.$admissionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admissions.
     * @param {admissionsDeleteManyArgs} args - Arguments to filter Admissions to delete.
     * @example
     * // Delete a few Admissions
     * const { count } = await prisma.admissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends admissionsDeleteManyArgs>(args?: SelectSubset<T, admissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admissions
     * const admissions = await prisma.admissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends admissionsUpdateManyArgs>(args: SelectSubset<T, admissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admissions and returns the data updated in the database.
     * @param {admissionsUpdateManyAndReturnArgs} args - Arguments to update many Admissions.
     * @example
     * // Update many Admissions
     * const admissions = await prisma.admissions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admissions and only return the `id`
     * const admissionsWithIdOnly = await prisma.admissions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends admissionsUpdateManyAndReturnArgs>(args: SelectSubset<T, admissionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admissionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admissions.
     * @param {admissionsUpsertArgs} args - Arguments to update or create a Admissions.
     * @example
     * // Update or create a Admissions
     * const admissions = await prisma.admissions.upsert({
     *   create: {
     *     // ... data to create a Admissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admissions we want to update
     *   }
     * })
     */
    upsert<T extends admissionsUpsertArgs>(args: SelectSubset<T, admissionsUpsertArgs<ExtArgs>>): Prisma__admissionsClient<$Result.GetResult<Prisma.$admissionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admissionsCountArgs} args - Arguments to filter Admissions to count.
     * @example
     * // Count the number of Admissions
     * const count = await prisma.admissions.count({
     *   where: {
     *     // ... the filter for the Admissions we want to count
     *   }
     * })
    **/
    count<T extends admissionsCountArgs>(
      args?: Subset<T, admissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdmissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdmissionsAggregateArgs>(args: Subset<T, AdmissionsAggregateArgs>): Prisma.PrismaPromise<GetAdmissionsAggregateType<T>>

    /**
     * Group by Admissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends admissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: admissionsGroupByArgs['orderBy'] }
        : { orderBy?: admissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, admissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admissions model
   */
  readonly fields: admissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__admissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admissions model
   */
  interface admissionsFieldRefs {
    readonly id: FieldRef<"admissions", 'String'>
    readonly patientId: FieldRef<"admissions", 'String'>
    readonly patient: FieldRef<"admissions", 'Json'>
    readonly unit: FieldRef<"admissions", 'String'>
    readonly bedNumber: FieldRef<"admissions", 'Int'>
    readonly reason: FieldRef<"admissions", 'String'>
    readonly status: FieldRef<"admissions", 'String'>
    readonly admittedAt: FieldRef<"admissions", 'DateTime'>
    readonly dischargedAt: FieldRef<"admissions", 'DateTime'>
    readonly notes: FieldRef<"admissions", 'String'>
    readonly createdAt: FieldRef<"admissions", 'DateTime'>
    readonly updatedAt: FieldRef<"admissions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * admissions findUnique
   */
  export type admissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admissions
     */
    select?: admissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admissions
     */
    omit?: admissionsOmit<ExtArgs> | null
    /**
     * Filter, which admissions to fetch.
     */
    where: admissionsWhereUniqueInput
  }

  /**
   * admissions findUniqueOrThrow
   */
  export type admissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admissions
     */
    select?: admissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admissions
     */
    omit?: admissionsOmit<ExtArgs> | null
    /**
     * Filter, which admissions to fetch.
     */
    where: admissionsWhereUniqueInput
  }

  /**
   * admissions findFirst
   */
  export type admissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admissions
     */
    select?: admissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admissions
     */
    omit?: admissionsOmit<ExtArgs> | null
    /**
     * Filter, which admissions to fetch.
     */
    where?: admissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admissions to fetch.
     */
    orderBy?: admissionsOrderByWithRelationInput | admissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admissions.
     */
    cursor?: admissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admissions.
     */
    distinct?: AdmissionsScalarFieldEnum | AdmissionsScalarFieldEnum[]
  }

  /**
   * admissions findFirstOrThrow
   */
  export type admissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admissions
     */
    select?: admissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admissions
     */
    omit?: admissionsOmit<ExtArgs> | null
    /**
     * Filter, which admissions to fetch.
     */
    where?: admissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admissions to fetch.
     */
    orderBy?: admissionsOrderByWithRelationInput | admissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admissions.
     */
    cursor?: admissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admissions.
     */
    distinct?: AdmissionsScalarFieldEnum | AdmissionsScalarFieldEnum[]
  }

  /**
   * admissions findMany
   */
  export type admissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admissions
     */
    select?: admissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admissions
     */
    omit?: admissionsOmit<ExtArgs> | null
    /**
     * Filter, which admissions to fetch.
     */
    where?: admissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admissions to fetch.
     */
    orderBy?: admissionsOrderByWithRelationInput | admissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admissions.
     */
    cursor?: admissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admissions.
     */
    skip?: number
    distinct?: AdmissionsScalarFieldEnum | AdmissionsScalarFieldEnum[]
  }

  /**
   * admissions create
   */
  export type admissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admissions
     */
    select?: admissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admissions
     */
    omit?: admissionsOmit<ExtArgs> | null
    /**
     * The data needed to create a admissions.
     */
    data: XOR<admissionsCreateInput, admissionsUncheckedCreateInput>
  }

  /**
   * admissions createMany
   */
  export type admissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admissions.
     */
    data: admissionsCreateManyInput | admissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admissions createManyAndReturn
   */
  export type admissionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admissions
     */
    select?: admissionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admissions
     */
    omit?: admissionsOmit<ExtArgs> | null
    /**
     * The data used to create many admissions.
     */
    data: admissionsCreateManyInput | admissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admissions update
   */
  export type admissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admissions
     */
    select?: admissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admissions
     */
    omit?: admissionsOmit<ExtArgs> | null
    /**
     * The data needed to update a admissions.
     */
    data: XOR<admissionsUpdateInput, admissionsUncheckedUpdateInput>
    /**
     * Choose, which admissions to update.
     */
    where: admissionsWhereUniqueInput
  }

  /**
   * admissions updateMany
   */
  export type admissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admissions.
     */
    data: XOR<admissionsUpdateManyMutationInput, admissionsUncheckedUpdateManyInput>
    /**
     * Filter which admissions to update
     */
    where?: admissionsWhereInput
    /**
     * Limit how many admissions to update.
     */
    limit?: number
  }

  /**
   * admissions updateManyAndReturn
   */
  export type admissionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admissions
     */
    select?: admissionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admissions
     */
    omit?: admissionsOmit<ExtArgs> | null
    /**
     * The data used to update admissions.
     */
    data: XOR<admissionsUpdateManyMutationInput, admissionsUncheckedUpdateManyInput>
    /**
     * Filter which admissions to update
     */
    where?: admissionsWhereInput
    /**
     * Limit how many admissions to update.
     */
    limit?: number
  }

  /**
   * admissions upsert
   */
  export type admissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admissions
     */
    select?: admissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admissions
     */
    omit?: admissionsOmit<ExtArgs> | null
    /**
     * The filter to search for the admissions to update in case it exists.
     */
    where: admissionsWhereUniqueInput
    /**
     * In case the admissions found by the `where` argument doesn't exist, create a new admissions with this data.
     */
    create: XOR<admissionsCreateInput, admissionsUncheckedCreateInput>
    /**
     * In case the admissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<admissionsUpdateInput, admissionsUncheckedUpdateInput>
  }

  /**
   * admissions delete
   */
  export type admissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admissions
     */
    select?: admissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admissions
     */
    omit?: admissionsOmit<ExtArgs> | null
    /**
     * Filter which admissions to delete.
     */
    where: admissionsWhereUniqueInput
  }

  /**
   * admissions deleteMany
   */
  export type admissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admissions to delete
     */
    where?: admissionsWhereInput
    /**
     * Limit how many admissions to delete.
     */
    limit?: number
  }

  /**
   * admissions without action
   */
  export type admissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admissions
     */
    select?: admissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admissions
     */
    omit?: admissionsOmit<ExtArgs> | null
  }


  /**
   * Model drugs
   */

  export type AggregateDrugs = {
    _count: DrugsCountAggregateOutputType | null
    _avg: DrugsAvgAggregateOutputType | null
    _sum: DrugsSumAggregateOutputType | null
    _min: DrugsMinAggregateOutputType | null
    _max: DrugsMaxAggregateOutputType | null
  }

  export type DrugsAvgAggregateOutputType = {
    price: number | null
    quantityInStock: number | null
    reorderLevel: number | null
  }

  export type DrugsSumAggregateOutputType = {
    price: number | null
    quantityInStock: number | null
    reorderLevel: number | null
  }

  export type DrugsMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    dosageForm: string | null
    strength: string | null
    unit: string | null
    price: number | null
    quantityInStock: number | null
    reorderLevel: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type DrugsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    dosageForm: string | null
    strength: string | null
    unit: string | null
    price: number | null
    quantityInStock: number | null
    reorderLevel: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type DrugsCountAggregateOutputType = {
    id: number
    name: number
    category: number
    dosageForm: number
    strength: number
    unit: number
    price: number
    quantityInStock: number
    reorderLevel: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type DrugsAvgAggregateInputType = {
    price?: true
    quantityInStock?: true
    reorderLevel?: true
  }

  export type DrugsSumAggregateInputType = {
    price?: true
    quantityInStock?: true
    reorderLevel?: true
  }

  export type DrugsMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    dosageForm?: true
    strength?: true
    unit?: true
    price?: true
    quantityInStock?: true
    reorderLevel?: true
    isActive?: true
    createdAt?: true
  }

  export type DrugsMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    dosageForm?: true
    strength?: true
    unit?: true
    price?: true
    quantityInStock?: true
    reorderLevel?: true
    isActive?: true
    createdAt?: true
  }

  export type DrugsCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    dosageForm?: true
    strength?: true
    unit?: true
    price?: true
    quantityInStock?: true
    reorderLevel?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type DrugsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which drugs to aggregate.
     */
    where?: drugsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drugs to fetch.
     */
    orderBy?: drugsOrderByWithRelationInput | drugsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: drugsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drugs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drugs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned drugs
    **/
    _count?: true | DrugsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DrugsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DrugsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DrugsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DrugsMaxAggregateInputType
  }

  export type GetDrugsAggregateType<T extends DrugsAggregateArgs> = {
        [P in keyof T & keyof AggregateDrugs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDrugs[P]>
      : GetScalarType<T[P], AggregateDrugs[P]>
  }




  export type drugsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: drugsWhereInput
    orderBy?: drugsOrderByWithAggregationInput | drugsOrderByWithAggregationInput[]
    by: DrugsScalarFieldEnum[] | DrugsScalarFieldEnum
    having?: drugsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DrugsCountAggregateInputType | true
    _avg?: DrugsAvgAggregateInputType
    _sum?: DrugsSumAggregateInputType
    _min?: DrugsMinAggregateInputType
    _max?: DrugsMaxAggregateInputType
  }

  export type DrugsGroupByOutputType = {
    id: string
    name: string
    category: string | null
    dosageForm: string | null
    strength: string | null
    unit: string | null
    price: number | null
    quantityInStock: number
    reorderLevel: number
    isActive: boolean
    createdAt: Date
    _count: DrugsCountAggregateOutputType | null
    _avg: DrugsAvgAggregateOutputType | null
    _sum: DrugsSumAggregateOutputType | null
    _min: DrugsMinAggregateOutputType | null
    _max: DrugsMaxAggregateOutputType | null
  }

  type GetDrugsGroupByPayload<T extends drugsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DrugsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DrugsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DrugsGroupByOutputType[P]>
            : GetScalarType<T[P], DrugsGroupByOutputType[P]>
        }
      >
    >


  export type drugsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    dosageForm?: boolean
    strength?: boolean
    unit?: boolean
    price?: boolean
    quantityInStock?: boolean
    reorderLevel?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["drugs"]>

  export type drugsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    dosageForm?: boolean
    strength?: boolean
    unit?: boolean
    price?: boolean
    quantityInStock?: boolean
    reorderLevel?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["drugs"]>

  export type drugsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    dosageForm?: boolean
    strength?: boolean
    unit?: boolean
    price?: boolean
    quantityInStock?: boolean
    reorderLevel?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["drugs"]>

  export type drugsSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    dosageForm?: boolean
    strength?: boolean
    unit?: boolean
    price?: boolean
    quantityInStock?: boolean
    reorderLevel?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type drugsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "dosageForm" | "strength" | "unit" | "price" | "quantityInStock" | "reorderLevel" | "isActive" | "createdAt", ExtArgs["result"]["drugs"]>

  export type $drugsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "drugs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: string | null
      dosageForm: string | null
      strength: string | null
      unit: string | null
      price: number | null
      quantityInStock: number
      reorderLevel: number
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["drugs"]>
    composites: {}
  }

  type drugsGetPayload<S extends boolean | null | undefined | drugsDefaultArgs> = $Result.GetResult<Prisma.$drugsPayload, S>

  type drugsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<drugsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DrugsCountAggregateInputType | true
    }

  export interface drugsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['drugs'], meta: { name: 'drugs' } }
    /**
     * Find zero or one Drugs that matches the filter.
     * @param {drugsFindUniqueArgs} args - Arguments to find a Drugs
     * @example
     * // Get one Drugs
     * const drugs = await prisma.drugs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends drugsFindUniqueArgs>(args: SelectSubset<T, drugsFindUniqueArgs<ExtArgs>>): Prisma__drugsClient<$Result.GetResult<Prisma.$drugsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Drugs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {drugsFindUniqueOrThrowArgs} args - Arguments to find a Drugs
     * @example
     * // Get one Drugs
     * const drugs = await prisma.drugs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends drugsFindUniqueOrThrowArgs>(args: SelectSubset<T, drugsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__drugsClient<$Result.GetResult<Prisma.$drugsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Drugs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drugsFindFirstArgs} args - Arguments to find a Drugs
     * @example
     * // Get one Drugs
     * const drugs = await prisma.drugs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends drugsFindFirstArgs>(args?: SelectSubset<T, drugsFindFirstArgs<ExtArgs>>): Prisma__drugsClient<$Result.GetResult<Prisma.$drugsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Drugs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drugsFindFirstOrThrowArgs} args - Arguments to find a Drugs
     * @example
     * // Get one Drugs
     * const drugs = await prisma.drugs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends drugsFindFirstOrThrowArgs>(args?: SelectSubset<T, drugsFindFirstOrThrowArgs<ExtArgs>>): Prisma__drugsClient<$Result.GetResult<Prisma.$drugsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Drugs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drugsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drugs
     * const drugs = await prisma.drugs.findMany()
     * 
     * // Get first 10 Drugs
     * const drugs = await prisma.drugs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const drugsWithIdOnly = await prisma.drugs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends drugsFindManyArgs>(args?: SelectSubset<T, drugsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$drugsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Drugs.
     * @param {drugsCreateArgs} args - Arguments to create a Drugs.
     * @example
     * // Create one Drugs
     * const Drugs = await prisma.drugs.create({
     *   data: {
     *     // ... data to create a Drugs
     *   }
     * })
     * 
     */
    create<T extends drugsCreateArgs>(args: SelectSubset<T, drugsCreateArgs<ExtArgs>>): Prisma__drugsClient<$Result.GetResult<Prisma.$drugsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Drugs.
     * @param {drugsCreateManyArgs} args - Arguments to create many Drugs.
     * @example
     * // Create many Drugs
     * const drugs = await prisma.drugs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends drugsCreateManyArgs>(args?: SelectSubset<T, drugsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Drugs and returns the data saved in the database.
     * @param {drugsCreateManyAndReturnArgs} args - Arguments to create many Drugs.
     * @example
     * // Create many Drugs
     * const drugs = await prisma.drugs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Drugs and only return the `id`
     * const drugsWithIdOnly = await prisma.drugs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends drugsCreateManyAndReturnArgs>(args?: SelectSubset<T, drugsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$drugsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Drugs.
     * @param {drugsDeleteArgs} args - Arguments to delete one Drugs.
     * @example
     * // Delete one Drugs
     * const Drugs = await prisma.drugs.delete({
     *   where: {
     *     // ... filter to delete one Drugs
     *   }
     * })
     * 
     */
    delete<T extends drugsDeleteArgs>(args: SelectSubset<T, drugsDeleteArgs<ExtArgs>>): Prisma__drugsClient<$Result.GetResult<Prisma.$drugsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Drugs.
     * @param {drugsUpdateArgs} args - Arguments to update one Drugs.
     * @example
     * // Update one Drugs
     * const drugs = await prisma.drugs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends drugsUpdateArgs>(args: SelectSubset<T, drugsUpdateArgs<ExtArgs>>): Prisma__drugsClient<$Result.GetResult<Prisma.$drugsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Drugs.
     * @param {drugsDeleteManyArgs} args - Arguments to filter Drugs to delete.
     * @example
     * // Delete a few Drugs
     * const { count } = await prisma.drugs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends drugsDeleteManyArgs>(args?: SelectSubset<T, drugsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drugs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drugsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drugs
     * const drugs = await prisma.drugs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends drugsUpdateManyArgs>(args: SelectSubset<T, drugsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drugs and returns the data updated in the database.
     * @param {drugsUpdateManyAndReturnArgs} args - Arguments to update many Drugs.
     * @example
     * // Update many Drugs
     * const drugs = await prisma.drugs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Drugs and only return the `id`
     * const drugsWithIdOnly = await prisma.drugs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends drugsUpdateManyAndReturnArgs>(args: SelectSubset<T, drugsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$drugsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Drugs.
     * @param {drugsUpsertArgs} args - Arguments to update or create a Drugs.
     * @example
     * // Update or create a Drugs
     * const drugs = await prisma.drugs.upsert({
     *   create: {
     *     // ... data to create a Drugs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Drugs we want to update
     *   }
     * })
     */
    upsert<T extends drugsUpsertArgs>(args: SelectSubset<T, drugsUpsertArgs<ExtArgs>>): Prisma__drugsClient<$Result.GetResult<Prisma.$drugsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Drugs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drugsCountArgs} args - Arguments to filter Drugs to count.
     * @example
     * // Count the number of Drugs
     * const count = await prisma.drugs.count({
     *   where: {
     *     // ... the filter for the Drugs we want to count
     *   }
     * })
    **/
    count<T extends drugsCountArgs>(
      args?: Subset<T, drugsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DrugsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Drugs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DrugsAggregateArgs>(args: Subset<T, DrugsAggregateArgs>): Prisma.PrismaPromise<GetDrugsAggregateType<T>>

    /**
     * Group by Drugs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drugsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends drugsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: drugsGroupByArgs['orderBy'] }
        : { orderBy?: drugsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, drugsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDrugsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the drugs model
   */
  readonly fields: drugsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for drugs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__drugsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the drugs model
   */
  interface drugsFieldRefs {
    readonly id: FieldRef<"drugs", 'String'>
    readonly name: FieldRef<"drugs", 'String'>
    readonly category: FieldRef<"drugs", 'String'>
    readonly dosageForm: FieldRef<"drugs", 'String'>
    readonly strength: FieldRef<"drugs", 'String'>
    readonly unit: FieldRef<"drugs", 'String'>
    readonly price: FieldRef<"drugs", 'Float'>
    readonly quantityInStock: FieldRef<"drugs", 'Int'>
    readonly reorderLevel: FieldRef<"drugs", 'Int'>
    readonly isActive: FieldRef<"drugs", 'Boolean'>
    readonly createdAt: FieldRef<"drugs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * drugs findUnique
   */
  export type drugsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drugs
     */
    select?: drugsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drugs
     */
    omit?: drugsOmit<ExtArgs> | null
    /**
     * Filter, which drugs to fetch.
     */
    where: drugsWhereUniqueInput
  }

  /**
   * drugs findUniqueOrThrow
   */
  export type drugsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drugs
     */
    select?: drugsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drugs
     */
    omit?: drugsOmit<ExtArgs> | null
    /**
     * Filter, which drugs to fetch.
     */
    where: drugsWhereUniqueInput
  }

  /**
   * drugs findFirst
   */
  export type drugsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drugs
     */
    select?: drugsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drugs
     */
    omit?: drugsOmit<ExtArgs> | null
    /**
     * Filter, which drugs to fetch.
     */
    where?: drugsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drugs to fetch.
     */
    orderBy?: drugsOrderByWithRelationInput | drugsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drugs.
     */
    cursor?: drugsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drugs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drugs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of drugs.
     */
    distinct?: DrugsScalarFieldEnum | DrugsScalarFieldEnum[]
  }

  /**
   * drugs findFirstOrThrow
   */
  export type drugsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drugs
     */
    select?: drugsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drugs
     */
    omit?: drugsOmit<ExtArgs> | null
    /**
     * Filter, which drugs to fetch.
     */
    where?: drugsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drugs to fetch.
     */
    orderBy?: drugsOrderByWithRelationInput | drugsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drugs.
     */
    cursor?: drugsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drugs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drugs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of drugs.
     */
    distinct?: DrugsScalarFieldEnum | DrugsScalarFieldEnum[]
  }

  /**
   * drugs findMany
   */
  export type drugsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drugs
     */
    select?: drugsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drugs
     */
    omit?: drugsOmit<ExtArgs> | null
    /**
     * Filter, which drugs to fetch.
     */
    where?: drugsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drugs to fetch.
     */
    orderBy?: drugsOrderByWithRelationInput | drugsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing drugs.
     */
    cursor?: drugsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drugs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drugs.
     */
    skip?: number
    distinct?: DrugsScalarFieldEnum | DrugsScalarFieldEnum[]
  }

  /**
   * drugs create
   */
  export type drugsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drugs
     */
    select?: drugsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drugs
     */
    omit?: drugsOmit<ExtArgs> | null
    /**
     * The data needed to create a drugs.
     */
    data: XOR<drugsCreateInput, drugsUncheckedCreateInput>
  }

  /**
   * drugs createMany
   */
  export type drugsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many drugs.
     */
    data: drugsCreateManyInput | drugsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * drugs createManyAndReturn
   */
  export type drugsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drugs
     */
    select?: drugsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the drugs
     */
    omit?: drugsOmit<ExtArgs> | null
    /**
     * The data used to create many drugs.
     */
    data: drugsCreateManyInput | drugsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * drugs update
   */
  export type drugsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drugs
     */
    select?: drugsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drugs
     */
    omit?: drugsOmit<ExtArgs> | null
    /**
     * The data needed to update a drugs.
     */
    data: XOR<drugsUpdateInput, drugsUncheckedUpdateInput>
    /**
     * Choose, which drugs to update.
     */
    where: drugsWhereUniqueInput
  }

  /**
   * drugs updateMany
   */
  export type drugsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update drugs.
     */
    data: XOR<drugsUpdateManyMutationInput, drugsUncheckedUpdateManyInput>
    /**
     * Filter which drugs to update
     */
    where?: drugsWhereInput
    /**
     * Limit how many drugs to update.
     */
    limit?: number
  }

  /**
   * drugs updateManyAndReturn
   */
  export type drugsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drugs
     */
    select?: drugsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the drugs
     */
    omit?: drugsOmit<ExtArgs> | null
    /**
     * The data used to update drugs.
     */
    data: XOR<drugsUpdateManyMutationInput, drugsUncheckedUpdateManyInput>
    /**
     * Filter which drugs to update
     */
    where?: drugsWhereInput
    /**
     * Limit how many drugs to update.
     */
    limit?: number
  }

  /**
   * drugs upsert
   */
  export type drugsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drugs
     */
    select?: drugsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drugs
     */
    omit?: drugsOmit<ExtArgs> | null
    /**
     * The filter to search for the drugs to update in case it exists.
     */
    where: drugsWhereUniqueInput
    /**
     * In case the drugs found by the `where` argument doesn't exist, create a new drugs with this data.
     */
    create: XOR<drugsCreateInput, drugsUncheckedCreateInput>
    /**
     * In case the drugs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<drugsUpdateInput, drugsUncheckedUpdateInput>
  }

  /**
   * drugs delete
   */
  export type drugsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drugs
     */
    select?: drugsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drugs
     */
    omit?: drugsOmit<ExtArgs> | null
    /**
     * Filter which drugs to delete.
     */
    where: drugsWhereUniqueInput
  }

  /**
   * drugs deleteMany
   */
  export type drugsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which drugs to delete
     */
    where?: drugsWhereInput
    /**
     * Limit how many drugs to delete.
     */
    limit?: number
  }

  /**
   * drugs without action
   */
  export type drugsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drugs
     */
    select?: drugsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drugs
     */
    omit?: drugsOmit<ExtArgs> | null
  }


  /**
   * Model lab_tests
   */

  export type AggregateLab_tests = {
    _count: Lab_testsCountAggregateOutputType | null
    _avg: Lab_testsAvgAggregateOutputType | null
    _sum: Lab_testsSumAggregateOutputType | null
    _min: Lab_testsMinAggregateOutputType | null
    _max: Lab_testsMaxAggregateOutputType | null
  }

  export type Lab_testsAvgAggregateOutputType = {
    price: number | null
  }

  export type Lab_testsSumAggregateOutputType = {
    price: number | null
  }

  export type Lab_testsMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    price: number | null
    turnaroundTime: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type Lab_testsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    price: number | null
    turnaroundTime: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type Lab_testsCountAggregateOutputType = {
    id: number
    name: number
    category: number
    price: number
    turnaroundTime: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type Lab_testsAvgAggregateInputType = {
    price?: true
  }

  export type Lab_testsSumAggregateInputType = {
    price?: true
  }

  export type Lab_testsMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    price?: true
    turnaroundTime?: true
    isActive?: true
    createdAt?: true
  }

  export type Lab_testsMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    price?: true
    turnaroundTime?: true
    isActive?: true
    createdAt?: true
  }

  export type Lab_testsCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    price?: true
    turnaroundTime?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type Lab_testsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lab_tests to aggregate.
     */
    where?: lab_testsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_tests to fetch.
     */
    orderBy?: lab_testsOrderByWithRelationInput | lab_testsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lab_testsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lab_tests
    **/
    _count?: true | Lab_testsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lab_testsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lab_testsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lab_testsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lab_testsMaxAggregateInputType
  }

  export type GetLab_testsAggregateType<T extends Lab_testsAggregateArgs> = {
        [P in keyof T & keyof AggregateLab_tests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLab_tests[P]>
      : GetScalarType<T[P], AggregateLab_tests[P]>
  }




  export type lab_testsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lab_testsWhereInput
    orderBy?: lab_testsOrderByWithAggregationInput | lab_testsOrderByWithAggregationInput[]
    by: Lab_testsScalarFieldEnum[] | Lab_testsScalarFieldEnum
    having?: lab_testsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lab_testsCountAggregateInputType | true
    _avg?: Lab_testsAvgAggregateInputType
    _sum?: Lab_testsSumAggregateInputType
    _min?: Lab_testsMinAggregateInputType
    _max?: Lab_testsMaxAggregateInputType
  }

  export type Lab_testsGroupByOutputType = {
    id: string
    name: string
    category: string | null
    price: number | null
    turnaroundTime: string | null
    isActive: boolean
    createdAt: Date
    _count: Lab_testsCountAggregateOutputType | null
    _avg: Lab_testsAvgAggregateOutputType | null
    _sum: Lab_testsSumAggregateOutputType | null
    _min: Lab_testsMinAggregateOutputType | null
    _max: Lab_testsMaxAggregateOutputType | null
  }

  type GetLab_testsGroupByPayload<T extends lab_testsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lab_testsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lab_testsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lab_testsGroupByOutputType[P]>
            : GetScalarType<T[P], Lab_testsGroupByOutputType[P]>
        }
      >
    >


  export type lab_testsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    price?: boolean
    turnaroundTime?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["lab_tests"]>

  export type lab_testsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    price?: boolean
    turnaroundTime?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["lab_tests"]>

  export type lab_testsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    price?: boolean
    turnaroundTime?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["lab_tests"]>

  export type lab_testsSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    price?: boolean
    turnaroundTime?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type lab_testsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "price" | "turnaroundTime" | "isActive" | "createdAt", ExtArgs["result"]["lab_tests"]>

  export type $lab_testsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lab_tests"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: string | null
      price: number | null
      turnaroundTime: string | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["lab_tests"]>
    composites: {}
  }

  type lab_testsGetPayload<S extends boolean | null | undefined | lab_testsDefaultArgs> = $Result.GetResult<Prisma.$lab_testsPayload, S>

  type lab_testsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<lab_testsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Lab_testsCountAggregateInputType | true
    }

  export interface lab_testsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lab_tests'], meta: { name: 'lab_tests' } }
    /**
     * Find zero or one Lab_tests that matches the filter.
     * @param {lab_testsFindUniqueArgs} args - Arguments to find a Lab_tests
     * @example
     * // Get one Lab_tests
     * const lab_tests = await prisma.lab_tests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends lab_testsFindUniqueArgs>(args: SelectSubset<T, lab_testsFindUniqueArgs<ExtArgs>>): Prisma__lab_testsClient<$Result.GetResult<Prisma.$lab_testsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lab_tests that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {lab_testsFindUniqueOrThrowArgs} args - Arguments to find a Lab_tests
     * @example
     * // Get one Lab_tests
     * const lab_tests = await prisma.lab_tests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends lab_testsFindUniqueOrThrowArgs>(args: SelectSubset<T, lab_testsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__lab_testsClient<$Result.GetResult<Prisma.$lab_testsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lab_tests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_testsFindFirstArgs} args - Arguments to find a Lab_tests
     * @example
     * // Get one Lab_tests
     * const lab_tests = await prisma.lab_tests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends lab_testsFindFirstArgs>(args?: SelectSubset<T, lab_testsFindFirstArgs<ExtArgs>>): Prisma__lab_testsClient<$Result.GetResult<Prisma.$lab_testsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lab_tests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_testsFindFirstOrThrowArgs} args - Arguments to find a Lab_tests
     * @example
     * // Get one Lab_tests
     * const lab_tests = await prisma.lab_tests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends lab_testsFindFirstOrThrowArgs>(args?: SelectSubset<T, lab_testsFindFirstOrThrowArgs<ExtArgs>>): Prisma__lab_testsClient<$Result.GetResult<Prisma.$lab_testsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lab_tests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_testsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lab_tests
     * const lab_tests = await prisma.lab_tests.findMany()
     * 
     * // Get first 10 Lab_tests
     * const lab_tests = await prisma.lab_tests.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lab_testsWithIdOnly = await prisma.lab_tests.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends lab_testsFindManyArgs>(args?: SelectSubset<T, lab_testsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lab_testsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lab_tests.
     * @param {lab_testsCreateArgs} args - Arguments to create a Lab_tests.
     * @example
     * // Create one Lab_tests
     * const Lab_tests = await prisma.lab_tests.create({
     *   data: {
     *     // ... data to create a Lab_tests
     *   }
     * })
     * 
     */
    create<T extends lab_testsCreateArgs>(args: SelectSubset<T, lab_testsCreateArgs<ExtArgs>>): Prisma__lab_testsClient<$Result.GetResult<Prisma.$lab_testsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lab_tests.
     * @param {lab_testsCreateManyArgs} args - Arguments to create many Lab_tests.
     * @example
     * // Create many Lab_tests
     * const lab_tests = await prisma.lab_tests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends lab_testsCreateManyArgs>(args?: SelectSubset<T, lab_testsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lab_tests and returns the data saved in the database.
     * @param {lab_testsCreateManyAndReturnArgs} args - Arguments to create many Lab_tests.
     * @example
     * // Create many Lab_tests
     * const lab_tests = await prisma.lab_tests.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lab_tests and only return the `id`
     * const lab_testsWithIdOnly = await prisma.lab_tests.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends lab_testsCreateManyAndReturnArgs>(args?: SelectSubset<T, lab_testsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lab_testsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lab_tests.
     * @param {lab_testsDeleteArgs} args - Arguments to delete one Lab_tests.
     * @example
     * // Delete one Lab_tests
     * const Lab_tests = await prisma.lab_tests.delete({
     *   where: {
     *     // ... filter to delete one Lab_tests
     *   }
     * })
     * 
     */
    delete<T extends lab_testsDeleteArgs>(args: SelectSubset<T, lab_testsDeleteArgs<ExtArgs>>): Prisma__lab_testsClient<$Result.GetResult<Prisma.$lab_testsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lab_tests.
     * @param {lab_testsUpdateArgs} args - Arguments to update one Lab_tests.
     * @example
     * // Update one Lab_tests
     * const lab_tests = await prisma.lab_tests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends lab_testsUpdateArgs>(args: SelectSubset<T, lab_testsUpdateArgs<ExtArgs>>): Prisma__lab_testsClient<$Result.GetResult<Prisma.$lab_testsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lab_tests.
     * @param {lab_testsDeleteManyArgs} args - Arguments to filter Lab_tests to delete.
     * @example
     * // Delete a few Lab_tests
     * const { count } = await prisma.lab_tests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends lab_testsDeleteManyArgs>(args?: SelectSubset<T, lab_testsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lab_tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_testsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lab_tests
     * const lab_tests = await prisma.lab_tests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends lab_testsUpdateManyArgs>(args: SelectSubset<T, lab_testsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lab_tests and returns the data updated in the database.
     * @param {lab_testsUpdateManyAndReturnArgs} args - Arguments to update many Lab_tests.
     * @example
     * // Update many Lab_tests
     * const lab_tests = await prisma.lab_tests.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lab_tests and only return the `id`
     * const lab_testsWithIdOnly = await prisma.lab_tests.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends lab_testsUpdateManyAndReturnArgs>(args: SelectSubset<T, lab_testsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lab_testsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lab_tests.
     * @param {lab_testsUpsertArgs} args - Arguments to update or create a Lab_tests.
     * @example
     * // Update or create a Lab_tests
     * const lab_tests = await prisma.lab_tests.upsert({
     *   create: {
     *     // ... data to create a Lab_tests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lab_tests we want to update
     *   }
     * })
     */
    upsert<T extends lab_testsUpsertArgs>(args: SelectSubset<T, lab_testsUpsertArgs<ExtArgs>>): Prisma__lab_testsClient<$Result.GetResult<Prisma.$lab_testsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lab_tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_testsCountArgs} args - Arguments to filter Lab_tests to count.
     * @example
     * // Count the number of Lab_tests
     * const count = await prisma.lab_tests.count({
     *   where: {
     *     // ... the filter for the Lab_tests we want to count
     *   }
     * })
    **/
    count<T extends lab_testsCountArgs>(
      args?: Subset<T, lab_testsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lab_testsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lab_tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lab_testsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lab_testsAggregateArgs>(args: Subset<T, Lab_testsAggregateArgs>): Prisma.PrismaPromise<GetLab_testsAggregateType<T>>

    /**
     * Group by Lab_tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lab_testsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lab_testsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lab_testsGroupByArgs['orderBy'] }
        : { orderBy?: lab_testsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lab_testsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLab_testsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lab_tests model
   */
  readonly fields: lab_testsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lab_tests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__lab_testsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the lab_tests model
   */
  interface lab_testsFieldRefs {
    readonly id: FieldRef<"lab_tests", 'String'>
    readonly name: FieldRef<"lab_tests", 'String'>
    readonly category: FieldRef<"lab_tests", 'String'>
    readonly price: FieldRef<"lab_tests", 'Float'>
    readonly turnaroundTime: FieldRef<"lab_tests", 'String'>
    readonly isActive: FieldRef<"lab_tests", 'Boolean'>
    readonly createdAt: FieldRef<"lab_tests", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * lab_tests findUnique
   */
  export type lab_testsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_tests
     */
    select?: lab_testsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_tests
     */
    omit?: lab_testsOmit<ExtArgs> | null
    /**
     * Filter, which lab_tests to fetch.
     */
    where: lab_testsWhereUniqueInput
  }

  /**
   * lab_tests findUniqueOrThrow
   */
  export type lab_testsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_tests
     */
    select?: lab_testsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_tests
     */
    omit?: lab_testsOmit<ExtArgs> | null
    /**
     * Filter, which lab_tests to fetch.
     */
    where: lab_testsWhereUniqueInput
  }

  /**
   * lab_tests findFirst
   */
  export type lab_testsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_tests
     */
    select?: lab_testsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_tests
     */
    omit?: lab_testsOmit<ExtArgs> | null
    /**
     * Filter, which lab_tests to fetch.
     */
    where?: lab_testsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_tests to fetch.
     */
    orderBy?: lab_testsOrderByWithRelationInput | lab_testsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lab_tests.
     */
    cursor?: lab_testsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lab_tests.
     */
    distinct?: Lab_testsScalarFieldEnum | Lab_testsScalarFieldEnum[]
  }

  /**
   * lab_tests findFirstOrThrow
   */
  export type lab_testsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_tests
     */
    select?: lab_testsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_tests
     */
    omit?: lab_testsOmit<ExtArgs> | null
    /**
     * Filter, which lab_tests to fetch.
     */
    where?: lab_testsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_tests to fetch.
     */
    orderBy?: lab_testsOrderByWithRelationInput | lab_testsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lab_tests.
     */
    cursor?: lab_testsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lab_tests.
     */
    distinct?: Lab_testsScalarFieldEnum | Lab_testsScalarFieldEnum[]
  }

  /**
   * lab_tests findMany
   */
  export type lab_testsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_tests
     */
    select?: lab_testsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_tests
     */
    omit?: lab_testsOmit<ExtArgs> | null
    /**
     * Filter, which lab_tests to fetch.
     */
    where?: lab_testsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lab_tests to fetch.
     */
    orderBy?: lab_testsOrderByWithRelationInput | lab_testsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lab_tests.
     */
    cursor?: lab_testsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lab_tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lab_tests.
     */
    skip?: number
    distinct?: Lab_testsScalarFieldEnum | Lab_testsScalarFieldEnum[]
  }

  /**
   * lab_tests create
   */
  export type lab_testsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_tests
     */
    select?: lab_testsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_tests
     */
    omit?: lab_testsOmit<ExtArgs> | null
    /**
     * The data needed to create a lab_tests.
     */
    data: XOR<lab_testsCreateInput, lab_testsUncheckedCreateInput>
  }

  /**
   * lab_tests createMany
   */
  export type lab_testsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lab_tests.
     */
    data: lab_testsCreateManyInput | lab_testsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lab_tests createManyAndReturn
   */
  export type lab_testsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_tests
     */
    select?: lab_testsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the lab_tests
     */
    omit?: lab_testsOmit<ExtArgs> | null
    /**
     * The data used to create many lab_tests.
     */
    data: lab_testsCreateManyInput | lab_testsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lab_tests update
   */
  export type lab_testsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_tests
     */
    select?: lab_testsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_tests
     */
    omit?: lab_testsOmit<ExtArgs> | null
    /**
     * The data needed to update a lab_tests.
     */
    data: XOR<lab_testsUpdateInput, lab_testsUncheckedUpdateInput>
    /**
     * Choose, which lab_tests to update.
     */
    where: lab_testsWhereUniqueInput
  }

  /**
   * lab_tests updateMany
   */
  export type lab_testsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lab_tests.
     */
    data: XOR<lab_testsUpdateManyMutationInput, lab_testsUncheckedUpdateManyInput>
    /**
     * Filter which lab_tests to update
     */
    where?: lab_testsWhereInput
    /**
     * Limit how many lab_tests to update.
     */
    limit?: number
  }

  /**
   * lab_tests updateManyAndReturn
   */
  export type lab_testsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_tests
     */
    select?: lab_testsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the lab_tests
     */
    omit?: lab_testsOmit<ExtArgs> | null
    /**
     * The data used to update lab_tests.
     */
    data: XOR<lab_testsUpdateManyMutationInput, lab_testsUncheckedUpdateManyInput>
    /**
     * Filter which lab_tests to update
     */
    where?: lab_testsWhereInput
    /**
     * Limit how many lab_tests to update.
     */
    limit?: number
  }

  /**
   * lab_tests upsert
   */
  export type lab_testsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_tests
     */
    select?: lab_testsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_tests
     */
    omit?: lab_testsOmit<ExtArgs> | null
    /**
     * The filter to search for the lab_tests to update in case it exists.
     */
    where: lab_testsWhereUniqueInput
    /**
     * In case the lab_tests found by the `where` argument doesn't exist, create a new lab_tests with this data.
     */
    create: XOR<lab_testsCreateInput, lab_testsUncheckedCreateInput>
    /**
     * In case the lab_tests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lab_testsUpdateInput, lab_testsUncheckedUpdateInput>
  }

  /**
   * lab_tests delete
   */
  export type lab_testsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_tests
     */
    select?: lab_testsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_tests
     */
    omit?: lab_testsOmit<ExtArgs> | null
    /**
     * Filter which lab_tests to delete.
     */
    where: lab_testsWhereUniqueInput
  }

  /**
   * lab_tests deleteMany
   */
  export type lab_testsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lab_tests to delete
     */
    where?: lab_testsWhereInput
    /**
     * Limit how many lab_tests to delete.
     */
    limit?: number
  }

  /**
   * lab_tests without action
   */
  export type lab_testsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab_tests
     */
    select?: lab_testsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab_tests
     */
    omit?: lab_testsOmit<ExtArgs> | null
  }


  /**
   * Model announcements
   */

  export type AggregateAnnouncements = {
    _count: AnnouncementsCountAggregateOutputType | null
    _min: AnnouncementsMinAggregateOutputType | null
    _max: AnnouncementsMaxAggregateOutputType | null
  }

  export type AnnouncementsMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    type: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type AnnouncementsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    type: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type AnnouncementsCountAggregateOutputType = {
    id: number
    title: number
    content: number
    type: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type AnnouncementsMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    createdBy?: true
    createdAt?: true
  }

  export type AnnouncementsMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    createdBy?: true
    createdAt?: true
  }

  export type AnnouncementsCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type AnnouncementsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which announcements to aggregate.
     */
    where?: announcementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of announcements to fetch.
     */
    orderBy?: announcementsOrderByWithRelationInput | announcementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: announcementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned announcements
    **/
    _count?: true | AnnouncementsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementsMaxAggregateInputType
  }

  export type GetAnnouncementsAggregateType<T extends AnnouncementsAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncements]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncements[P]>
      : GetScalarType<T[P], AggregateAnnouncements[P]>
  }




  export type announcementsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: announcementsWhereInput
    orderBy?: announcementsOrderByWithAggregationInput | announcementsOrderByWithAggregationInput[]
    by: AnnouncementsScalarFieldEnum[] | AnnouncementsScalarFieldEnum
    having?: announcementsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementsCountAggregateInputType | true
    _min?: AnnouncementsMinAggregateInputType
    _max?: AnnouncementsMaxAggregateInputType
  }

  export type AnnouncementsGroupByOutputType = {
    id: string
    title: string
    content: string | null
    type: string
    createdBy: string | null
    createdAt: Date
    _count: AnnouncementsCountAggregateOutputType | null
    _min: AnnouncementsMinAggregateOutputType | null
    _max: AnnouncementsMaxAggregateOutputType | null
  }

  type GetAnnouncementsGroupByPayload<T extends announcementsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementsGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementsGroupByOutputType[P]>
        }
      >
    >


  export type announcementsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["announcements"]>

  export type announcementsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["announcements"]>

  export type announcementsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["announcements"]>

  export type announcementsSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type announcementsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "type" | "createdBy" | "createdAt", ExtArgs["result"]["announcements"]>

  export type $announcementsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "announcements"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string | null
      type: string
      createdBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["announcements"]>
    composites: {}
  }

  type announcementsGetPayload<S extends boolean | null | undefined | announcementsDefaultArgs> = $Result.GetResult<Prisma.$announcementsPayload, S>

  type announcementsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<announcementsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnouncementsCountAggregateInputType | true
    }

  export interface announcementsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['announcements'], meta: { name: 'announcements' } }
    /**
     * Find zero or one Announcements that matches the filter.
     * @param {announcementsFindUniqueArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends announcementsFindUniqueArgs>(args: SelectSubset<T, announcementsFindUniqueArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Announcements that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {announcementsFindUniqueOrThrowArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends announcementsFindUniqueOrThrowArgs>(args: SelectSubset<T, announcementsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsFindFirstArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends announcementsFindFirstArgs>(args?: SelectSubset<T, announcementsFindFirstArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcements that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsFindFirstOrThrowArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends announcementsFindFirstOrThrowArgs>(args?: SelectSubset<T, announcementsFindFirstOrThrowArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcements.findMany()
     * 
     * // Get first 10 Announcements
     * const announcements = await prisma.announcements.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const announcementsWithIdOnly = await prisma.announcements.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends announcementsFindManyArgs>(args?: SelectSubset<T, announcementsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Announcements.
     * @param {announcementsCreateArgs} args - Arguments to create a Announcements.
     * @example
     * // Create one Announcements
     * const Announcements = await prisma.announcements.create({
     *   data: {
     *     // ... data to create a Announcements
     *   }
     * })
     * 
     */
    create<T extends announcementsCreateArgs>(args: SelectSubset<T, announcementsCreateArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Announcements.
     * @param {announcementsCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcements = await prisma.announcements.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends announcementsCreateManyArgs>(args?: SelectSubset<T, announcementsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Announcements and returns the data saved in the database.
     * @param {announcementsCreateManyAndReturnArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcements = await prisma.announcements.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Announcements and only return the `id`
     * const announcementsWithIdOnly = await prisma.announcements.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends announcementsCreateManyAndReturnArgs>(args?: SelectSubset<T, announcementsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Announcements.
     * @param {announcementsDeleteArgs} args - Arguments to delete one Announcements.
     * @example
     * // Delete one Announcements
     * const Announcements = await prisma.announcements.delete({
     *   where: {
     *     // ... filter to delete one Announcements
     *   }
     * })
     * 
     */
    delete<T extends announcementsDeleteArgs>(args: SelectSubset<T, announcementsDeleteArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Announcements.
     * @param {announcementsUpdateArgs} args - Arguments to update one Announcements.
     * @example
     * // Update one Announcements
     * const announcements = await prisma.announcements.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends announcementsUpdateArgs>(args: SelectSubset<T, announcementsUpdateArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Announcements.
     * @param {announcementsDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcements.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends announcementsDeleteManyArgs>(args?: SelectSubset<T, announcementsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcements = await prisma.announcements.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends announcementsUpdateManyArgs>(args: SelectSubset<T, announcementsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements and returns the data updated in the database.
     * @param {announcementsUpdateManyAndReturnArgs} args - Arguments to update many Announcements.
     * @example
     * // Update many Announcements
     * const announcements = await prisma.announcements.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Announcements and only return the `id`
     * const announcementsWithIdOnly = await prisma.announcements.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends announcementsUpdateManyAndReturnArgs>(args: SelectSubset<T, announcementsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Announcements.
     * @param {announcementsUpsertArgs} args - Arguments to update or create a Announcements.
     * @example
     * // Update or create a Announcements
     * const announcements = await prisma.announcements.upsert({
     *   create: {
     *     // ... data to create a Announcements
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcements we want to update
     *   }
     * })
     */
    upsert<T extends announcementsUpsertArgs>(args: SelectSubset<T, announcementsUpsertArgs<ExtArgs>>): Prisma__announcementsClient<$Result.GetResult<Prisma.$announcementsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcements.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
    **/
    count<T extends announcementsCountArgs>(
      args?: Subset<T, announcementsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementsAggregateArgs>(args: Subset<T, AnnouncementsAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementsAggregateType<T>>

    /**
     * Group by Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {announcementsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends announcementsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: announcementsGroupByArgs['orderBy'] }
        : { orderBy?: announcementsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, announcementsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the announcements model
   */
  readonly fields: announcementsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for announcements.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__announcementsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the announcements model
   */
  interface announcementsFieldRefs {
    readonly id: FieldRef<"announcements", 'String'>
    readonly title: FieldRef<"announcements", 'String'>
    readonly content: FieldRef<"announcements", 'String'>
    readonly type: FieldRef<"announcements", 'String'>
    readonly createdBy: FieldRef<"announcements", 'String'>
    readonly createdAt: FieldRef<"announcements", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * announcements findUnique
   */
  export type announcementsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Filter, which announcements to fetch.
     */
    where: announcementsWhereUniqueInput
  }

  /**
   * announcements findUniqueOrThrow
   */
  export type announcementsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Filter, which announcements to fetch.
     */
    where: announcementsWhereUniqueInput
  }

  /**
   * announcements findFirst
   */
  export type announcementsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Filter, which announcements to fetch.
     */
    where?: announcementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of announcements to fetch.
     */
    orderBy?: announcementsOrderByWithRelationInput | announcementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for announcements.
     */
    cursor?: announcementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of announcements.
     */
    distinct?: AnnouncementsScalarFieldEnum | AnnouncementsScalarFieldEnum[]
  }

  /**
   * announcements findFirstOrThrow
   */
  export type announcementsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Filter, which announcements to fetch.
     */
    where?: announcementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of announcements to fetch.
     */
    orderBy?: announcementsOrderByWithRelationInput | announcementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for announcements.
     */
    cursor?: announcementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of announcements.
     */
    distinct?: AnnouncementsScalarFieldEnum | AnnouncementsScalarFieldEnum[]
  }

  /**
   * announcements findMany
   */
  export type announcementsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Filter, which announcements to fetch.
     */
    where?: announcementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of announcements to fetch.
     */
    orderBy?: announcementsOrderByWithRelationInput | announcementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing announcements.
     */
    cursor?: announcementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` announcements.
     */
    skip?: number
    distinct?: AnnouncementsScalarFieldEnum | AnnouncementsScalarFieldEnum[]
  }

  /**
   * announcements create
   */
  export type announcementsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * The data needed to create a announcements.
     */
    data: XOR<announcementsCreateInput, announcementsUncheckedCreateInput>
  }

  /**
   * announcements createMany
   */
  export type announcementsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many announcements.
     */
    data: announcementsCreateManyInput | announcementsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * announcements createManyAndReturn
   */
  export type announcementsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * The data used to create many announcements.
     */
    data: announcementsCreateManyInput | announcementsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * announcements update
   */
  export type announcementsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * The data needed to update a announcements.
     */
    data: XOR<announcementsUpdateInput, announcementsUncheckedUpdateInput>
    /**
     * Choose, which announcements to update.
     */
    where: announcementsWhereUniqueInput
  }

  /**
   * announcements updateMany
   */
  export type announcementsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update announcements.
     */
    data: XOR<announcementsUpdateManyMutationInput, announcementsUncheckedUpdateManyInput>
    /**
     * Filter which announcements to update
     */
    where?: announcementsWhereInput
    /**
     * Limit how many announcements to update.
     */
    limit?: number
  }

  /**
   * announcements updateManyAndReturn
   */
  export type announcementsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * The data used to update announcements.
     */
    data: XOR<announcementsUpdateManyMutationInput, announcementsUncheckedUpdateManyInput>
    /**
     * Filter which announcements to update
     */
    where?: announcementsWhereInput
    /**
     * Limit how many announcements to update.
     */
    limit?: number
  }

  /**
   * announcements upsert
   */
  export type announcementsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * The filter to search for the announcements to update in case it exists.
     */
    where: announcementsWhereUniqueInput
    /**
     * In case the announcements found by the `where` argument doesn't exist, create a new announcements with this data.
     */
    create: XOR<announcementsCreateInput, announcementsUncheckedCreateInput>
    /**
     * In case the announcements was found with the provided `where` argument, update it with this data.
     */
    update: XOR<announcementsUpdateInput, announcementsUncheckedUpdateInput>
  }

  /**
   * announcements delete
   */
  export type announcementsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
    /**
     * Filter which announcements to delete.
     */
    where: announcementsWhereUniqueInput
  }

  /**
   * announcements deleteMany
   */
  export type announcementsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which announcements to delete
     */
    where?: announcementsWhereInput
    /**
     * Limit how many announcements to delete.
     */
    limit?: number
  }

  /**
   * announcements without action
   */
  export type announcementsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the announcements
     */
    select?: announcementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the announcements
     */
    omit?: announcementsOmit<ExtArgs> | null
  }


  /**
   * Model voice_notes
   */

  export type AggregateVoice_notes = {
    _count: Voice_notesCountAggregateOutputType | null
    _min: Voice_notesMinAggregateOutputType | null
    _max: Voice_notesMaxAggregateOutputType | null
  }

  export type Voice_notesMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    recipientRole: string | null
    transcription: string | null
    audioUrl: string | null
    initials: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type Voice_notesMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    recipientRole: string | null
    transcription: string | null
    audioUrl: string | null
    initials: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type Voice_notesCountAggregateOutputType = {
    id: number
    patientId: number
    patient: number
    recipientRole: number
    transcription: number
    audioUrl: number
    initials: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type Voice_notesMinAggregateInputType = {
    id?: true
    patientId?: true
    recipientRole?: true
    transcription?: true
    audioUrl?: true
    initials?: true
    createdBy?: true
    createdAt?: true
  }

  export type Voice_notesMaxAggregateInputType = {
    id?: true
    patientId?: true
    recipientRole?: true
    transcription?: true
    audioUrl?: true
    initials?: true
    createdBy?: true
    createdAt?: true
  }

  export type Voice_notesCountAggregateInputType = {
    id?: true
    patientId?: true
    patient?: true
    recipientRole?: true
    transcription?: true
    audioUrl?: true
    initials?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type Voice_notesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which voice_notes to aggregate.
     */
    where?: voice_notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of voice_notes to fetch.
     */
    orderBy?: voice_notesOrderByWithRelationInput | voice_notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: voice_notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` voice_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` voice_notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned voice_notes
    **/
    _count?: true | Voice_notesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Voice_notesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Voice_notesMaxAggregateInputType
  }

  export type GetVoice_notesAggregateType<T extends Voice_notesAggregateArgs> = {
        [P in keyof T & keyof AggregateVoice_notes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoice_notes[P]>
      : GetScalarType<T[P], AggregateVoice_notes[P]>
  }




  export type voice_notesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: voice_notesWhereInput
    orderBy?: voice_notesOrderByWithAggregationInput | voice_notesOrderByWithAggregationInput[]
    by: Voice_notesScalarFieldEnum[] | Voice_notesScalarFieldEnum
    having?: voice_notesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Voice_notesCountAggregateInputType | true
    _min?: Voice_notesMinAggregateInputType
    _max?: Voice_notesMaxAggregateInputType
  }

  export type Voice_notesGroupByOutputType = {
    id: string
    patientId: string | null
    patient: JsonValue | null
    recipientRole: string | null
    transcription: string | null
    audioUrl: string | null
    initials: string | null
    createdBy: string | null
    createdAt: Date
    _count: Voice_notesCountAggregateOutputType | null
    _min: Voice_notesMinAggregateOutputType | null
    _max: Voice_notesMaxAggregateOutputType | null
  }

  type GetVoice_notesGroupByPayload<T extends voice_notesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Voice_notesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Voice_notesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Voice_notesGroupByOutputType[P]>
            : GetScalarType<T[P], Voice_notesGroupByOutputType[P]>
        }
      >
    >


  export type voice_notesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    recipientRole?: boolean
    transcription?: boolean
    audioUrl?: boolean
    initials?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["voice_notes"]>

  export type voice_notesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    recipientRole?: boolean
    transcription?: boolean
    audioUrl?: boolean
    initials?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["voice_notes"]>

  export type voice_notesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    recipientRole?: boolean
    transcription?: boolean
    audioUrl?: boolean
    initials?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["voice_notes"]>

  export type voice_notesSelectScalar = {
    id?: boolean
    patientId?: boolean
    patient?: boolean
    recipientRole?: boolean
    transcription?: boolean
    audioUrl?: boolean
    initials?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type voice_notesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "patient" | "recipientRole" | "transcription" | "audioUrl" | "initials" | "createdBy" | "createdAt", ExtArgs["result"]["voice_notes"]>

  export type $voice_notesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "voice_notes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string | null
      patient: Prisma.JsonValue | null
      recipientRole: string | null
      transcription: string | null
      audioUrl: string | null
      initials: string | null
      createdBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["voice_notes"]>
    composites: {}
  }

  type voice_notesGetPayload<S extends boolean | null | undefined | voice_notesDefaultArgs> = $Result.GetResult<Prisma.$voice_notesPayload, S>

  type voice_notesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<voice_notesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Voice_notesCountAggregateInputType | true
    }

  export interface voice_notesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['voice_notes'], meta: { name: 'voice_notes' } }
    /**
     * Find zero or one Voice_notes that matches the filter.
     * @param {voice_notesFindUniqueArgs} args - Arguments to find a Voice_notes
     * @example
     * // Get one Voice_notes
     * const voice_notes = await prisma.voice_notes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends voice_notesFindUniqueArgs>(args: SelectSubset<T, voice_notesFindUniqueArgs<ExtArgs>>): Prisma__voice_notesClient<$Result.GetResult<Prisma.$voice_notesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Voice_notes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {voice_notesFindUniqueOrThrowArgs} args - Arguments to find a Voice_notes
     * @example
     * // Get one Voice_notes
     * const voice_notes = await prisma.voice_notes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends voice_notesFindUniqueOrThrowArgs>(args: SelectSubset<T, voice_notesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__voice_notesClient<$Result.GetResult<Prisma.$voice_notesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Voice_notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {voice_notesFindFirstArgs} args - Arguments to find a Voice_notes
     * @example
     * // Get one Voice_notes
     * const voice_notes = await prisma.voice_notes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends voice_notesFindFirstArgs>(args?: SelectSubset<T, voice_notesFindFirstArgs<ExtArgs>>): Prisma__voice_notesClient<$Result.GetResult<Prisma.$voice_notesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Voice_notes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {voice_notesFindFirstOrThrowArgs} args - Arguments to find a Voice_notes
     * @example
     * // Get one Voice_notes
     * const voice_notes = await prisma.voice_notes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends voice_notesFindFirstOrThrowArgs>(args?: SelectSubset<T, voice_notesFindFirstOrThrowArgs<ExtArgs>>): Prisma__voice_notesClient<$Result.GetResult<Prisma.$voice_notesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Voice_notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {voice_notesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Voice_notes
     * const voice_notes = await prisma.voice_notes.findMany()
     * 
     * // Get first 10 Voice_notes
     * const voice_notes = await prisma.voice_notes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voice_notesWithIdOnly = await prisma.voice_notes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends voice_notesFindManyArgs>(args?: SelectSubset<T, voice_notesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$voice_notesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Voice_notes.
     * @param {voice_notesCreateArgs} args - Arguments to create a Voice_notes.
     * @example
     * // Create one Voice_notes
     * const Voice_notes = await prisma.voice_notes.create({
     *   data: {
     *     // ... data to create a Voice_notes
     *   }
     * })
     * 
     */
    create<T extends voice_notesCreateArgs>(args: SelectSubset<T, voice_notesCreateArgs<ExtArgs>>): Prisma__voice_notesClient<$Result.GetResult<Prisma.$voice_notesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Voice_notes.
     * @param {voice_notesCreateManyArgs} args - Arguments to create many Voice_notes.
     * @example
     * // Create many Voice_notes
     * const voice_notes = await prisma.voice_notes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends voice_notesCreateManyArgs>(args?: SelectSubset<T, voice_notesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Voice_notes and returns the data saved in the database.
     * @param {voice_notesCreateManyAndReturnArgs} args - Arguments to create many Voice_notes.
     * @example
     * // Create many Voice_notes
     * const voice_notes = await prisma.voice_notes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Voice_notes and only return the `id`
     * const voice_notesWithIdOnly = await prisma.voice_notes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends voice_notesCreateManyAndReturnArgs>(args?: SelectSubset<T, voice_notesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$voice_notesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Voice_notes.
     * @param {voice_notesDeleteArgs} args - Arguments to delete one Voice_notes.
     * @example
     * // Delete one Voice_notes
     * const Voice_notes = await prisma.voice_notes.delete({
     *   where: {
     *     // ... filter to delete one Voice_notes
     *   }
     * })
     * 
     */
    delete<T extends voice_notesDeleteArgs>(args: SelectSubset<T, voice_notesDeleteArgs<ExtArgs>>): Prisma__voice_notesClient<$Result.GetResult<Prisma.$voice_notesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Voice_notes.
     * @param {voice_notesUpdateArgs} args - Arguments to update one Voice_notes.
     * @example
     * // Update one Voice_notes
     * const voice_notes = await prisma.voice_notes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends voice_notesUpdateArgs>(args: SelectSubset<T, voice_notesUpdateArgs<ExtArgs>>): Prisma__voice_notesClient<$Result.GetResult<Prisma.$voice_notesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Voice_notes.
     * @param {voice_notesDeleteManyArgs} args - Arguments to filter Voice_notes to delete.
     * @example
     * // Delete a few Voice_notes
     * const { count } = await prisma.voice_notes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends voice_notesDeleteManyArgs>(args?: SelectSubset<T, voice_notesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Voice_notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {voice_notesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Voice_notes
     * const voice_notes = await prisma.voice_notes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends voice_notesUpdateManyArgs>(args: SelectSubset<T, voice_notesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Voice_notes and returns the data updated in the database.
     * @param {voice_notesUpdateManyAndReturnArgs} args - Arguments to update many Voice_notes.
     * @example
     * // Update many Voice_notes
     * const voice_notes = await prisma.voice_notes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Voice_notes and only return the `id`
     * const voice_notesWithIdOnly = await prisma.voice_notes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends voice_notesUpdateManyAndReturnArgs>(args: SelectSubset<T, voice_notesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$voice_notesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Voice_notes.
     * @param {voice_notesUpsertArgs} args - Arguments to update or create a Voice_notes.
     * @example
     * // Update or create a Voice_notes
     * const voice_notes = await prisma.voice_notes.upsert({
     *   create: {
     *     // ... data to create a Voice_notes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Voice_notes we want to update
     *   }
     * })
     */
    upsert<T extends voice_notesUpsertArgs>(args: SelectSubset<T, voice_notesUpsertArgs<ExtArgs>>): Prisma__voice_notesClient<$Result.GetResult<Prisma.$voice_notesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Voice_notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {voice_notesCountArgs} args - Arguments to filter Voice_notes to count.
     * @example
     * // Count the number of Voice_notes
     * const count = await prisma.voice_notes.count({
     *   where: {
     *     // ... the filter for the Voice_notes we want to count
     *   }
     * })
    **/
    count<T extends voice_notesCountArgs>(
      args?: Subset<T, voice_notesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Voice_notesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Voice_notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Voice_notesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Voice_notesAggregateArgs>(args: Subset<T, Voice_notesAggregateArgs>): Prisma.PrismaPromise<GetVoice_notesAggregateType<T>>

    /**
     * Group by Voice_notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {voice_notesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends voice_notesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: voice_notesGroupByArgs['orderBy'] }
        : { orderBy?: voice_notesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, voice_notesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoice_notesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the voice_notes model
   */
  readonly fields: voice_notesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for voice_notes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__voice_notesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the voice_notes model
   */
  interface voice_notesFieldRefs {
    readonly id: FieldRef<"voice_notes", 'String'>
    readonly patientId: FieldRef<"voice_notes", 'String'>
    readonly patient: FieldRef<"voice_notes", 'Json'>
    readonly recipientRole: FieldRef<"voice_notes", 'String'>
    readonly transcription: FieldRef<"voice_notes", 'String'>
    readonly audioUrl: FieldRef<"voice_notes", 'String'>
    readonly initials: FieldRef<"voice_notes", 'String'>
    readonly createdBy: FieldRef<"voice_notes", 'String'>
    readonly createdAt: FieldRef<"voice_notes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * voice_notes findUnique
   */
  export type voice_notesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voice_notes
     */
    select?: voice_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voice_notes
     */
    omit?: voice_notesOmit<ExtArgs> | null
    /**
     * Filter, which voice_notes to fetch.
     */
    where: voice_notesWhereUniqueInput
  }

  /**
   * voice_notes findUniqueOrThrow
   */
  export type voice_notesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voice_notes
     */
    select?: voice_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voice_notes
     */
    omit?: voice_notesOmit<ExtArgs> | null
    /**
     * Filter, which voice_notes to fetch.
     */
    where: voice_notesWhereUniqueInput
  }

  /**
   * voice_notes findFirst
   */
  export type voice_notesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voice_notes
     */
    select?: voice_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voice_notes
     */
    omit?: voice_notesOmit<ExtArgs> | null
    /**
     * Filter, which voice_notes to fetch.
     */
    where?: voice_notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of voice_notes to fetch.
     */
    orderBy?: voice_notesOrderByWithRelationInput | voice_notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for voice_notes.
     */
    cursor?: voice_notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` voice_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` voice_notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of voice_notes.
     */
    distinct?: Voice_notesScalarFieldEnum | Voice_notesScalarFieldEnum[]
  }

  /**
   * voice_notes findFirstOrThrow
   */
  export type voice_notesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voice_notes
     */
    select?: voice_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voice_notes
     */
    omit?: voice_notesOmit<ExtArgs> | null
    /**
     * Filter, which voice_notes to fetch.
     */
    where?: voice_notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of voice_notes to fetch.
     */
    orderBy?: voice_notesOrderByWithRelationInput | voice_notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for voice_notes.
     */
    cursor?: voice_notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` voice_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` voice_notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of voice_notes.
     */
    distinct?: Voice_notesScalarFieldEnum | Voice_notesScalarFieldEnum[]
  }

  /**
   * voice_notes findMany
   */
  export type voice_notesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voice_notes
     */
    select?: voice_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voice_notes
     */
    omit?: voice_notesOmit<ExtArgs> | null
    /**
     * Filter, which voice_notes to fetch.
     */
    where?: voice_notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of voice_notes to fetch.
     */
    orderBy?: voice_notesOrderByWithRelationInput | voice_notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing voice_notes.
     */
    cursor?: voice_notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` voice_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` voice_notes.
     */
    skip?: number
    distinct?: Voice_notesScalarFieldEnum | Voice_notesScalarFieldEnum[]
  }

  /**
   * voice_notes create
   */
  export type voice_notesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voice_notes
     */
    select?: voice_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voice_notes
     */
    omit?: voice_notesOmit<ExtArgs> | null
    /**
     * The data needed to create a voice_notes.
     */
    data: XOR<voice_notesCreateInput, voice_notesUncheckedCreateInput>
  }

  /**
   * voice_notes createMany
   */
  export type voice_notesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many voice_notes.
     */
    data: voice_notesCreateManyInput | voice_notesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * voice_notes createManyAndReturn
   */
  export type voice_notesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voice_notes
     */
    select?: voice_notesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the voice_notes
     */
    omit?: voice_notesOmit<ExtArgs> | null
    /**
     * The data used to create many voice_notes.
     */
    data: voice_notesCreateManyInput | voice_notesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * voice_notes update
   */
  export type voice_notesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voice_notes
     */
    select?: voice_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voice_notes
     */
    omit?: voice_notesOmit<ExtArgs> | null
    /**
     * The data needed to update a voice_notes.
     */
    data: XOR<voice_notesUpdateInput, voice_notesUncheckedUpdateInput>
    /**
     * Choose, which voice_notes to update.
     */
    where: voice_notesWhereUniqueInput
  }

  /**
   * voice_notes updateMany
   */
  export type voice_notesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update voice_notes.
     */
    data: XOR<voice_notesUpdateManyMutationInput, voice_notesUncheckedUpdateManyInput>
    /**
     * Filter which voice_notes to update
     */
    where?: voice_notesWhereInput
    /**
     * Limit how many voice_notes to update.
     */
    limit?: number
  }

  /**
   * voice_notes updateManyAndReturn
   */
  export type voice_notesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voice_notes
     */
    select?: voice_notesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the voice_notes
     */
    omit?: voice_notesOmit<ExtArgs> | null
    /**
     * The data used to update voice_notes.
     */
    data: XOR<voice_notesUpdateManyMutationInput, voice_notesUncheckedUpdateManyInput>
    /**
     * Filter which voice_notes to update
     */
    where?: voice_notesWhereInput
    /**
     * Limit how many voice_notes to update.
     */
    limit?: number
  }

  /**
   * voice_notes upsert
   */
  export type voice_notesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voice_notes
     */
    select?: voice_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voice_notes
     */
    omit?: voice_notesOmit<ExtArgs> | null
    /**
     * The filter to search for the voice_notes to update in case it exists.
     */
    where: voice_notesWhereUniqueInput
    /**
     * In case the voice_notes found by the `where` argument doesn't exist, create a new voice_notes with this data.
     */
    create: XOR<voice_notesCreateInput, voice_notesUncheckedCreateInput>
    /**
     * In case the voice_notes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<voice_notesUpdateInput, voice_notesUncheckedUpdateInput>
  }

  /**
   * voice_notes delete
   */
  export type voice_notesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voice_notes
     */
    select?: voice_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voice_notes
     */
    omit?: voice_notesOmit<ExtArgs> | null
    /**
     * Filter which voice_notes to delete.
     */
    where: voice_notesWhereUniqueInput
  }

  /**
   * voice_notes deleteMany
   */
  export type voice_notesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which voice_notes to delete
     */
    where?: voice_notesWhereInput
    /**
     * Limit how many voice_notes to delete.
     */
    limit?: number
  }

  /**
   * voice_notes without action
   */
  export type voice_notesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voice_notes
     */
    select?: voice_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voice_notes
     */
    omit?: voice_notesOmit<ExtArgs> | null
  }


  /**
   * Model medical_certificates
   */

  export type AggregateMedical_certificates = {
    _count: Medical_certificatesCountAggregateOutputType | null
    _avg: Medical_certificatesAvgAggregateOutputType | null
    _sum: Medical_certificatesSumAggregateOutputType | null
    _min: Medical_certificatesMinAggregateOutputType | null
    _max: Medical_certificatesMaxAggregateOutputType | null
  }

  export type Medical_certificatesAvgAggregateOutputType = {
    daysOff: number | null
  }

  export type Medical_certificatesSumAggregateOutputType = {
    daysOff: number | null
  }

  export type Medical_certificatesMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    type: string | null
    diagnosis: string | null
    daysOff: number | null
    startDate: string | null
    endDate: string | null
    notes: string | null
    issuedBy: string | null
    createdAt: Date | null
  }

  export type Medical_certificatesMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    type: string | null
    diagnosis: string | null
    daysOff: number | null
    startDate: string | null
    endDate: string | null
    notes: string | null
    issuedBy: string | null
    createdAt: Date | null
  }

  export type Medical_certificatesCountAggregateOutputType = {
    id: number
    patientId: number
    patient: number
    type: number
    diagnosis: number
    daysOff: number
    startDate: number
    endDate: number
    notes: number
    issuedBy: number
    createdAt: number
    _all: number
  }


  export type Medical_certificatesAvgAggregateInputType = {
    daysOff?: true
  }

  export type Medical_certificatesSumAggregateInputType = {
    daysOff?: true
  }

  export type Medical_certificatesMinAggregateInputType = {
    id?: true
    patientId?: true
    type?: true
    diagnosis?: true
    daysOff?: true
    startDate?: true
    endDate?: true
    notes?: true
    issuedBy?: true
    createdAt?: true
  }

  export type Medical_certificatesMaxAggregateInputType = {
    id?: true
    patientId?: true
    type?: true
    diagnosis?: true
    daysOff?: true
    startDate?: true
    endDate?: true
    notes?: true
    issuedBy?: true
    createdAt?: true
  }

  export type Medical_certificatesCountAggregateInputType = {
    id?: true
    patientId?: true
    patient?: true
    type?: true
    diagnosis?: true
    daysOff?: true
    startDate?: true
    endDate?: true
    notes?: true
    issuedBy?: true
    createdAt?: true
    _all?: true
  }

  export type Medical_certificatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medical_certificates to aggregate.
     */
    where?: medical_certificatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medical_certificates to fetch.
     */
    orderBy?: medical_certificatesOrderByWithRelationInput | medical_certificatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: medical_certificatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medical_certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medical_certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned medical_certificates
    **/
    _count?: true | Medical_certificatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Medical_certificatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Medical_certificatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Medical_certificatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Medical_certificatesMaxAggregateInputType
  }

  export type GetMedical_certificatesAggregateType<T extends Medical_certificatesAggregateArgs> = {
        [P in keyof T & keyof AggregateMedical_certificates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedical_certificates[P]>
      : GetScalarType<T[P], AggregateMedical_certificates[P]>
  }




  export type medical_certificatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medical_certificatesWhereInput
    orderBy?: medical_certificatesOrderByWithAggregationInput | medical_certificatesOrderByWithAggregationInput[]
    by: Medical_certificatesScalarFieldEnum[] | Medical_certificatesScalarFieldEnum
    having?: medical_certificatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Medical_certificatesCountAggregateInputType | true
    _avg?: Medical_certificatesAvgAggregateInputType
    _sum?: Medical_certificatesSumAggregateInputType
    _min?: Medical_certificatesMinAggregateInputType
    _max?: Medical_certificatesMaxAggregateInputType
  }

  export type Medical_certificatesGroupByOutputType = {
    id: string
    patientId: string | null
    patient: JsonValue | null
    type: string | null
    diagnosis: string | null
    daysOff: number | null
    startDate: string | null
    endDate: string | null
    notes: string | null
    issuedBy: string | null
    createdAt: Date
    _count: Medical_certificatesCountAggregateOutputType | null
    _avg: Medical_certificatesAvgAggregateOutputType | null
    _sum: Medical_certificatesSumAggregateOutputType | null
    _min: Medical_certificatesMinAggregateOutputType | null
    _max: Medical_certificatesMaxAggregateOutputType | null
  }

  type GetMedical_certificatesGroupByPayload<T extends medical_certificatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Medical_certificatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Medical_certificatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Medical_certificatesGroupByOutputType[P]>
            : GetScalarType<T[P], Medical_certificatesGroupByOutputType[P]>
        }
      >
    >


  export type medical_certificatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    type?: boolean
    diagnosis?: boolean
    daysOff?: boolean
    startDate?: boolean
    endDate?: boolean
    notes?: boolean
    issuedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["medical_certificates"]>

  export type medical_certificatesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    type?: boolean
    diagnosis?: boolean
    daysOff?: boolean
    startDate?: boolean
    endDate?: boolean
    notes?: boolean
    issuedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["medical_certificates"]>

  export type medical_certificatesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    type?: boolean
    diagnosis?: boolean
    daysOff?: boolean
    startDate?: boolean
    endDate?: boolean
    notes?: boolean
    issuedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["medical_certificates"]>

  export type medical_certificatesSelectScalar = {
    id?: boolean
    patientId?: boolean
    patient?: boolean
    type?: boolean
    diagnosis?: boolean
    daysOff?: boolean
    startDate?: boolean
    endDate?: boolean
    notes?: boolean
    issuedBy?: boolean
    createdAt?: boolean
  }

  export type medical_certificatesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "patient" | "type" | "diagnosis" | "daysOff" | "startDate" | "endDate" | "notes" | "issuedBy" | "createdAt", ExtArgs["result"]["medical_certificates"]>

  export type $medical_certificatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "medical_certificates"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string | null
      patient: Prisma.JsonValue | null
      type: string | null
      diagnosis: string | null
      daysOff: number | null
      startDate: string | null
      endDate: string | null
      notes: string | null
      issuedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["medical_certificates"]>
    composites: {}
  }

  type medical_certificatesGetPayload<S extends boolean | null | undefined | medical_certificatesDefaultArgs> = $Result.GetResult<Prisma.$medical_certificatesPayload, S>

  type medical_certificatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<medical_certificatesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Medical_certificatesCountAggregateInputType | true
    }

  export interface medical_certificatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['medical_certificates'], meta: { name: 'medical_certificates' } }
    /**
     * Find zero or one Medical_certificates that matches the filter.
     * @param {medical_certificatesFindUniqueArgs} args - Arguments to find a Medical_certificates
     * @example
     * // Get one Medical_certificates
     * const medical_certificates = await prisma.medical_certificates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends medical_certificatesFindUniqueArgs>(args: SelectSubset<T, medical_certificatesFindUniqueArgs<ExtArgs>>): Prisma__medical_certificatesClient<$Result.GetResult<Prisma.$medical_certificatesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Medical_certificates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {medical_certificatesFindUniqueOrThrowArgs} args - Arguments to find a Medical_certificates
     * @example
     * // Get one Medical_certificates
     * const medical_certificates = await prisma.medical_certificates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends medical_certificatesFindUniqueOrThrowArgs>(args: SelectSubset<T, medical_certificatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__medical_certificatesClient<$Result.GetResult<Prisma.$medical_certificatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medical_certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_certificatesFindFirstArgs} args - Arguments to find a Medical_certificates
     * @example
     * // Get one Medical_certificates
     * const medical_certificates = await prisma.medical_certificates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends medical_certificatesFindFirstArgs>(args?: SelectSubset<T, medical_certificatesFindFirstArgs<ExtArgs>>): Prisma__medical_certificatesClient<$Result.GetResult<Prisma.$medical_certificatesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medical_certificates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_certificatesFindFirstOrThrowArgs} args - Arguments to find a Medical_certificates
     * @example
     * // Get one Medical_certificates
     * const medical_certificates = await prisma.medical_certificates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends medical_certificatesFindFirstOrThrowArgs>(args?: SelectSubset<T, medical_certificatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__medical_certificatesClient<$Result.GetResult<Prisma.$medical_certificatesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Medical_certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_certificatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medical_certificates
     * const medical_certificates = await prisma.medical_certificates.findMany()
     * 
     * // Get first 10 Medical_certificates
     * const medical_certificates = await prisma.medical_certificates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medical_certificatesWithIdOnly = await prisma.medical_certificates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends medical_certificatesFindManyArgs>(args?: SelectSubset<T, medical_certificatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medical_certificatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Medical_certificates.
     * @param {medical_certificatesCreateArgs} args - Arguments to create a Medical_certificates.
     * @example
     * // Create one Medical_certificates
     * const Medical_certificates = await prisma.medical_certificates.create({
     *   data: {
     *     // ... data to create a Medical_certificates
     *   }
     * })
     * 
     */
    create<T extends medical_certificatesCreateArgs>(args: SelectSubset<T, medical_certificatesCreateArgs<ExtArgs>>): Prisma__medical_certificatesClient<$Result.GetResult<Prisma.$medical_certificatesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Medical_certificates.
     * @param {medical_certificatesCreateManyArgs} args - Arguments to create many Medical_certificates.
     * @example
     * // Create many Medical_certificates
     * const medical_certificates = await prisma.medical_certificates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends medical_certificatesCreateManyArgs>(args?: SelectSubset<T, medical_certificatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Medical_certificates and returns the data saved in the database.
     * @param {medical_certificatesCreateManyAndReturnArgs} args - Arguments to create many Medical_certificates.
     * @example
     * // Create many Medical_certificates
     * const medical_certificates = await prisma.medical_certificates.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Medical_certificates and only return the `id`
     * const medical_certificatesWithIdOnly = await prisma.medical_certificates.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends medical_certificatesCreateManyAndReturnArgs>(args?: SelectSubset<T, medical_certificatesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medical_certificatesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Medical_certificates.
     * @param {medical_certificatesDeleteArgs} args - Arguments to delete one Medical_certificates.
     * @example
     * // Delete one Medical_certificates
     * const Medical_certificates = await prisma.medical_certificates.delete({
     *   where: {
     *     // ... filter to delete one Medical_certificates
     *   }
     * })
     * 
     */
    delete<T extends medical_certificatesDeleteArgs>(args: SelectSubset<T, medical_certificatesDeleteArgs<ExtArgs>>): Prisma__medical_certificatesClient<$Result.GetResult<Prisma.$medical_certificatesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Medical_certificates.
     * @param {medical_certificatesUpdateArgs} args - Arguments to update one Medical_certificates.
     * @example
     * // Update one Medical_certificates
     * const medical_certificates = await prisma.medical_certificates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends medical_certificatesUpdateArgs>(args: SelectSubset<T, medical_certificatesUpdateArgs<ExtArgs>>): Prisma__medical_certificatesClient<$Result.GetResult<Prisma.$medical_certificatesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Medical_certificates.
     * @param {medical_certificatesDeleteManyArgs} args - Arguments to filter Medical_certificates to delete.
     * @example
     * // Delete a few Medical_certificates
     * const { count } = await prisma.medical_certificates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends medical_certificatesDeleteManyArgs>(args?: SelectSubset<T, medical_certificatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medical_certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_certificatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medical_certificates
     * const medical_certificates = await prisma.medical_certificates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends medical_certificatesUpdateManyArgs>(args: SelectSubset<T, medical_certificatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medical_certificates and returns the data updated in the database.
     * @param {medical_certificatesUpdateManyAndReturnArgs} args - Arguments to update many Medical_certificates.
     * @example
     * // Update many Medical_certificates
     * const medical_certificates = await prisma.medical_certificates.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Medical_certificates and only return the `id`
     * const medical_certificatesWithIdOnly = await prisma.medical_certificates.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends medical_certificatesUpdateManyAndReturnArgs>(args: SelectSubset<T, medical_certificatesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medical_certificatesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Medical_certificates.
     * @param {medical_certificatesUpsertArgs} args - Arguments to update or create a Medical_certificates.
     * @example
     * // Update or create a Medical_certificates
     * const medical_certificates = await prisma.medical_certificates.upsert({
     *   create: {
     *     // ... data to create a Medical_certificates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medical_certificates we want to update
     *   }
     * })
     */
    upsert<T extends medical_certificatesUpsertArgs>(args: SelectSubset<T, medical_certificatesUpsertArgs<ExtArgs>>): Prisma__medical_certificatesClient<$Result.GetResult<Prisma.$medical_certificatesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Medical_certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_certificatesCountArgs} args - Arguments to filter Medical_certificates to count.
     * @example
     * // Count the number of Medical_certificates
     * const count = await prisma.medical_certificates.count({
     *   where: {
     *     // ... the filter for the Medical_certificates we want to count
     *   }
     * })
    **/
    count<T extends medical_certificatesCountArgs>(
      args?: Subset<T, medical_certificatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Medical_certificatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medical_certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Medical_certificatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Medical_certificatesAggregateArgs>(args: Subset<T, Medical_certificatesAggregateArgs>): Prisma.PrismaPromise<GetMedical_certificatesAggregateType<T>>

    /**
     * Group by Medical_certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_certificatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends medical_certificatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: medical_certificatesGroupByArgs['orderBy'] }
        : { orderBy?: medical_certificatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, medical_certificatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedical_certificatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the medical_certificates model
   */
  readonly fields: medical_certificatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for medical_certificates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__medical_certificatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the medical_certificates model
   */
  interface medical_certificatesFieldRefs {
    readonly id: FieldRef<"medical_certificates", 'String'>
    readonly patientId: FieldRef<"medical_certificates", 'String'>
    readonly patient: FieldRef<"medical_certificates", 'Json'>
    readonly type: FieldRef<"medical_certificates", 'String'>
    readonly diagnosis: FieldRef<"medical_certificates", 'String'>
    readonly daysOff: FieldRef<"medical_certificates", 'Int'>
    readonly startDate: FieldRef<"medical_certificates", 'String'>
    readonly endDate: FieldRef<"medical_certificates", 'String'>
    readonly notes: FieldRef<"medical_certificates", 'String'>
    readonly issuedBy: FieldRef<"medical_certificates", 'String'>
    readonly createdAt: FieldRef<"medical_certificates", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * medical_certificates findUnique
   */
  export type medical_certificatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_certificates
     */
    select?: medical_certificatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_certificates
     */
    omit?: medical_certificatesOmit<ExtArgs> | null
    /**
     * Filter, which medical_certificates to fetch.
     */
    where: medical_certificatesWhereUniqueInput
  }

  /**
   * medical_certificates findUniqueOrThrow
   */
  export type medical_certificatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_certificates
     */
    select?: medical_certificatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_certificates
     */
    omit?: medical_certificatesOmit<ExtArgs> | null
    /**
     * Filter, which medical_certificates to fetch.
     */
    where: medical_certificatesWhereUniqueInput
  }

  /**
   * medical_certificates findFirst
   */
  export type medical_certificatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_certificates
     */
    select?: medical_certificatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_certificates
     */
    omit?: medical_certificatesOmit<ExtArgs> | null
    /**
     * Filter, which medical_certificates to fetch.
     */
    where?: medical_certificatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medical_certificates to fetch.
     */
    orderBy?: medical_certificatesOrderByWithRelationInput | medical_certificatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medical_certificates.
     */
    cursor?: medical_certificatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medical_certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medical_certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medical_certificates.
     */
    distinct?: Medical_certificatesScalarFieldEnum | Medical_certificatesScalarFieldEnum[]
  }

  /**
   * medical_certificates findFirstOrThrow
   */
  export type medical_certificatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_certificates
     */
    select?: medical_certificatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_certificates
     */
    omit?: medical_certificatesOmit<ExtArgs> | null
    /**
     * Filter, which medical_certificates to fetch.
     */
    where?: medical_certificatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medical_certificates to fetch.
     */
    orderBy?: medical_certificatesOrderByWithRelationInput | medical_certificatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medical_certificates.
     */
    cursor?: medical_certificatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medical_certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medical_certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medical_certificates.
     */
    distinct?: Medical_certificatesScalarFieldEnum | Medical_certificatesScalarFieldEnum[]
  }

  /**
   * medical_certificates findMany
   */
  export type medical_certificatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_certificates
     */
    select?: medical_certificatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_certificates
     */
    omit?: medical_certificatesOmit<ExtArgs> | null
    /**
     * Filter, which medical_certificates to fetch.
     */
    where?: medical_certificatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medical_certificates to fetch.
     */
    orderBy?: medical_certificatesOrderByWithRelationInput | medical_certificatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing medical_certificates.
     */
    cursor?: medical_certificatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medical_certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medical_certificates.
     */
    skip?: number
    distinct?: Medical_certificatesScalarFieldEnum | Medical_certificatesScalarFieldEnum[]
  }

  /**
   * medical_certificates create
   */
  export type medical_certificatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_certificates
     */
    select?: medical_certificatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_certificates
     */
    omit?: medical_certificatesOmit<ExtArgs> | null
    /**
     * The data needed to create a medical_certificates.
     */
    data: XOR<medical_certificatesCreateInput, medical_certificatesUncheckedCreateInput>
  }

  /**
   * medical_certificates createMany
   */
  export type medical_certificatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many medical_certificates.
     */
    data: medical_certificatesCreateManyInput | medical_certificatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * medical_certificates createManyAndReturn
   */
  export type medical_certificatesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_certificates
     */
    select?: medical_certificatesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the medical_certificates
     */
    omit?: medical_certificatesOmit<ExtArgs> | null
    /**
     * The data used to create many medical_certificates.
     */
    data: medical_certificatesCreateManyInput | medical_certificatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * medical_certificates update
   */
  export type medical_certificatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_certificates
     */
    select?: medical_certificatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_certificates
     */
    omit?: medical_certificatesOmit<ExtArgs> | null
    /**
     * The data needed to update a medical_certificates.
     */
    data: XOR<medical_certificatesUpdateInput, medical_certificatesUncheckedUpdateInput>
    /**
     * Choose, which medical_certificates to update.
     */
    where: medical_certificatesWhereUniqueInput
  }

  /**
   * medical_certificates updateMany
   */
  export type medical_certificatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update medical_certificates.
     */
    data: XOR<medical_certificatesUpdateManyMutationInput, medical_certificatesUncheckedUpdateManyInput>
    /**
     * Filter which medical_certificates to update
     */
    where?: medical_certificatesWhereInput
    /**
     * Limit how many medical_certificates to update.
     */
    limit?: number
  }

  /**
   * medical_certificates updateManyAndReturn
   */
  export type medical_certificatesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_certificates
     */
    select?: medical_certificatesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the medical_certificates
     */
    omit?: medical_certificatesOmit<ExtArgs> | null
    /**
     * The data used to update medical_certificates.
     */
    data: XOR<medical_certificatesUpdateManyMutationInput, medical_certificatesUncheckedUpdateManyInput>
    /**
     * Filter which medical_certificates to update
     */
    where?: medical_certificatesWhereInput
    /**
     * Limit how many medical_certificates to update.
     */
    limit?: number
  }

  /**
   * medical_certificates upsert
   */
  export type medical_certificatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_certificates
     */
    select?: medical_certificatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_certificates
     */
    omit?: medical_certificatesOmit<ExtArgs> | null
    /**
     * The filter to search for the medical_certificates to update in case it exists.
     */
    where: medical_certificatesWhereUniqueInput
    /**
     * In case the medical_certificates found by the `where` argument doesn't exist, create a new medical_certificates with this data.
     */
    create: XOR<medical_certificatesCreateInput, medical_certificatesUncheckedCreateInput>
    /**
     * In case the medical_certificates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<medical_certificatesUpdateInput, medical_certificatesUncheckedUpdateInput>
  }

  /**
   * medical_certificates delete
   */
  export type medical_certificatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_certificates
     */
    select?: medical_certificatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_certificates
     */
    omit?: medical_certificatesOmit<ExtArgs> | null
    /**
     * Filter which medical_certificates to delete.
     */
    where: medical_certificatesWhereUniqueInput
  }

  /**
   * medical_certificates deleteMany
   */
  export type medical_certificatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medical_certificates to delete
     */
    where?: medical_certificatesWhereInput
    /**
     * Limit how many medical_certificates to delete.
     */
    limit?: number
  }

  /**
   * medical_certificates without action
   */
  export type medical_certificatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_certificates
     */
    select?: medical_certificatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_certificates
     */
    omit?: medical_certificatesOmit<ExtArgs> | null
  }


  /**
   * Model referral_letters
   */

  export type AggregateReferral_letters = {
    _count: Referral_lettersCountAggregateOutputType | null
    _min: Referral_lettersMinAggregateOutputType | null
    _max: Referral_lettersMaxAggregateOutputType | null
  }

  export type Referral_lettersMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    referredTo: string | null
    reason: string | null
    diagnosis: string | null
    notes: string | null
    issuedBy: string | null
    createdAt: Date | null
  }

  export type Referral_lettersMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    referredTo: string | null
    reason: string | null
    diagnosis: string | null
    notes: string | null
    issuedBy: string | null
    createdAt: Date | null
  }

  export type Referral_lettersCountAggregateOutputType = {
    id: number
    patientId: number
    patient: number
    referredTo: number
    reason: number
    diagnosis: number
    notes: number
    issuedBy: number
    createdAt: number
    _all: number
  }


  export type Referral_lettersMinAggregateInputType = {
    id?: true
    patientId?: true
    referredTo?: true
    reason?: true
    diagnosis?: true
    notes?: true
    issuedBy?: true
    createdAt?: true
  }

  export type Referral_lettersMaxAggregateInputType = {
    id?: true
    patientId?: true
    referredTo?: true
    reason?: true
    diagnosis?: true
    notes?: true
    issuedBy?: true
    createdAt?: true
  }

  export type Referral_lettersCountAggregateInputType = {
    id?: true
    patientId?: true
    patient?: true
    referredTo?: true
    reason?: true
    diagnosis?: true
    notes?: true
    issuedBy?: true
    createdAt?: true
    _all?: true
  }

  export type Referral_lettersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which referral_letters to aggregate.
     */
    where?: referral_lettersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_letters to fetch.
     */
    orderBy?: referral_lettersOrderByWithRelationInput | referral_lettersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: referral_lettersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_letters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_letters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned referral_letters
    **/
    _count?: true | Referral_lettersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Referral_lettersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Referral_lettersMaxAggregateInputType
  }

  export type GetReferral_lettersAggregateType<T extends Referral_lettersAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral_letters]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral_letters[P]>
      : GetScalarType<T[P], AggregateReferral_letters[P]>
  }




  export type referral_lettersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: referral_lettersWhereInput
    orderBy?: referral_lettersOrderByWithAggregationInput | referral_lettersOrderByWithAggregationInput[]
    by: Referral_lettersScalarFieldEnum[] | Referral_lettersScalarFieldEnum
    having?: referral_lettersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Referral_lettersCountAggregateInputType | true
    _min?: Referral_lettersMinAggregateInputType
    _max?: Referral_lettersMaxAggregateInputType
  }

  export type Referral_lettersGroupByOutputType = {
    id: string
    patientId: string | null
    patient: JsonValue | null
    referredTo: string | null
    reason: string | null
    diagnosis: string | null
    notes: string | null
    issuedBy: string | null
    createdAt: Date
    _count: Referral_lettersCountAggregateOutputType | null
    _min: Referral_lettersMinAggregateOutputType | null
    _max: Referral_lettersMaxAggregateOutputType | null
  }

  type GetReferral_lettersGroupByPayload<T extends referral_lettersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Referral_lettersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Referral_lettersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Referral_lettersGroupByOutputType[P]>
            : GetScalarType<T[P], Referral_lettersGroupByOutputType[P]>
        }
      >
    >


  export type referral_lettersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    referredTo?: boolean
    reason?: boolean
    diagnosis?: boolean
    notes?: boolean
    issuedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["referral_letters"]>

  export type referral_lettersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    referredTo?: boolean
    reason?: boolean
    diagnosis?: boolean
    notes?: boolean
    issuedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["referral_letters"]>

  export type referral_lettersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    referredTo?: boolean
    reason?: boolean
    diagnosis?: boolean
    notes?: boolean
    issuedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["referral_letters"]>

  export type referral_lettersSelectScalar = {
    id?: boolean
    patientId?: boolean
    patient?: boolean
    referredTo?: boolean
    reason?: boolean
    diagnosis?: boolean
    notes?: boolean
    issuedBy?: boolean
    createdAt?: boolean
  }

  export type referral_lettersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "patient" | "referredTo" | "reason" | "diagnosis" | "notes" | "issuedBy" | "createdAt", ExtArgs["result"]["referral_letters"]>

  export type $referral_lettersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "referral_letters"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string | null
      patient: Prisma.JsonValue | null
      referredTo: string | null
      reason: string | null
      diagnosis: string | null
      notes: string | null
      issuedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["referral_letters"]>
    composites: {}
  }

  type referral_lettersGetPayload<S extends boolean | null | undefined | referral_lettersDefaultArgs> = $Result.GetResult<Prisma.$referral_lettersPayload, S>

  type referral_lettersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<referral_lettersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Referral_lettersCountAggregateInputType | true
    }

  export interface referral_lettersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['referral_letters'], meta: { name: 'referral_letters' } }
    /**
     * Find zero or one Referral_letters that matches the filter.
     * @param {referral_lettersFindUniqueArgs} args - Arguments to find a Referral_letters
     * @example
     * // Get one Referral_letters
     * const referral_letters = await prisma.referral_letters.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends referral_lettersFindUniqueArgs>(args: SelectSubset<T, referral_lettersFindUniqueArgs<ExtArgs>>): Prisma__referral_lettersClient<$Result.GetResult<Prisma.$referral_lettersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Referral_letters that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {referral_lettersFindUniqueOrThrowArgs} args - Arguments to find a Referral_letters
     * @example
     * // Get one Referral_letters
     * const referral_letters = await prisma.referral_letters.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends referral_lettersFindUniqueOrThrowArgs>(args: SelectSubset<T, referral_lettersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__referral_lettersClient<$Result.GetResult<Prisma.$referral_lettersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral_letters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_lettersFindFirstArgs} args - Arguments to find a Referral_letters
     * @example
     * // Get one Referral_letters
     * const referral_letters = await prisma.referral_letters.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends referral_lettersFindFirstArgs>(args?: SelectSubset<T, referral_lettersFindFirstArgs<ExtArgs>>): Prisma__referral_lettersClient<$Result.GetResult<Prisma.$referral_lettersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral_letters that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_lettersFindFirstOrThrowArgs} args - Arguments to find a Referral_letters
     * @example
     * // Get one Referral_letters
     * const referral_letters = await prisma.referral_letters.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends referral_lettersFindFirstOrThrowArgs>(args?: SelectSubset<T, referral_lettersFindFirstOrThrowArgs<ExtArgs>>): Prisma__referral_lettersClient<$Result.GetResult<Prisma.$referral_lettersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Referral_letters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_lettersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referral_letters
     * const referral_letters = await prisma.referral_letters.findMany()
     * 
     * // Get first 10 Referral_letters
     * const referral_letters = await prisma.referral_letters.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referral_lettersWithIdOnly = await prisma.referral_letters.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends referral_lettersFindManyArgs>(args?: SelectSubset<T, referral_lettersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$referral_lettersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Referral_letters.
     * @param {referral_lettersCreateArgs} args - Arguments to create a Referral_letters.
     * @example
     * // Create one Referral_letters
     * const Referral_letters = await prisma.referral_letters.create({
     *   data: {
     *     // ... data to create a Referral_letters
     *   }
     * })
     * 
     */
    create<T extends referral_lettersCreateArgs>(args: SelectSubset<T, referral_lettersCreateArgs<ExtArgs>>): Prisma__referral_lettersClient<$Result.GetResult<Prisma.$referral_lettersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Referral_letters.
     * @param {referral_lettersCreateManyArgs} args - Arguments to create many Referral_letters.
     * @example
     * // Create many Referral_letters
     * const referral_letters = await prisma.referral_letters.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends referral_lettersCreateManyArgs>(args?: SelectSubset<T, referral_lettersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Referral_letters and returns the data saved in the database.
     * @param {referral_lettersCreateManyAndReturnArgs} args - Arguments to create many Referral_letters.
     * @example
     * // Create many Referral_letters
     * const referral_letters = await prisma.referral_letters.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Referral_letters and only return the `id`
     * const referral_lettersWithIdOnly = await prisma.referral_letters.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends referral_lettersCreateManyAndReturnArgs>(args?: SelectSubset<T, referral_lettersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$referral_lettersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Referral_letters.
     * @param {referral_lettersDeleteArgs} args - Arguments to delete one Referral_letters.
     * @example
     * // Delete one Referral_letters
     * const Referral_letters = await prisma.referral_letters.delete({
     *   where: {
     *     // ... filter to delete one Referral_letters
     *   }
     * })
     * 
     */
    delete<T extends referral_lettersDeleteArgs>(args: SelectSubset<T, referral_lettersDeleteArgs<ExtArgs>>): Prisma__referral_lettersClient<$Result.GetResult<Prisma.$referral_lettersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Referral_letters.
     * @param {referral_lettersUpdateArgs} args - Arguments to update one Referral_letters.
     * @example
     * // Update one Referral_letters
     * const referral_letters = await prisma.referral_letters.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends referral_lettersUpdateArgs>(args: SelectSubset<T, referral_lettersUpdateArgs<ExtArgs>>): Prisma__referral_lettersClient<$Result.GetResult<Prisma.$referral_lettersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Referral_letters.
     * @param {referral_lettersDeleteManyArgs} args - Arguments to filter Referral_letters to delete.
     * @example
     * // Delete a few Referral_letters
     * const { count } = await prisma.referral_letters.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends referral_lettersDeleteManyArgs>(args?: SelectSubset<T, referral_lettersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referral_letters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_lettersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referral_letters
     * const referral_letters = await prisma.referral_letters.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends referral_lettersUpdateManyArgs>(args: SelectSubset<T, referral_lettersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referral_letters and returns the data updated in the database.
     * @param {referral_lettersUpdateManyAndReturnArgs} args - Arguments to update many Referral_letters.
     * @example
     * // Update many Referral_letters
     * const referral_letters = await prisma.referral_letters.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Referral_letters and only return the `id`
     * const referral_lettersWithIdOnly = await prisma.referral_letters.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends referral_lettersUpdateManyAndReturnArgs>(args: SelectSubset<T, referral_lettersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$referral_lettersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Referral_letters.
     * @param {referral_lettersUpsertArgs} args - Arguments to update or create a Referral_letters.
     * @example
     * // Update or create a Referral_letters
     * const referral_letters = await prisma.referral_letters.upsert({
     *   create: {
     *     // ... data to create a Referral_letters
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral_letters we want to update
     *   }
     * })
     */
    upsert<T extends referral_lettersUpsertArgs>(args: SelectSubset<T, referral_lettersUpsertArgs<ExtArgs>>): Prisma__referral_lettersClient<$Result.GetResult<Prisma.$referral_lettersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Referral_letters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_lettersCountArgs} args - Arguments to filter Referral_letters to count.
     * @example
     * // Count the number of Referral_letters
     * const count = await prisma.referral_letters.count({
     *   where: {
     *     // ... the filter for the Referral_letters we want to count
     *   }
     * })
    **/
    count<T extends referral_lettersCountArgs>(
      args?: Subset<T, referral_lettersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Referral_lettersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral_letters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Referral_lettersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Referral_lettersAggregateArgs>(args: Subset<T, Referral_lettersAggregateArgs>): Prisma.PrismaPromise<GetReferral_lettersAggregateType<T>>

    /**
     * Group by Referral_letters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referral_lettersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends referral_lettersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: referral_lettersGroupByArgs['orderBy'] }
        : { orderBy?: referral_lettersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, referral_lettersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferral_lettersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the referral_letters model
   */
  readonly fields: referral_lettersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for referral_letters.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__referral_lettersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the referral_letters model
   */
  interface referral_lettersFieldRefs {
    readonly id: FieldRef<"referral_letters", 'String'>
    readonly patientId: FieldRef<"referral_letters", 'String'>
    readonly patient: FieldRef<"referral_letters", 'Json'>
    readonly referredTo: FieldRef<"referral_letters", 'String'>
    readonly reason: FieldRef<"referral_letters", 'String'>
    readonly diagnosis: FieldRef<"referral_letters", 'String'>
    readonly notes: FieldRef<"referral_letters", 'String'>
    readonly issuedBy: FieldRef<"referral_letters", 'String'>
    readonly createdAt: FieldRef<"referral_letters", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * referral_letters findUnique
   */
  export type referral_lettersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_letters
     */
    select?: referral_lettersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the referral_letters
     */
    omit?: referral_lettersOmit<ExtArgs> | null
    /**
     * Filter, which referral_letters to fetch.
     */
    where: referral_lettersWhereUniqueInput
  }

  /**
   * referral_letters findUniqueOrThrow
   */
  export type referral_lettersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_letters
     */
    select?: referral_lettersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the referral_letters
     */
    omit?: referral_lettersOmit<ExtArgs> | null
    /**
     * Filter, which referral_letters to fetch.
     */
    where: referral_lettersWhereUniqueInput
  }

  /**
   * referral_letters findFirst
   */
  export type referral_lettersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_letters
     */
    select?: referral_lettersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the referral_letters
     */
    omit?: referral_lettersOmit<ExtArgs> | null
    /**
     * Filter, which referral_letters to fetch.
     */
    where?: referral_lettersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_letters to fetch.
     */
    orderBy?: referral_lettersOrderByWithRelationInput | referral_lettersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for referral_letters.
     */
    cursor?: referral_lettersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_letters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_letters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of referral_letters.
     */
    distinct?: Referral_lettersScalarFieldEnum | Referral_lettersScalarFieldEnum[]
  }

  /**
   * referral_letters findFirstOrThrow
   */
  export type referral_lettersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_letters
     */
    select?: referral_lettersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the referral_letters
     */
    omit?: referral_lettersOmit<ExtArgs> | null
    /**
     * Filter, which referral_letters to fetch.
     */
    where?: referral_lettersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_letters to fetch.
     */
    orderBy?: referral_lettersOrderByWithRelationInput | referral_lettersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for referral_letters.
     */
    cursor?: referral_lettersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_letters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_letters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of referral_letters.
     */
    distinct?: Referral_lettersScalarFieldEnum | Referral_lettersScalarFieldEnum[]
  }

  /**
   * referral_letters findMany
   */
  export type referral_lettersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_letters
     */
    select?: referral_lettersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the referral_letters
     */
    omit?: referral_lettersOmit<ExtArgs> | null
    /**
     * Filter, which referral_letters to fetch.
     */
    where?: referral_lettersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of referral_letters to fetch.
     */
    orderBy?: referral_lettersOrderByWithRelationInput | referral_lettersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing referral_letters.
     */
    cursor?: referral_lettersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` referral_letters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` referral_letters.
     */
    skip?: number
    distinct?: Referral_lettersScalarFieldEnum | Referral_lettersScalarFieldEnum[]
  }

  /**
   * referral_letters create
   */
  export type referral_lettersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_letters
     */
    select?: referral_lettersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the referral_letters
     */
    omit?: referral_lettersOmit<ExtArgs> | null
    /**
     * The data needed to create a referral_letters.
     */
    data: XOR<referral_lettersCreateInput, referral_lettersUncheckedCreateInput>
  }

  /**
   * referral_letters createMany
   */
  export type referral_lettersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many referral_letters.
     */
    data: referral_lettersCreateManyInput | referral_lettersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * referral_letters createManyAndReturn
   */
  export type referral_lettersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_letters
     */
    select?: referral_lettersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the referral_letters
     */
    omit?: referral_lettersOmit<ExtArgs> | null
    /**
     * The data used to create many referral_letters.
     */
    data: referral_lettersCreateManyInput | referral_lettersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * referral_letters update
   */
  export type referral_lettersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_letters
     */
    select?: referral_lettersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the referral_letters
     */
    omit?: referral_lettersOmit<ExtArgs> | null
    /**
     * The data needed to update a referral_letters.
     */
    data: XOR<referral_lettersUpdateInput, referral_lettersUncheckedUpdateInput>
    /**
     * Choose, which referral_letters to update.
     */
    where: referral_lettersWhereUniqueInput
  }

  /**
   * referral_letters updateMany
   */
  export type referral_lettersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update referral_letters.
     */
    data: XOR<referral_lettersUpdateManyMutationInput, referral_lettersUncheckedUpdateManyInput>
    /**
     * Filter which referral_letters to update
     */
    where?: referral_lettersWhereInput
    /**
     * Limit how many referral_letters to update.
     */
    limit?: number
  }

  /**
   * referral_letters updateManyAndReturn
   */
  export type referral_lettersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_letters
     */
    select?: referral_lettersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the referral_letters
     */
    omit?: referral_lettersOmit<ExtArgs> | null
    /**
     * The data used to update referral_letters.
     */
    data: XOR<referral_lettersUpdateManyMutationInput, referral_lettersUncheckedUpdateManyInput>
    /**
     * Filter which referral_letters to update
     */
    where?: referral_lettersWhereInput
    /**
     * Limit how many referral_letters to update.
     */
    limit?: number
  }

  /**
   * referral_letters upsert
   */
  export type referral_lettersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_letters
     */
    select?: referral_lettersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the referral_letters
     */
    omit?: referral_lettersOmit<ExtArgs> | null
    /**
     * The filter to search for the referral_letters to update in case it exists.
     */
    where: referral_lettersWhereUniqueInput
    /**
     * In case the referral_letters found by the `where` argument doesn't exist, create a new referral_letters with this data.
     */
    create: XOR<referral_lettersCreateInput, referral_lettersUncheckedCreateInput>
    /**
     * In case the referral_letters was found with the provided `where` argument, update it with this data.
     */
    update: XOR<referral_lettersUpdateInput, referral_lettersUncheckedUpdateInput>
  }

  /**
   * referral_letters delete
   */
  export type referral_lettersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_letters
     */
    select?: referral_lettersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the referral_letters
     */
    omit?: referral_lettersOmit<ExtArgs> | null
    /**
     * Filter which referral_letters to delete.
     */
    where: referral_lettersWhereUniqueInput
  }

  /**
   * referral_letters deleteMany
   */
  export type referral_lettersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which referral_letters to delete
     */
    where?: referral_lettersWhereInput
    /**
     * Limit how many referral_letters to delete.
     */
    limit?: number
  }

  /**
   * referral_letters without action
   */
  export type referral_lettersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the referral_letters
     */
    select?: referral_lettersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the referral_letters
     */
    omit?: referral_lettersOmit<ExtArgs> | null
  }


  /**
   * Model discharge_summaries
   */

  export type AggregateDischarge_summaries = {
    _count: Discharge_summariesCountAggregateOutputType | null
    _min: Discharge_summariesMinAggregateOutputType | null
    _max: Discharge_summariesMaxAggregateOutputType | null
  }

  export type Discharge_summariesMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    admissionDate: string | null
    dischargeDate: string | null
    diagnosis: string | null
    treatment: string | null
    medications: string | null
    followUp: string | null
    notes: string | null
    dischargedBy: string | null
    createdAt: Date | null
  }

  export type Discharge_summariesMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    admissionDate: string | null
    dischargeDate: string | null
    diagnosis: string | null
    treatment: string | null
    medications: string | null
    followUp: string | null
    notes: string | null
    dischargedBy: string | null
    createdAt: Date | null
  }

  export type Discharge_summariesCountAggregateOutputType = {
    id: number
    patientId: number
    patient: number
    admissionDate: number
    dischargeDate: number
    diagnosis: number
    treatment: number
    medications: number
    followUp: number
    notes: number
    dischargedBy: number
    createdAt: number
    _all: number
  }


  export type Discharge_summariesMinAggregateInputType = {
    id?: true
    patientId?: true
    admissionDate?: true
    dischargeDate?: true
    diagnosis?: true
    treatment?: true
    medications?: true
    followUp?: true
    notes?: true
    dischargedBy?: true
    createdAt?: true
  }

  export type Discharge_summariesMaxAggregateInputType = {
    id?: true
    patientId?: true
    admissionDate?: true
    dischargeDate?: true
    diagnosis?: true
    treatment?: true
    medications?: true
    followUp?: true
    notes?: true
    dischargedBy?: true
    createdAt?: true
  }

  export type Discharge_summariesCountAggregateInputType = {
    id?: true
    patientId?: true
    patient?: true
    admissionDate?: true
    dischargeDate?: true
    diagnosis?: true
    treatment?: true
    medications?: true
    followUp?: true
    notes?: true
    dischargedBy?: true
    createdAt?: true
    _all?: true
  }

  export type Discharge_summariesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which discharge_summaries to aggregate.
     */
    where?: discharge_summariesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of discharge_summaries to fetch.
     */
    orderBy?: discharge_summariesOrderByWithRelationInput | discharge_summariesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: discharge_summariesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` discharge_summaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` discharge_summaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned discharge_summaries
    **/
    _count?: true | Discharge_summariesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Discharge_summariesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Discharge_summariesMaxAggregateInputType
  }

  export type GetDischarge_summariesAggregateType<T extends Discharge_summariesAggregateArgs> = {
        [P in keyof T & keyof AggregateDischarge_summaries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDischarge_summaries[P]>
      : GetScalarType<T[P], AggregateDischarge_summaries[P]>
  }




  export type discharge_summariesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: discharge_summariesWhereInput
    orderBy?: discharge_summariesOrderByWithAggregationInput | discharge_summariesOrderByWithAggregationInput[]
    by: Discharge_summariesScalarFieldEnum[] | Discharge_summariesScalarFieldEnum
    having?: discharge_summariesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Discharge_summariesCountAggregateInputType | true
    _min?: Discharge_summariesMinAggregateInputType
    _max?: Discharge_summariesMaxAggregateInputType
  }

  export type Discharge_summariesGroupByOutputType = {
    id: string
    patientId: string | null
    patient: JsonValue | null
    admissionDate: string | null
    dischargeDate: string | null
    diagnosis: string | null
    treatment: string | null
    medications: string | null
    followUp: string | null
    notes: string | null
    dischargedBy: string | null
    createdAt: Date
    _count: Discharge_summariesCountAggregateOutputType | null
    _min: Discharge_summariesMinAggregateOutputType | null
    _max: Discharge_summariesMaxAggregateOutputType | null
  }

  type GetDischarge_summariesGroupByPayload<T extends discharge_summariesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Discharge_summariesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Discharge_summariesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Discharge_summariesGroupByOutputType[P]>
            : GetScalarType<T[P], Discharge_summariesGroupByOutputType[P]>
        }
      >
    >


  export type discharge_summariesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    admissionDate?: boolean
    dischargeDate?: boolean
    diagnosis?: boolean
    treatment?: boolean
    medications?: boolean
    followUp?: boolean
    notes?: boolean
    dischargedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["discharge_summaries"]>

  export type discharge_summariesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    admissionDate?: boolean
    dischargeDate?: boolean
    diagnosis?: boolean
    treatment?: boolean
    medications?: boolean
    followUp?: boolean
    notes?: boolean
    dischargedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["discharge_summaries"]>

  export type discharge_summariesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    patient?: boolean
    admissionDate?: boolean
    dischargeDate?: boolean
    diagnosis?: boolean
    treatment?: boolean
    medications?: boolean
    followUp?: boolean
    notes?: boolean
    dischargedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["discharge_summaries"]>

  export type discharge_summariesSelectScalar = {
    id?: boolean
    patientId?: boolean
    patient?: boolean
    admissionDate?: boolean
    dischargeDate?: boolean
    diagnosis?: boolean
    treatment?: boolean
    medications?: boolean
    followUp?: boolean
    notes?: boolean
    dischargedBy?: boolean
    createdAt?: boolean
  }

  export type discharge_summariesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "patient" | "admissionDate" | "dischargeDate" | "diagnosis" | "treatment" | "medications" | "followUp" | "notes" | "dischargedBy" | "createdAt", ExtArgs["result"]["discharge_summaries"]>

  export type $discharge_summariesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "discharge_summaries"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string | null
      patient: Prisma.JsonValue | null
      admissionDate: string | null
      dischargeDate: string | null
      diagnosis: string | null
      treatment: string | null
      medications: string | null
      followUp: string | null
      notes: string | null
      dischargedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["discharge_summaries"]>
    composites: {}
  }

  type discharge_summariesGetPayload<S extends boolean | null | undefined | discharge_summariesDefaultArgs> = $Result.GetResult<Prisma.$discharge_summariesPayload, S>

  type discharge_summariesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<discharge_summariesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Discharge_summariesCountAggregateInputType | true
    }

  export interface discharge_summariesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['discharge_summaries'], meta: { name: 'discharge_summaries' } }
    /**
     * Find zero or one Discharge_summaries that matches the filter.
     * @param {discharge_summariesFindUniqueArgs} args - Arguments to find a Discharge_summaries
     * @example
     * // Get one Discharge_summaries
     * const discharge_summaries = await prisma.discharge_summaries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends discharge_summariesFindUniqueArgs>(args: SelectSubset<T, discharge_summariesFindUniqueArgs<ExtArgs>>): Prisma__discharge_summariesClient<$Result.GetResult<Prisma.$discharge_summariesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Discharge_summaries that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {discharge_summariesFindUniqueOrThrowArgs} args - Arguments to find a Discharge_summaries
     * @example
     * // Get one Discharge_summaries
     * const discharge_summaries = await prisma.discharge_summaries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends discharge_summariesFindUniqueOrThrowArgs>(args: SelectSubset<T, discharge_summariesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__discharge_summariesClient<$Result.GetResult<Prisma.$discharge_summariesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discharge_summaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {discharge_summariesFindFirstArgs} args - Arguments to find a Discharge_summaries
     * @example
     * // Get one Discharge_summaries
     * const discharge_summaries = await prisma.discharge_summaries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends discharge_summariesFindFirstArgs>(args?: SelectSubset<T, discharge_summariesFindFirstArgs<ExtArgs>>): Prisma__discharge_summariesClient<$Result.GetResult<Prisma.$discharge_summariesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discharge_summaries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {discharge_summariesFindFirstOrThrowArgs} args - Arguments to find a Discharge_summaries
     * @example
     * // Get one Discharge_summaries
     * const discharge_summaries = await prisma.discharge_summaries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends discharge_summariesFindFirstOrThrowArgs>(args?: SelectSubset<T, discharge_summariesFindFirstOrThrowArgs<ExtArgs>>): Prisma__discharge_summariesClient<$Result.GetResult<Prisma.$discharge_summariesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Discharge_summaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {discharge_summariesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Discharge_summaries
     * const discharge_summaries = await prisma.discharge_summaries.findMany()
     * 
     * // Get first 10 Discharge_summaries
     * const discharge_summaries = await prisma.discharge_summaries.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discharge_summariesWithIdOnly = await prisma.discharge_summaries.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends discharge_summariesFindManyArgs>(args?: SelectSubset<T, discharge_summariesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$discharge_summariesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Discharge_summaries.
     * @param {discharge_summariesCreateArgs} args - Arguments to create a Discharge_summaries.
     * @example
     * // Create one Discharge_summaries
     * const Discharge_summaries = await prisma.discharge_summaries.create({
     *   data: {
     *     // ... data to create a Discharge_summaries
     *   }
     * })
     * 
     */
    create<T extends discharge_summariesCreateArgs>(args: SelectSubset<T, discharge_summariesCreateArgs<ExtArgs>>): Prisma__discharge_summariesClient<$Result.GetResult<Prisma.$discharge_summariesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Discharge_summaries.
     * @param {discharge_summariesCreateManyArgs} args - Arguments to create many Discharge_summaries.
     * @example
     * // Create many Discharge_summaries
     * const discharge_summaries = await prisma.discharge_summaries.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends discharge_summariesCreateManyArgs>(args?: SelectSubset<T, discharge_summariesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Discharge_summaries and returns the data saved in the database.
     * @param {discharge_summariesCreateManyAndReturnArgs} args - Arguments to create many Discharge_summaries.
     * @example
     * // Create many Discharge_summaries
     * const discharge_summaries = await prisma.discharge_summaries.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Discharge_summaries and only return the `id`
     * const discharge_summariesWithIdOnly = await prisma.discharge_summaries.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends discharge_summariesCreateManyAndReturnArgs>(args?: SelectSubset<T, discharge_summariesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$discharge_summariesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Discharge_summaries.
     * @param {discharge_summariesDeleteArgs} args - Arguments to delete one Discharge_summaries.
     * @example
     * // Delete one Discharge_summaries
     * const Discharge_summaries = await prisma.discharge_summaries.delete({
     *   where: {
     *     // ... filter to delete one Discharge_summaries
     *   }
     * })
     * 
     */
    delete<T extends discharge_summariesDeleteArgs>(args: SelectSubset<T, discharge_summariesDeleteArgs<ExtArgs>>): Prisma__discharge_summariesClient<$Result.GetResult<Prisma.$discharge_summariesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Discharge_summaries.
     * @param {discharge_summariesUpdateArgs} args - Arguments to update one Discharge_summaries.
     * @example
     * // Update one Discharge_summaries
     * const discharge_summaries = await prisma.discharge_summaries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends discharge_summariesUpdateArgs>(args: SelectSubset<T, discharge_summariesUpdateArgs<ExtArgs>>): Prisma__discharge_summariesClient<$Result.GetResult<Prisma.$discharge_summariesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Discharge_summaries.
     * @param {discharge_summariesDeleteManyArgs} args - Arguments to filter Discharge_summaries to delete.
     * @example
     * // Delete a few Discharge_summaries
     * const { count } = await prisma.discharge_summaries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends discharge_summariesDeleteManyArgs>(args?: SelectSubset<T, discharge_summariesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discharge_summaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {discharge_summariesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Discharge_summaries
     * const discharge_summaries = await prisma.discharge_summaries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends discharge_summariesUpdateManyArgs>(args: SelectSubset<T, discharge_summariesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discharge_summaries and returns the data updated in the database.
     * @param {discharge_summariesUpdateManyAndReturnArgs} args - Arguments to update many Discharge_summaries.
     * @example
     * // Update many Discharge_summaries
     * const discharge_summaries = await prisma.discharge_summaries.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Discharge_summaries and only return the `id`
     * const discharge_summariesWithIdOnly = await prisma.discharge_summaries.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends discharge_summariesUpdateManyAndReturnArgs>(args: SelectSubset<T, discharge_summariesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$discharge_summariesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Discharge_summaries.
     * @param {discharge_summariesUpsertArgs} args - Arguments to update or create a Discharge_summaries.
     * @example
     * // Update or create a Discharge_summaries
     * const discharge_summaries = await prisma.discharge_summaries.upsert({
     *   create: {
     *     // ... data to create a Discharge_summaries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Discharge_summaries we want to update
     *   }
     * })
     */
    upsert<T extends discharge_summariesUpsertArgs>(args: SelectSubset<T, discharge_summariesUpsertArgs<ExtArgs>>): Prisma__discharge_summariesClient<$Result.GetResult<Prisma.$discharge_summariesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Discharge_summaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {discharge_summariesCountArgs} args - Arguments to filter Discharge_summaries to count.
     * @example
     * // Count the number of Discharge_summaries
     * const count = await prisma.discharge_summaries.count({
     *   where: {
     *     // ... the filter for the Discharge_summaries we want to count
     *   }
     * })
    **/
    count<T extends discharge_summariesCountArgs>(
      args?: Subset<T, discharge_summariesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Discharge_summariesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Discharge_summaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Discharge_summariesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Discharge_summariesAggregateArgs>(args: Subset<T, Discharge_summariesAggregateArgs>): Prisma.PrismaPromise<GetDischarge_summariesAggregateType<T>>

    /**
     * Group by Discharge_summaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {discharge_summariesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends discharge_summariesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: discharge_summariesGroupByArgs['orderBy'] }
        : { orderBy?: discharge_summariesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, discharge_summariesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDischarge_summariesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the discharge_summaries model
   */
  readonly fields: discharge_summariesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for discharge_summaries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__discharge_summariesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the discharge_summaries model
   */
  interface discharge_summariesFieldRefs {
    readonly id: FieldRef<"discharge_summaries", 'String'>
    readonly patientId: FieldRef<"discharge_summaries", 'String'>
    readonly patient: FieldRef<"discharge_summaries", 'Json'>
    readonly admissionDate: FieldRef<"discharge_summaries", 'String'>
    readonly dischargeDate: FieldRef<"discharge_summaries", 'String'>
    readonly diagnosis: FieldRef<"discharge_summaries", 'String'>
    readonly treatment: FieldRef<"discharge_summaries", 'String'>
    readonly medications: FieldRef<"discharge_summaries", 'String'>
    readonly followUp: FieldRef<"discharge_summaries", 'String'>
    readonly notes: FieldRef<"discharge_summaries", 'String'>
    readonly dischargedBy: FieldRef<"discharge_summaries", 'String'>
    readonly createdAt: FieldRef<"discharge_summaries", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * discharge_summaries findUnique
   */
  export type discharge_summariesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discharge_summaries
     */
    select?: discharge_summariesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discharge_summaries
     */
    omit?: discharge_summariesOmit<ExtArgs> | null
    /**
     * Filter, which discharge_summaries to fetch.
     */
    where: discharge_summariesWhereUniqueInput
  }

  /**
   * discharge_summaries findUniqueOrThrow
   */
  export type discharge_summariesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discharge_summaries
     */
    select?: discharge_summariesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discharge_summaries
     */
    omit?: discharge_summariesOmit<ExtArgs> | null
    /**
     * Filter, which discharge_summaries to fetch.
     */
    where: discharge_summariesWhereUniqueInput
  }

  /**
   * discharge_summaries findFirst
   */
  export type discharge_summariesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discharge_summaries
     */
    select?: discharge_summariesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discharge_summaries
     */
    omit?: discharge_summariesOmit<ExtArgs> | null
    /**
     * Filter, which discharge_summaries to fetch.
     */
    where?: discharge_summariesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of discharge_summaries to fetch.
     */
    orderBy?: discharge_summariesOrderByWithRelationInput | discharge_summariesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for discharge_summaries.
     */
    cursor?: discharge_summariesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` discharge_summaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` discharge_summaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of discharge_summaries.
     */
    distinct?: Discharge_summariesScalarFieldEnum | Discharge_summariesScalarFieldEnum[]
  }

  /**
   * discharge_summaries findFirstOrThrow
   */
  export type discharge_summariesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discharge_summaries
     */
    select?: discharge_summariesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discharge_summaries
     */
    omit?: discharge_summariesOmit<ExtArgs> | null
    /**
     * Filter, which discharge_summaries to fetch.
     */
    where?: discharge_summariesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of discharge_summaries to fetch.
     */
    orderBy?: discharge_summariesOrderByWithRelationInput | discharge_summariesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for discharge_summaries.
     */
    cursor?: discharge_summariesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` discharge_summaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` discharge_summaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of discharge_summaries.
     */
    distinct?: Discharge_summariesScalarFieldEnum | Discharge_summariesScalarFieldEnum[]
  }

  /**
   * discharge_summaries findMany
   */
  export type discharge_summariesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discharge_summaries
     */
    select?: discharge_summariesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discharge_summaries
     */
    omit?: discharge_summariesOmit<ExtArgs> | null
    /**
     * Filter, which discharge_summaries to fetch.
     */
    where?: discharge_summariesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of discharge_summaries to fetch.
     */
    orderBy?: discharge_summariesOrderByWithRelationInput | discharge_summariesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing discharge_summaries.
     */
    cursor?: discharge_summariesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` discharge_summaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` discharge_summaries.
     */
    skip?: number
    distinct?: Discharge_summariesScalarFieldEnum | Discharge_summariesScalarFieldEnum[]
  }

  /**
   * discharge_summaries create
   */
  export type discharge_summariesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discharge_summaries
     */
    select?: discharge_summariesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discharge_summaries
     */
    omit?: discharge_summariesOmit<ExtArgs> | null
    /**
     * The data needed to create a discharge_summaries.
     */
    data: XOR<discharge_summariesCreateInput, discharge_summariesUncheckedCreateInput>
  }

  /**
   * discharge_summaries createMany
   */
  export type discharge_summariesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many discharge_summaries.
     */
    data: discharge_summariesCreateManyInput | discharge_summariesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * discharge_summaries createManyAndReturn
   */
  export type discharge_summariesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discharge_summaries
     */
    select?: discharge_summariesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the discharge_summaries
     */
    omit?: discharge_summariesOmit<ExtArgs> | null
    /**
     * The data used to create many discharge_summaries.
     */
    data: discharge_summariesCreateManyInput | discharge_summariesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * discharge_summaries update
   */
  export type discharge_summariesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discharge_summaries
     */
    select?: discharge_summariesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discharge_summaries
     */
    omit?: discharge_summariesOmit<ExtArgs> | null
    /**
     * The data needed to update a discharge_summaries.
     */
    data: XOR<discharge_summariesUpdateInput, discharge_summariesUncheckedUpdateInput>
    /**
     * Choose, which discharge_summaries to update.
     */
    where: discharge_summariesWhereUniqueInput
  }

  /**
   * discharge_summaries updateMany
   */
  export type discharge_summariesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update discharge_summaries.
     */
    data: XOR<discharge_summariesUpdateManyMutationInput, discharge_summariesUncheckedUpdateManyInput>
    /**
     * Filter which discharge_summaries to update
     */
    where?: discharge_summariesWhereInput
    /**
     * Limit how many discharge_summaries to update.
     */
    limit?: number
  }

  /**
   * discharge_summaries updateManyAndReturn
   */
  export type discharge_summariesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discharge_summaries
     */
    select?: discharge_summariesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the discharge_summaries
     */
    omit?: discharge_summariesOmit<ExtArgs> | null
    /**
     * The data used to update discharge_summaries.
     */
    data: XOR<discharge_summariesUpdateManyMutationInput, discharge_summariesUncheckedUpdateManyInput>
    /**
     * Filter which discharge_summaries to update
     */
    where?: discharge_summariesWhereInput
    /**
     * Limit how many discharge_summaries to update.
     */
    limit?: number
  }

  /**
   * discharge_summaries upsert
   */
  export type discharge_summariesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discharge_summaries
     */
    select?: discharge_summariesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discharge_summaries
     */
    omit?: discharge_summariesOmit<ExtArgs> | null
    /**
     * The filter to search for the discharge_summaries to update in case it exists.
     */
    where: discharge_summariesWhereUniqueInput
    /**
     * In case the discharge_summaries found by the `where` argument doesn't exist, create a new discharge_summaries with this data.
     */
    create: XOR<discharge_summariesCreateInput, discharge_summariesUncheckedCreateInput>
    /**
     * In case the discharge_summaries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<discharge_summariesUpdateInput, discharge_summariesUncheckedUpdateInput>
  }

  /**
   * discharge_summaries delete
   */
  export type discharge_summariesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discharge_summaries
     */
    select?: discharge_summariesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discharge_summaries
     */
    omit?: discharge_summariesOmit<ExtArgs> | null
    /**
     * Filter which discharge_summaries to delete.
     */
    where: discharge_summariesWhereUniqueInput
  }

  /**
   * discharge_summaries deleteMany
   */
  export type discharge_summariesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which discharge_summaries to delete
     */
    where?: discharge_summariesWhereInput
    /**
     * Limit how many discharge_summaries to delete.
     */
    limit?: number
  }

  /**
   * discharge_summaries without action
   */
  export type discharge_summariesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discharge_summaries
     */
    select?: discharge_summariesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discharge_summaries
     */
    omit?: discharge_summariesOmit<ExtArgs> | null
  }


  /**
   * Model audit_logs
   */

  export type AggregateAudit_logs = {
    _count: Audit_logsCountAggregateOutputType | null
    _min: Audit_logsMinAggregateOutputType | null
    _max: Audit_logsMaxAggregateOutputType | null
  }

  export type Audit_logsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    action: string | null
    description: string | null
    timestamp: Date | null
  }

  export type Audit_logsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    action: string | null
    description: string | null
    timestamp: Date | null
  }

  export type Audit_logsCountAggregateOutputType = {
    id: number
    userId: number
    userName: number
    action: number
    description: number
    metadata: number
    timestamp: number
    _all: number
  }


  export type Audit_logsMinAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    action?: true
    description?: true
    timestamp?: true
  }

  export type Audit_logsMaxAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    action?: true
    description?: true
    timestamp?: true
  }

  export type Audit_logsCountAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    action?: true
    description?: true
    metadata?: true
    timestamp?: true
    _all?: true
  }

  export type Audit_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which audit_logs to aggregate.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned audit_logs
    **/
    _count?: true | Audit_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Audit_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Audit_logsMaxAggregateInputType
  }

  export type GetAudit_logsAggregateType<T extends Audit_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateAudit_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudit_logs[P]>
      : GetScalarType<T[P], AggregateAudit_logs[P]>
  }




  export type audit_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: audit_logsWhereInput
    orderBy?: audit_logsOrderByWithAggregationInput | audit_logsOrderByWithAggregationInput[]
    by: Audit_logsScalarFieldEnum[] | Audit_logsScalarFieldEnum
    having?: audit_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Audit_logsCountAggregateInputType | true
    _min?: Audit_logsMinAggregateInputType
    _max?: Audit_logsMaxAggregateInputType
  }

  export type Audit_logsGroupByOutputType = {
    id: string
    userId: string | null
    userName: string | null
    action: string
    description: string | null
    metadata: JsonValue | null
    timestamp: Date
    _count: Audit_logsCountAggregateOutputType | null
    _min: Audit_logsMinAggregateOutputType | null
    _max: Audit_logsMaxAggregateOutputType | null
  }

  type GetAudit_logsGroupByPayload<T extends audit_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Audit_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Audit_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Audit_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Audit_logsGroupByOutputType[P]>
        }
      >
    >


  export type audit_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    action?: boolean
    description?: boolean
    metadata?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["audit_logs"]>

  export type audit_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    action?: boolean
    description?: boolean
    metadata?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["audit_logs"]>

  export type audit_logsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    action?: boolean
    description?: boolean
    metadata?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["audit_logs"]>

  export type audit_logsSelectScalar = {
    id?: boolean
    userId?: boolean
    userName?: boolean
    action?: boolean
    description?: boolean
    metadata?: boolean
    timestamp?: boolean
  }

  export type audit_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "userName" | "action" | "description" | "metadata" | "timestamp", ExtArgs["result"]["audit_logs"]>

  export type $audit_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "audit_logs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      userName: string | null
      action: string
      description: string | null
      metadata: Prisma.JsonValue | null
      timestamp: Date
    }, ExtArgs["result"]["audit_logs"]>
    composites: {}
  }

  type audit_logsGetPayload<S extends boolean | null | undefined | audit_logsDefaultArgs> = $Result.GetResult<Prisma.$audit_logsPayload, S>

  type audit_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<audit_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Audit_logsCountAggregateInputType | true
    }

  export interface audit_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['audit_logs'], meta: { name: 'audit_logs' } }
    /**
     * Find zero or one Audit_logs that matches the filter.
     * @param {audit_logsFindUniqueArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends audit_logsFindUniqueArgs>(args: SelectSubset<T, audit_logsFindUniqueArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Audit_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {audit_logsFindUniqueOrThrowArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends audit_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, audit_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsFindFirstArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends audit_logsFindFirstArgs>(args?: SelectSubset<T, audit_logsFindFirstArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsFindFirstOrThrowArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends audit_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, audit_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Audit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Audit_logs
     * const audit_logs = await prisma.audit_logs.findMany()
     * 
     * // Get first 10 Audit_logs
     * const audit_logs = await prisma.audit_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audit_logsWithIdOnly = await prisma.audit_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends audit_logsFindManyArgs>(args?: SelectSubset<T, audit_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Audit_logs.
     * @param {audit_logsCreateArgs} args - Arguments to create a Audit_logs.
     * @example
     * // Create one Audit_logs
     * const Audit_logs = await prisma.audit_logs.create({
     *   data: {
     *     // ... data to create a Audit_logs
     *   }
     * })
     * 
     */
    create<T extends audit_logsCreateArgs>(args: SelectSubset<T, audit_logsCreateArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Audit_logs.
     * @param {audit_logsCreateManyArgs} args - Arguments to create many Audit_logs.
     * @example
     * // Create many Audit_logs
     * const audit_logs = await prisma.audit_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends audit_logsCreateManyArgs>(args?: SelectSubset<T, audit_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Audit_logs and returns the data saved in the database.
     * @param {audit_logsCreateManyAndReturnArgs} args - Arguments to create many Audit_logs.
     * @example
     * // Create many Audit_logs
     * const audit_logs = await prisma.audit_logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Audit_logs and only return the `id`
     * const audit_logsWithIdOnly = await prisma.audit_logs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends audit_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, audit_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Audit_logs.
     * @param {audit_logsDeleteArgs} args - Arguments to delete one Audit_logs.
     * @example
     * // Delete one Audit_logs
     * const Audit_logs = await prisma.audit_logs.delete({
     *   where: {
     *     // ... filter to delete one Audit_logs
     *   }
     * })
     * 
     */
    delete<T extends audit_logsDeleteArgs>(args: SelectSubset<T, audit_logsDeleteArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Audit_logs.
     * @param {audit_logsUpdateArgs} args - Arguments to update one Audit_logs.
     * @example
     * // Update one Audit_logs
     * const audit_logs = await prisma.audit_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends audit_logsUpdateArgs>(args: SelectSubset<T, audit_logsUpdateArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Audit_logs.
     * @param {audit_logsDeleteManyArgs} args - Arguments to filter Audit_logs to delete.
     * @example
     * // Delete a few Audit_logs
     * const { count } = await prisma.audit_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends audit_logsDeleteManyArgs>(args?: SelectSubset<T, audit_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Audit_logs
     * const audit_logs = await prisma.audit_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends audit_logsUpdateManyArgs>(args: SelectSubset<T, audit_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audit_logs and returns the data updated in the database.
     * @param {audit_logsUpdateManyAndReturnArgs} args - Arguments to update many Audit_logs.
     * @example
     * // Update many Audit_logs
     * const audit_logs = await prisma.audit_logs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Audit_logs and only return the `id`
     * const audit_logsWithIdOnly = await prisma.audit_logs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends audit_logsUpdateManyAndReturnArgs>(args: SelectSubset<T, audit_logsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Audit_logs.
     * @param {audit_logsUpsertArgs} args - Arguments to update or create a Audit_logs.
     * @example
     * // Update or create a Audit_logs
     * const audit_logs = await prisma.audit_logs.upsert({
     *   create: {
     *     // ... data to create a Audit_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Audit_logs we want to update
     *   }
     * })
     */
    upsert<T extends audit_logsUpsertArgs>(args: SelectSubset<T, audit_logsUpsertArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsCountArgs} args - Arguments to filter Audit_logs to count.
     * @example
     * // Count the number of Audit_logs
     * const count = await prisma.audit_logs.count({
     *   where: {
     *     // ... the filter for the Audit_logs we want to count
     *   }
     * })
    **/
    count<T extends audit_logsCountArgs>(
      args?: Subset<T, audit_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Audit_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Audit_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Audit_logsAggregateArgs>(args: Subset<T, Audit_logsAggregateArgs>): Prisma.PrismaPromise<GetAudit_logsAggregateType<T>>

    /**
     * Group by Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends audit_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: audit_logsGroupByArgs['orderBy'] }
        : { orderBy?: audit_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, audit_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudit_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the audit_logs model
   */
  readonly fields: audit_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for audit_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__audit_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the audit_logs model
   */
  interface audit_logsFieldRefs {
    readonly id: FieldRef<"audit_logs", 'String'>
    readonly userId: FieldRef<"audit_logs", 'String'>
    readonly userName: FieldRef<"audit_logs", 'String'>
    readonly action: FieldRef<"audit_logs", 'String'>
    readonly description: FieldRef<"audit_logs", 'String'>
    readonly metadata: FieldRef<"audit_logs", 'Json'>
    readonly timestamp: FieldRef<"audit_logs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * audit_logs findUnique
   */
  export type audit_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs findUniqueOrThrow
   */
  export type audit_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs findFirst
   */
  export type audit_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audit_logs.
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audit_logs.
     */
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }

  /**
   * audit_logs findFirstOrThrow
   */
  export type audit_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audit_logs.
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audit_logs.
     */
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }

  /**
   * audit_logs findMany
   */
  export type audit_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing audit_logs.
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }

  /**
   * audit_logs create
   */
  export type audit_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * The data needed to create a audit_logs.
     */
    data: XOR<audit_logsCreateInput, audit_logsUncheckedCreateInput>
  }

  /**
   * audit_logs createMany
   */
  export type audit_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many audit_logs.
     */
    data: audit_logsCreateManyInput | audit_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * audit_logs createManyAndReturn
   */
  export type audit_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * The data used to create many audit_logs.
     */
    data: audit_logsCreateManyInput | audit_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * audit_logs update
   */
  export type audit_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * The data needed to update a audit_logs.
     */
    data: XOR<audit_logsUpdateInput, audit_logsUncheckedUpdateInput>
    /**
     * Choose, which audit_logs to update.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs updateMany
   */
  export type audit_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update audit_logs.
     */
    data: XOR<audit_logsUpdateManyMutationInput, audit_logsUncheckedUpdateManyInput>
    /**
     * Filter which audit_logs to update
     */
    where?: audit_logsWhereInput
    /**
     * Limit how many audit_logs to update.
     */
    limit?: number
  }

  /**
   * audit_logs updateManyAndReturn
   */
  export type audit_logsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * The data used to update audit_logs.
     */
    data: XOR<audit_logsUpdateManyMutationInput, audit_logsUncheckedUpdateManyInput>
    /**
     * Filter which audit_logs to update
     */
    where?: audit_logsWhereInput
    /**
     * Limit how many audit_logs to update.
     */
    limit?: number
  }

  /**
   * audit_logs upsert
   */
  export type audit_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * The filter to search for the audit_logs to update in case it exists.
     */
    where: audit_logsWhereUniqueInput
    /**
     * In case the audit_logs found by the `where` argument doesn't exist, create a new audit_logs with this data.
     */
    create: XOR<audit_logsCreateInput, audit_logsUncheckedCreateInput>
    /**
     * In case the audit_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<audit_logsUpdateInput, audit_logsUncheckedUpdateInput>
  }

  /**
   * audit_logs delete
   */
  export type audit_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Filter which audit_logs to delete.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs deleteMany
   */
  export type audit_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which audit_logs to delete
     */
    where?: audit_logsWhereInput
    /**
     * Limit how many audit_logs to delete.
     */
    limit?: number
  }

  /**
   * audit_logs without action
   */
  export type audit_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsersScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    role: 'role',
    department: 'department',
    initials: 'initials',
    phone: 'phone',
    dateOfBirth: 'dateOfBirth',
    isActive: 'isActive',
    isFirstLogin: 'isFirstLogin',
    approvalStatus: 'approvalStatus',
    lastLogin: 'lastLogin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const PatientsScalarFieldEnum: {
    id: 'id',
    hospitalNumber: 'hospitalNumber',
    ruhcCode: 'ruhcCode',
    matricNumber: 'matricNumber',
    firstName: 'firstName',
    lastName: 'lastName',
    middleName: 'middleName',
    title: 'title',
    dateOfBirth: 'dateOfBirth',
    gender: 'gender',
    bloodGroup: 'bloodGroup',
    genotype: 'genotype',
    phone: 'phone',
    email: 'email',
    address: 'address',
    city: 'city',
    state: 'state',
    lga: 'lga',
    nationality: 'nationality',
    religion: 'religion',
    occupation: 'occupation',
    maritalStatus: 'maritalStatus',
    nokName: 'nokName',
    nokRelationship: 'nokRelationship',
    nokPhone: 'nokPhone',
    nokAddress: 'nokAddress',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    emergencyContactRelationship: 'emergencyContactRelationship',
    insuranceNumber: 'insuranceNumber',
    insuranceProvider: 'insuranceProvider',
    allergies: 'allergies',
    chronicConditions: 'chronicConditions',
    currentMedications: 'currentMedications',
    currentUnit: 'currentUnit',
    bedNumber: 'bedNumber',
    admissionDate: 'admissionDate',
    dischargeDate: 'dischargeDate',
    isActive: 'isActive',
    registeredAt: 'registeredAt',
    registeredBy: 'registeredBy',
    lastEditedBy: 'lastEditedBy',
    lastEditedAt: 'lastEditedAt'
  };

  export type PatientsScalarFieldEnum = (typeof PatientsScalarFieldEnum)[keyof typeof PatientsScalarFieldEnum]


  export const ConsultationsScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    patient: 'patient',
    doctorId: 'doctorId',
    doctorName: 'doctorName',
    status: 'status',
    chiefComplaint: 'chiefComplaint',
    historyOfPresentIllness: 'historyOfPresentIllness',
    pastMedicalHistory: 'pastMedicalHistory',
    signsAndSymptoms: 'signsAndSymptoms',
    bloodPressureSystolic: 'bloodPressureSystolic',
    bloodPressureDiastolic: 'bloodPressureDiastolic',
    temperature: 'temperature',
    pulse: 'pulse',
    respiratoryRate: 'respiratoryRate',
    weight: 'weight',
    height: 'height',
    oxygenSaturation: 'oxygenSaturation',
    generalExamination: 'generalExamination',
    systemExamination: 'systemExamination',
    investigationsRequested: 'investigationsRequested',
    scanRequested: 'scanRequested',
    scanFindings: 'scanFindings',
    provisionalDiagnosis: 'provisionalDiagnosis',
    finalDiagnosis: 'finalDiagnosis',
    treatmentPlan: 'treatmentPlan',
    prescriptions: 'prescriptions',
    referralTo: 'referralTo',
    referralNotes: 'referralNotes',
    sendBackTo: 'sendBackTo',
    sendBackNotes: 'sendBackNotes',
    sentAt: 'sentAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConsultationsScalarFieldEnum = (typeof ConsultationsScalarFieldEnum)[keyof typeof ConsultationsScalarFieldEnum]


  export const Vital_signsScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    patient: 'patient',
    recordedBy: 'recordedBy',
    bloodPressureSystolic: 'bloodPressureSystolic',
    bloodPressureDiastolic: 'bloodPressureDiastolic',
    temperature: 'temperature',
    pulse: 'pulse',
    respiratoryRate: 'respiratoryRate',
    weight: 'weight',
    height: 'height',
    oxygenSaturation: 'oxygenSaturation',
    painScore: 'painScore',
    notes: 'notes',
    recordedAt: 'recordedAt'
  };

  export type Vital_signsScalarFieldEnum = (typeof Vital_signsScalarFieldEnum)[keyof typeof Vital_signsScalarFieldEnum]


  export const Lab_requestsScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    patient: 'patient',
    requestedBy: 'requestedBy',
    tests: 'tests',
    status: 'status',
    notes: 'notes',
    requestedAt: 'requestedAt',
    completedAt: 'completedAt'
  };

  export type Lab_requestsScalarFieldEnum = (typeof Lab_requestsScalarFieldEnum)[keyof typeof Lab_requestsScalarFieldEnum]


  export const Lab_resultsScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    patientId: 'patientId',
    patient: 'patient',
    testName: 'testName',
    result: 'result',
    notes: 'notes',
    performedBy: 'performedBy',
    createdAt: 'createdAt'
  };

  export type Lab_resultsScalarFieldEnum = (typeof Lab_resultsScalarFieldEnum)[keyof typeof Lab_resultsScalarFieldEnum]


  export const PrescriptionsScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    patient: 'patient',
    prescribedBy: 'prescribedBy',
    medications: 'medications',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    dispensedAt: 'dispensedAt'
  };

  export type PrescriptionsScalarFieldEnum = (typeof PrescriptionsScalarFieldEnum)[keyof typeof PrescriptionsScalarFieldEnum]


  export const Queue_entriesScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    patient: 'patient',
    unit: 'unit',
    status: 'status',
    priority: 'priority',
    notes: 'notes',
    checkedInAt: 'checkedInAt',
    seenAt: 'seenAt'
  };

  export type Queue_entriesScalarFieldEnum = (typeof Queue_entriesScalarFieldEnum)[keyof typeof Queue_entriesScalarFieldEnum]


  export const AppointmentsScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    patient: 'patient',
    doctorId: 'doctorId',
    doctorName: 'doctorName',
    type: 'type',
    reason: 'reason',
    appointmentDate: 'appointmentDate',
    startTime: 'startTime',
    endTime: 'endTime',
    status: 'status',
    notes: 'notes',
    initials: 'initials',
    createdAt: 'createdAt'
  };

  export type AppointmentsScalarFieldEnum = (typeof AppointmentsScalarFieldEnum)[keyof typeof AppointmentsScalarFieldEnum]


  export const AdmissionsScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    patient: 'patient',
    unit: 'unit',
    bedNumber: 'bedNumber',
    reason: 'reason',
    status: 'status',
    admittedAt: 'admittedAt',
    dischargedAt: 'dischargedAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdmissionsScalarFieldEnum = (typeof AdmissionsScalarFieldEnum)[keyof typeof AdmissionsScalarFieldEnum]


  export const DrugsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    dosageForm: 'dosageForm',
    strength: 'strength',
    unit: 'unit',
    price: 'price',
    quantityInStock: 'quantityInStock',
    reorderLevel: 'reorderLevel',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type DrugsScalarFieldEnum = (typeof DrugsScalarFieldEnum)[keyof typeof DrugsScalarFieldEnum]


  export const Lab_testsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    price: 'price',
    turnaroundTime: 'turnaroundTime',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type Lab_testsScalarFieldEnum = (typeof Lab_testsScalarFieldEnum)[keyof typeof Lab_testsScalarFieldEnum]


  export const AnnouncementsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    type: 'type',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type AnnouncementsScalarFieldEnum = (typeof AnnouncementsScalarFieldEnum)[keyof typeof AnnouncementsScalarFieldEnum]


  export const Voice_notesScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    patient: 'patient',
    recipientRole: 'recipientRole',
    transcription: 'transcription',
    audioUrl: 'audioUrl',
    initials: 'initials',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type Voice_notesScalarFieldEnum = (typeof Voice_notesScalarFieldEnum)[keyof typeof Voice_notesScalarFieldEnum]


  export const Medical_certificatesScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    patient: 'patient',
    type: 'type',
    diagnosis: 'diagnosis',
    daysOff: 'daysOff',
    startDate: 'startDate',
    endDate: 'endDate',
    notes: 'notes',
    issuedBy: 'issuedBy',
    createdAt: 'createdAt'
  };

  export type Medical_certificatesScalarFieldEnum = (typeof Medical_certificatesScalarFieldEnum)[keyof typeof Medical_certificatesScalarFieldEnum]


  export const Referral_lettersScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    patient: 'patient',
    referredTo: 'referredTo',
    reason: 'reason',
    diagnosis: 'diagnosis',
    notes: 'notes',
    issuedBy: 'issuedBy',
    createdAt: 'createdAt'
  };

  export type Referral_lettersScalarFieldEnum = (typeof Referral_lettersScalarFieldEnum)[keyof typeof Referral_lettersScalarFieldEnum]


  export const Discharge_summariesScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    patient: 'patient',
    admissionDate: 'admissionDate',
    dischargeDate: 'dischargeDate',
    diagnosis: 'diagnosis',
    treatment: 'treatment',
    medications: 'medications',
    followUp: 'followUp',
    notes: 'notes',
    dischargedBy: 'dischargedBy',
    createdAt: 'createdAt'
  };

  export type Discharge_summariesScalarFieldEnum = (typeof Discharge_summariesScalarFieldEnum)[keyof typeof Discharge_summariesScalarFieldEnum]


  export const Audit_logsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userName: 'userName',
    action: 'action',
    description: 'description',
    metadata: 'metadata',
    timestamp: 'timestamp'
  };

  export type Audit_logsScalarFieldEnum = (typeof Audit_logsScalarFieldEnum)[keyof typeof Audit_logsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    name?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    role?: StringFilter<"users"> | string
    department?: StringNullableFilter<"users"> | string | null
    initials?: StringNullableFilter<"users"> | string | null
    phone?: StringNullableFilter<"users"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"users"> | Date | string | null
    isActive?: BoolFilter<"users"> | boolean
    isFirstLogin?: BoolFilter<"users"> | boolean
    approvalStatus?: StringFilter<"users"> | string
    lastLogin?: DateTimeNullableFilter<"users"> | Date | string | null
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    department?: SortOrderInput | SortOrder
    initials?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isFirstLogin?: SortOrder
    approvalStatus?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    name?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    role?: StringFilter<"users"> | string
    department?: StringNullableFilter<"users"> | string | null
    initials?: StringNullableFilter<"users"> | string | null
    phone?: StringNullableFilter<"users"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"users"> | Date | string | null
    isActive?: BoolFilter<"users"> | boolean
    isFirstLogin?: BoolFilter<"users"> | boolean
    approvalStatus?: StringFilter<"users"> | string
    lastLogin?: DateTimeNullableFilter<"users"> | Date | string | null
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
  }, "id" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    department?: SortOrderInput | SortOrder
    initials?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isFirstLogin?: SortOrder
    approvalStatus?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    name?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    role?: StringWithAggregatesFilter<"users"> | string
    department?: StringNullableWithAggregatesFilter<"users"> | string | null
    initials?: StringNullableWithAggregatesFilter<"users"> | string | null
    phone?: StringNullableWithAggregatesFilter<"users"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"users"> | boolean
    isFirstLogin?: BoolWithAggregatesFilter<"users"> | boolean
    approvalStatus?: StringWithAggregatesFilter<"users"> | string
    lastLogin?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
  }

  export type patientsWhereInput = {
    AND?: patientsWhereInput | patientsWhereInput[]
    OR?: patientsWhereInput[]
    NOT?: patientsWhereInput | patientsWhereInput[]
    id?: StringFilter<"patients"> | string
    hospitalNumber?: StringNullableFilter<"patients"> | string | null
    ruhcCode?: StringFilter<"patients"> | string
    matricNumber?: StringNullableFilter<"patients"> | string | null
    firstName?: StringFilter<"patients"> | string
    lastName?: StringFilter<"patients"> | string
    middleName?: StringNullableFilter<"patients"> | string | null
    title?: StringNullableFilter<"patients"> | string | null
    dateOfBirth?: StringNullableFilter<"patients"> | string | null
    gender?: StringNullableFilter<"patients"> | string | null
    bloodGroup?: StringNullableFilter<"patients"> | string | null
    genotype?: StringNullableFilter<"patients"> | string | null
    phone?: StringNullableFilter<"patients"> | string | null
    email?: StringNullableFilter<"patients"> | string | null
    address?: StringNullableFilter<"patients"> | string | null
    city?: StringNullableFilter<"patients"> | string | null
    state?: StringNullableFilter<"patients"> | string | null
    lga?: StringNullableFilter<"patients"> | string | null
    nationality?: StringNullableFilter<"patients"> | string | null
    religion?: StringNullableFilter<"patients"> | string | null
    occupation?: StringNullableFilter<"patients"> | string | null
    maritalStatus?: StringNullableFilter<"patients"> | string | null
    nokName?: StringNullableFilter<"patients"> | string | null
    nokRelationship?: StringNullableFilter<"patients"> | string | null
    nokPhone?: StringNullableFilter<"patients"> | string | null
    nokAddress?: StringNullableFilter<"patients"> | string | null
    emergencyContactName?: StringNullableFilter<"patients"> | string | null
    emergencyContactPhone?: StringNullableFilter<"patients"> | string | null
    emergencyContactRelationship?: StringNullableFilter<"patients"> | string | null
    insuranceNumber?: StringNullableFilter<"patients"> | string | null
    insuranceProvider?: StringNullableFilter<"patients"> | string | null
    allergies?: StringNullableFilter<"patients"> | string | null
    chronicConditions?: StringNullableFilter<"patients"> | string | null
    currentMedications?: StringNullableFilter<"patients"> | string | null
    currentUnit?: StringNullableFilter<"patients"> | string | null
    bedNumber?: IntNullableFilter<"patients"> | number | null
    admissionDate?: DateTimeNullableFilter<"patients"> | Date | string | null
    dischargeDate?: DateTimeNullableFilter<"patients"> | Date | string | null
    isActive?: BoolFilter<"patients"> | boolean
    registeredAt?: DateTimeFilter<"patients"> | Date | string
    registeredBy?: StringNullableFilter<"patients"> | string | null
    lastEditedBy?: StringNullableFilter<"patients"> | string | null
    lastEditedAt?: DateTimeNullableFilter<"patients"> | Date | string | null
  }

  export type patientsOrderByWithRelationInput = {
    id?: SortOrder
    hospitalNumber?: SortOrderInput | SortOrder
    ruhcCode?: SortOrder
    matricNumber?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    bloodGroup?: SortOrderInput | SortOrder
    genotype?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    lga?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    religion?: SortOrderInput | SortOrder
    occupation?: SortOrderInput | SortOrder
    maritalStatus?: SortOrderInput | SortOrder
    nokName?: SortOrderInput | SortOrder
    nokRelationship?: SortOrderInput | SortOrder
    nokPhone?: SortOrderInput | SortOrder
    nokAddress?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    emergencyContactRelationship?: SortOrderInput | SortOrder
    insuranceNumber?: SortOrderInput | SortOrder
    insuranceProvider?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    chronicConditions?: SortOrderInput | SortOrder
    currentMedications?: SortOrderInput | SortOrder
    currentUnit?: SortOrderInput | SortOrder
    bedNumber?: SortOrderInput | SortOrder
    admissionDate?: SortOrderInput | SortOrder
    dischargeDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    registeredAt?: SortOrder
    registeredBy?: SortOrderInput | SortOrder
    lastEditedBy?: SortOrderInput | SortOrder
    lastEditedAt?: SortOrderInput | SortOrder
  }

  export type patientsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ruhcCode?: string
    AND?: patientsWhereInput | patientsWhereInput[]
    OR?: patientsWhereInput[]
    NOT?: patientsWhereInput | patientsWhereInput[]
    hospitalNumber?: StringNullableFilter<"patients"> | string | null
    matricNumber?: StringNullableFilter<"patients"> | string | null
    firstName?: StringFilter<"patients"> | string
    lastName?: StringFilter<"patients"> | string
    middleName?: StringNullableFilter<"patients"> | string | null
    title?: StringNullableFilter<"patients"> | string | null
    dateOfBirth?: StringNullableFilter<"patients"> | string | null
    gender?: StringNullableFilter<"patients"> | string | null
    bloodGroup?: StringNullableFilter<"patients"> | string | null
    genotype?: StringNullableFilter<"patients"> | string | null
    phone?: StringNullableFilter<"patients"> | string | null
    email?: StringNullableFilter<"patients"> | string | null
    address?: StringNullableFilter<"patients"> | string | null
    city?: StringNullableFilter<"patients"> | string | null
    state?: StringNullableFilter<"patients"> | string | null
    lga?: StringNullableFilter<"patients"> | string | null
    nationality?: StringNullableFilter<"patients"> | string | null
    religion?: StringNullableFilter<"patients"> | string | null
    occupation?: StringNullableFilter<"patients"> | string | null
    maritalStatus?: StringNullableFilter<"patients"> | string | null
    nokName?: StringNullableFilter<"patients"> | string | null
    nokRelationship?: StringNullableFilter<"patients"> | string | null
    nokPhone?: StringNullableFilter<"patients"> | string | null
    nokAddress?: StringNullableFilter<"patients"> | string | null
    emergencyContactName?: StringNullableFilter<"patients"> | string | null
    emergencyContactPhone?: StringNullableFilter<"patients"> | string | null
    emergencyContactRelationship?: StringNullableFilter<"patients"> | string | null
    insuranceNumber?: StringNullableFilter<"patients"> | string | null
    insuranceProvider?: StringNullableFilter<"patients"> | string | null
    allergies?: StringNullableFilter<"patients"> | string | null
    chronicConditions?: StringNullableFilter<"patients"> | string | null
    currentMedications?: StringNullableFilter<"patients"> | string | null
    currentUnit?: StringNullableFilter<"patients"> | string | null
    bedNumber?: IntNullableFilter<"patients"> | number | null
    admissionDate?: DateTimeNullableFilter<"patients"> | Date | string | null
    dischargeDate?: DateTimeNullableFilter<"patients"> | Date | string | null
    isActive?: BoolFilter<"patients"> | boolean
    registeredAt?: DateTimeFilter<"patients"> | Date | string
    registeredBy?: StringNullableFilter<"patients"> | string | null
    lastEditedBy?: StringNullableFilter<"patients"> | string | null
    lastEditedAt?: DateTimeNullableFilter<"patients"> | Date | string | null
  }, "id" | "ruhcCode">

  export type patientsOrderByWithAggregationInput = {
    id?: SortOrder
    hospitalNumber?: SortOrderInput | SortOrder
    ruhcCode?: SortOrder
    matricNumber?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    bloodGroup?: SortOrderInput | SortOrder
    genotype?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    lga?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    religion?: SortOrderInput | SortOrder
    occupation?: SortOrderInput | SortOrder
    maritalStatus?: SortOrderInput | SortOrder
    nokName?: SortOrderInput | SortOrder
    nokRelationship?: SortOrderInput | SortOrder
    nokPhone?: SortOrderInput | SortOrder
    nokAddress?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    emergencyContactRelationship?: SortOrderInput | SortOrder
    insuranceNumber?: SortOrderInput | SortOrder
    insuranceProvider?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    chronicConditions?: SortOrderInput | SortOrder
    currentMedications?: SortOrderInput | SortOrder
    currentUnit?: SortOrderInput | SortOrder
    bedNumber?: SortOrderInput | SortOrder
    admissionDate?: SortOrderInput | SortOrder
    dischargeDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    registeredAt?: SortOrder
    registeredBy?: SortOrderInput | SortOrder
    lastEditedBy?: SortOrderInput | SortOrder
    lastEditedAt?: SortOrderInput | SortOrder
    _count?: patientsCountOrderByAggregateInput
    _avg?: patientsAvgOrderByAggregateInput
    _max?: patientsMaxOrderByAggregateInput
    _min?: patientsMinOrderByAggregateInput
    _sum?: patientsSumOrderByAggregateInput
  }

  export type patientsScalarWhereWithAggregatesInput = {
    AND?: patientsScalarWhereWithAggregatesInput | patientsScalarWhereWithAggregatesInput[]
    OR?: patientsScalarWhereWithAggregatesInput[]
    NOT?: patientsScalarWhereWithAggregatesInput | patientsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"patients"> | string
    hospitalNumber?: StringNullableWithAggregatesFilter<"patients"> | string | null
    ruhcCode?: StringWithAggregatesFilter<"patients"> | string
    matricNumber?: StringNullableWithAggregatesFilter<"patients"> | string | null
    firstName?: StringWithAggregatesFilter<"patients"> | string
    lastName?: StringWithAggregatesFilter<"patients"> | string
    middleName?: StringNullableWithAggregatesFilter<"patients"> | string | null
    title?: StringNullableWithAggregatesFilter<"patients"> | string | null
    dateOfBirth?: StringNullableWithAggregatesFilter<"patients"> | string | null
    gender?: StringNullableWithAggregatesFilter<"patients"> | string | null
    bloodGroup?: StringNullableWithAggregatesFilter<"patients"> | string | null
    genotype?: StringNullableWithAggregatesFilter<"patients"> | string | null
    phone?: StringNullableWithAggregatesFilter<"patients"> | string | null
    email?: StringNullableWithAggregatesFilter<"patients"> | string | null
    address?: StringNullableWithAggregatesFilter<"patients"> | string | null
    city?: StringNullableWithAggregatesFilter<"patients"> | string | null
    state?: StringNullableWithAggregatesFilter<"patients"> | string | null
    lga?: StringNullableWithAggregatesFilter<"patients"> | string | null
    nationality?: StringNullableWithAggregatesFilter<"patients"> | string | null
    religion?: StringNullableWithAggregatesFilter<"patients"> | string | null
    occupation?: StringNullableWithAggregatesFilter<"patients"> | string | null
    maritalStatus?: StringNullableWithAggregatesFilter<"patients"> | string | null
    nokName?: StringNullableWithAggregatesFilter<"patients"> | string | null
    nokRelationship?: StringNullableWithAggregatesFilter<"patients"> | string | null
    nokPhone?: StringNullableWithAggregatesFilter<"patients"> | string | null
    nokAddress?: StringNullableWithAggregatesFilter<"patients"> | string | null
    emergencyContactName?: StringNullableWithAggregatesFilter<"patients"> | string | null
    emergencyContactPhone?: StringNullableWithAggregatesFilter<"patients"> | string | null
    emergencyContactRelationship?: StringNullableWithAggregatesFilter<"patients"> | string | null
    insuranceNumber?: StringNullableWithAggregatesFilter<"patients"> | string | null
    insuranceProvider?: StringNullableWithAggregatesFilter<"patients"> | string | null
    allergies?: StringNullableWithAggregatesFilter<"patients"> | string | null
    chronicConditions?: StringNullableWithAggregatesFilter<"patients"> | string | null
    currentMedications?: StringNullableWithAggregatesFilter<"patients"> | string | null
    currentUnit?: StringNullableWithAggregatesFilter<"patients"> | string | null
    bedNumber?: IntNullableWithAggregatesFilter<"patients"> | number | null
    admissionDate?: DateTimeNullableWithAggregatesFilter<"patients"> | Date | string | null
    dischargeDate?: DateTimeNullableWithAggregatesFilter<"patients"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"patients"> | boolean
    registeredAt?: DateTimeWithAggregatesFilter<"patients"> | Date | string
    registeredBy?: StringNullableWithAggregatesFilter<"patients"> | string | null
    lastEditedBy?: StringNullableWithAggregatesFilter<"patients"> | string | null
    lastEditedAt?: DateTimeNullableWithAggregatesFilter<"patients"> | Date | string | null
  }

  export type consultationsWhereInput = {
    AND?: consultationsWhereInput | consultationsWhereInput[]
    OR?: consultationsWhereInput[]
    NOT?: consultationsWhereInput | consultationsWhereInput[]
    id?: StringFilter<"consultations"> | string
    patientId?: StringNullableFilter<"consultations"> | string | null
    patient?: JsonNullableFilter<"consultations">
    doctorId?: StringNullableFilter<"consultations"> | string | null
    doctorName?: StringNullableFilter<"consultations"> | string | null
    status?: StringFilter<"consultations"> | string
    chiefComplaint?: StringNullableFilter<"consultations"> | string | null
    historyOfPresentIllness?: StringNullableFilter<"consultations"> | string | null
    pastMedicalHistory?: StringNullableFilter<"consultations"> | string | null
    signsAndSymptoms?: StringNullableFilter<"consultations"> | string | null
    bloodPressureSystolic?: StringNullableFilter<"consultations"> | string | null
    bloodPressureDiastolic?: StringNullableFilter<"consultations"> | string | null
    temperature?: StringNullableFilter<"consultations"> | string | null
    pulse?: StringNullableFilter<"consultations"> | string | null
    respiratoryRate?: StringNullableFilter<"consultations"> | string | null
    weight?: StringNullableFilter<"consultations"> | string | null
    height?: StringNullableFilter<"consultations"> | string | null
    oxygenSaturation?: StringNullableFilter<"consultations"> | string | null
    generalExamination?: StringNullableFilter<"consultations"> | string | null
    systemExamination?: StringNullableFilter<"consultations"> | string | null
    investigationsRequested?: JsonNullableFilter<"consultations">
    scanRequested?: JsonNullableFilter<"consultations">
    scanFindings?: StringNullableFilter<"consultations"> | string | null
    provisionalDiagnosis?: StringNullableFilter<"consultations"> | string | null
    finalDiagnosis?: StringNullableFilter<"consultations"> | string | null
    treatmentPlan?: StringNullableFilter<"consultations"> | string | null
    prescriptions?: JsonNullableFilter<"consultations">
    referralTo?: StringNullableFilter<"consultations"> | string | null
    referralNotes?: StringNullableFilter<"consultations"> | string | null
    sendBackTo?: JsonNullableFilter<"consultations">
    sendBackNotes?: StringNullableFilter<"consultations"> | string | null
    sentAt?: DateTimeNullableFilter<"consultations"> | Date | string | null
    createdAt?: DateTimeFilter<"consultations"> | Date | string
    updatedAt?: DateTimeFilter<"consultations"> | Date | string
  }

  export type consultationsOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    doctorName?: SortOrderInput | SortOrder
    status?: SortOrder
    chiefComplaint?: SortOrderInput | SortOrder
    historyOfPresentIllness?: SortOrderInput | SortOrder
    pastMedicalHistory?: SortOrderInput | SortOrder
    signsAndSymptoms?: SortOrderInput | SortOrder
    bloodPressureSystolic?: SortOrderInput | SortOrder
    bloodPressureDiastolic?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    pulse?: SortOrderInput | SortOrder
    respiratoryRate?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    oxygenSaturation?: SortOrderInput | SortOrder
    generalExamination?: SortOrderInput | SortOrder
    systemExamination?: SortOrderInput | SortOrder
    investigationsRequested?: SortOrderInput | SortOrder
    scanRequested?: SortOrderInput | SortOrder
    scanFindings?: SortOrderInput | SortOrder
    provisionalDiagnosis?: SortOrderInput | SortOrder
    finalDiagnosis?: SortOrderInput | SortOrder
    treatmentPlan?: SortOrderInput | SortOrder
    prescriptions?: SortOrderInput | SortOrder
    referralTo?: SortOrderInput | SortOrder
    referralNotes?: SortOrderInput | SortOrder
    sendBackTo?: SortOrderInput | SortOrder
    sendBackNotes?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type consultationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: consultationsWhereInput | consultationsWhereInput[]
    OR?: consultationsWhereInput[]
    NOT?: consultationsWhereInput | consultationsWhereInput[]
    patientId?: StringNullableFilter<"consultations"> | string | null
    patient?: JsonNullableFilter<"consultations">
    doctorId?: StringNullableFilter<"consultations"> | string | null
    doctorName?: StringNullableFilter<"consultations"> | string | null
    status?: StringFilter<"consultations"> | string
    chiefComplaint?: StringNullableFilter<"consultations"> | string | null
    historyOfPresentIllness?: StringNullableFilter<"consultations"> | string | null
    pastMedicalHistory?: StringNullableFilter<"consultations"> | string | null
    signsAndSymptoms?: StringNullableFilter<"consultations"> | string | null
    bloodPressureSystolic?: StringNullableFilter<"consultations"> | string | null
    bloodPressureDiastolic?: StringNullableFilter<"consultations"> | string | null
    temperature?: StringNullableFilter<"consultations"> | string | null
    pulse?: StringNullableFilter<"consultations"> | string | null
    respiratoryRate?: StringNullableFilter<"consultations"> | string | null
    weight?: StringNullableFilter<"consultations"> | string | null
    height?: StringNullableFilter<"consultations"> | string | null
    oxygenSaturation?: StringNullableFilter<"consultations"> | string | null
    generalExamination?: StringNullableFilter<"consultations"> | string | null
    systemExamination?: StringNullableFilter<"consultations"> | string | null
    investigationsRequested?: JsonNullableFilter<"consultations">
    scanRequested?: JsonNullableFilter<"consultations">
    scanFindings?: StringNullableFilter<"consultations"> | string | null
    provisionalDiagnosis?: StringNullableFilter<"consultations"> | string | null
    finalDiagnosis?: StringNullableFilter<"consultations"> | string | null
    treatmentPlan?: StringNullableFilter<"consultations"> | string | null
    prescriptions?: JsonNullableFilter<"consultations">
    referralTo?: StringNullableFilter<"consultations"> | string | null
    referralNotes?: StringNullableFilter<"consultations"> | string | null
    sendBackTo?: JsonNullableFilter<"consultations">
    sendBackNotes?: StringNullableFilter<"consultations"> | string | null
    sentAt?: DateTimeNullableFilter<"consultations"> | Date | string | null
    createdAt?: DateTimeFilter<"consultations"> | Date | string
    updatedAt?: DateTimeFilter<"consultations"> | Date | string
  }, "id">

  export type consultationsOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    doctorName?: SortOrderInput | SortOrder
    status?: SortOrder
    chiefComplaint?: SortOrderInput | SortOrder
    historyOfPresentIllness?: SortOrderInput | SortOrder
    pastMedicalHistory?: SortOrderInput | SortOrder
    signsAndSymptoms?: SortOrderInput | SortOrder
    bloodPressureSystolic?: SortOrderInput | SortOrder
    bloodPressureDiastolic?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    pulse?: SortOrderInput | SortOrder
    respiratoryRate?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    oxygenSaturation?: SortOrderInput | SortOrder
    generalExamination?: SortOrderInput | SortOrder
    systemExamination?: SortOrderInput | SortOrder
    investigationsRequested?: SortOrderInput | SortOrder
    scanRequested?: SortOrderInput | SortOrder
    scanFindings?: SortOrderInput | SortOrder
    provisionalDiagnosis?: SortOrderInput | SortOrder
    finalDiagnosis?: SortOrderInput | SortOrder
    treatmentPlan?: SortOrderInput | SortOrder
    prescriptions?: SortOrderInput | SortOrder
    referralTo?: SortOrderInput | SortOrder
    referralNotes?: SortOrderInput | SortOrder
    sendBackTo?: SortOrderInput | SortOrder
    sendBackNotes?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: consultationsCountOrderByAggregateInput
    _max?: consultationsMaxOrderByAggregateInput
    _min?: consultationsMinOrderByAggregateInput
  }

  export type consultationsScalarWhereWithAggregatesInput = {
    AND?: consultationsScalarWhereWithAggregatesInput | consultationsScalarWhereWithAggregatesInput[]
    OR?: consultationsScalarWhereWithAggregatesInput[]
    NOT?: consultationsScalarWhereWithAggregatesInput | consultationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"consultations"> | string
    patientId?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    patient?: JsonNullableWithAggregatesFilter<"consultations">
    doctorId?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    doctorName?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    status?: StringWithAggregatesFilter<"consultations"> | string
    chiefComplaint?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    historyOfPresentIllness?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    pastMedicalHistory?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    signsAndSymptoms?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    bloodPressureSystolic?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    bloodPressureDiastolic?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    temperature?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    pulse?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    respiratoryRate?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    weight?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    height?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    oxygenSaturation?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    generalExamination?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    systemExamination?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    investigationsRequested?: JsonNullableWithAggregatesFilter<"consultations">
    scanRequested?: JsonNullableWithAggregatesFilter<"consultations">
    scanFindings?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    provisionalDiagnosis?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    finalDiagnosis?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    treatmentPlan?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    prescriptions?: JsonNullableWithAggregatesFilter<"consultations">
    referralTo?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    referralNotes?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    sendBackTo?: JsonNullableWithAggregatesFilter<"consultations">
    sendBackNotes?: StringNullableWithAggregatesFilter<"consultations"> | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"consultations"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"consultations"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"consultations"> | Date | string
  }

  export type vital_signsWhereInput = {
    AND?: vital_signsWhereInput | vital_signsWhereInput[]
    OR?: vital_signsWhereInput[]
    NOT?: vital_signsWhereInput | vital_signsWhereInput[]
    id?: StringFilter<"vital_signs"> | string
    patientId?: StringNullableFilter<"vital_signs"> | string | null
    patient?: JsonNullableFilter<"vital_signs">
    recordedBy?: StringNullableFilter<"vital_signs"> | string | null
    bloodPressureSystolic?: StringNullableFilter<"vital_signs"> | string | null
    bloodPressureDiastolic?: StringNullableFilter<"vital_signs"> | string | null
    temperature?: StringNullableFilter<"vital_signs"> | string | null
    pulse?: StringNullableFilter<"vital_signs"> | string | null
    respiratoryRate?: StringNullableFilter<"vital_signs"> | string | null
    weight?: StringNullableFilter<"vital_signs"> | string | null
    height?: StringNullableFilter<"vital_signs"> | string | null
    oxygenSaturation?: StringNullableFilter<"vital_signs"> | string | null
    painScore?: StringNullableFilter<"vital_signs"> | string | null
    notes?: StringNullableFilter<"vital_signs"> | string | null
    recordedAt?: DateTimeFilter<"vital_signs"> | Date | string
  }

  export type vital_signsOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    recordedBy?: SortOrderInput | SortOrder
    bloodPressureSystolic?: SortOrderInput | SortOrder
    bloodPressureDiastolic?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    pulse?: SortOrderInput | SortOrder
    respiratoryRate?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    oxygenSaturation?: SortOrderInput | SortOrder
    painScore?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
  }

  export type vital_signsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: vital_signsWhereInput | vital_signsWhereInput[]
    OR?: vital_signsWhereInput[]
    NOT?: vital_signsWhereInput | vital_signsWhereInput[]
    patientId?: StringNullableFilter<"vital_signs"> | string | null
    patient?: JsonNullableFilter<"vital_signs">
    recordedBy?: StringNullableFilter<"vital_signs"> | string | null
    bloodPressureSystolic?: StringNullableFilter<"vital_signs"> | string | null
    bloodPressureDiastolic?: StringNullableFilter<"vital_signs"> | string | null
    temperature?: StringNullableFilter<"vital_signs"> | string | null
    pulse?: StringNullableFilter<"vital_signs"> | string | null
    respiratoryRate?: StringNullableFilter<"vital_signs"> | string | null
    weight?: StringNullableFilter<"vital_signs"> | string | null
    height?: StringNullableFilter<"vital_signs"> | string | null
    oxygenSaturation?: StringNullableFilter<"vital_signs"> | string | null
    painScore?: StringNullableFilter<"vital_signs"> | string | null
    notes?: StringNullableFilter<"vital_signs"> | string | null
    recordedAt?: DateTimeFilter<"vital_signs"> | Date | string
  }, "id">

  export type vital_signsOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    recordedBy?: SortOrderInput | SortOrder
    bloodPressureSystolic?: SortOrderInput | SortOrder
    bloodPressureDiastolic?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    pulse?: SortOrderInput | SortOrder
    respiratoryRate?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    oxygenSaturation?: SortOrderInput | SortOrder
    painScore?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    _count?: vital_signsCountOrderByAggregateInput
    _max?: vital_signsMaxOrderByAggregateInput
    _min?: vital_signsMinOrderByAggregateInput
  }

  export type vital_signsScalarWhereWithAggregatesInput = {
    AND?: vital_signsScalarWhereWithAggregatesInput | vital_signsScalarWhereWithAggregatesInput[]
    OR?: vital_signsScalarWhereWithAggregatesInput[]
    NOT?: vital_signsScalarWhereWithAggregatesInput | vital_signsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"vital_signs"> | string
    patientId?: StringNullableWithAggregatesFilter<"vital_signs"> | string | null
    patient?: JsonNullableWithAggregatesFilter<"vital_signs">
    recordedBy?: StringNullableWithAggregatesFilter<"vital_signs"> | string | null
    bloodPressureSystolic?: StringNullableWithAggregatesFilter<"vital_signs"> | string | null
    bloodPressureDiastolic?: StringNullableWithAggregatesFilter<"vital_signs"> | string | null
    temperature?: StringNullableWithAggregatesFilter<"vital_signs"> | string | null
    pulse?: StringNullableWithAggregatesFilter<"vital_signs"> | string | null
    respiratoryRate?: StringNullableWithAggregatesFilter<"vital_signs"> | string | null
    weight?: StringNullableWithAggregatesFilter<"vital_signs"> | string | null
    height?: StringNullableWithAggregatesFilter<"vital_signs"> | string | null
    oxygenSaturation?: StringNullableWithAggregatesFilter<"vital_signs"> | string | null
    painScore?: StringNullableWithAggregatesFilter<"vital_signs"> | string | null
    notes?: StringNullableWithAggregatesFilter<"vital_signs"> | string | null
    recordedAt?: DateTimeWithAggregatesFilter<"vital_signs"> | Date | string
  }

  export type lab_requestsWhereInput = {
    AND?: lab_requestsWhereInput | lab_requestsWhereInput[]
    OR?: lab_requestsWhereInput[]
    NOT?: lab_requestsWhereInput | lab_requestsWhereInput[]
    id?: StringFilter<"lab_requests"> | string
    patientId?: StringNullableFilter<"lab_requests"> | string | null
    patient?: JsonNullableFilter<"lab_requests">
    requestedBy?: StringNullableFilter<"lab_requests"> | string | null
    tests?: JsonNullableFilter<"lab_requests">
    status?: StringFilter<"lab_requests"> | string
    notes?: StringNullableFilter<"lab_requests"> | string | null
    requestedAt?: DateTimeFilter<"lab_requests"> | Date | string
    completedAt?: DateTimeNullableFilter<"lab_requests"> | Date | string | null
  }

  export type lab_requestsOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    requestedBy?: SortOrderInput | SortOrder
    tests?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
  }

  export type lab_requestsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: lab_requestsWhereInput | lab_requestsWhereInput[]
    OR?: lab_requestsWhereInput[]
    NOT?: lab_requestsWhereInput | lab_requestsWhereInput[]
    patientId?: StringNullableFilter<"lab_requests"> | string | null
    patient?: JsonNullableFilter<"lab_requests">
    requestedBy?: StringNullableFilter<"lab_requests"> | string | null
    tests?: JsonNullableFilter<"lab_requests">
    status?: StringFilter<"lab_requests"> | string
    notes?: StringNullableFilter<"lab_requests"> | string | null
    requestedAt?: DateTimeFilter<"lab_requests"> | Date | string
    completedAt?: DateTimeNullableFilter<"lab_requests"> | Date | string | null
  }, "id">

  export type lab_requestsOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    requestedBy?: SortOrderInput | SortOrder
    tests?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: lab_requestsCountOrderByAggregateInput
    _max?: lab_requestsMaxOrderByAggregateInput
    _min?: lab_requestsMinOrderByAggregateInput
  }

  export type lab_requestsScalarWhereWithAggregatesInput = {
    AND?: lab_requestsScalarWhereWithAggregatesInput | lab_requestsScalarWhereWithAggregatesInput[]
    OR?: lab_requestsScalarWhereWithAggregatesInput[]
    NOT?: lab_requestsScalarWhereWithAggregatesInput | lab_requestsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"lab_requests"> | string
    patientId?: StringNullableWithAggregatesFilter<"lab_requests"> | string | null
    patient?: JsonNullableWithAggregatesFilter<"lab_requests">
    requestedBy?: StringNullableWithAggregatesFilter<"lab_requests"> | string | null
    tests?: JsonNullableWithAggregatesFilter<"lab_requests">
    status?: StringWithAggregatesFilter<"lab_requests"> | string
    notes?: StringNullableWithAggregatesFilter<"lab_requests"> | string | null
    requestedAt?: DateTimeWithAggregatesFilter<"lab_requests"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"lab_requests"> | Date | string | null
  }

  export type lab_resultsWhereInput = {
    AND?: lab_resultsWhereInput | lab_resultsWhereInput[]
    OR?: lab_resultsWhereInput[]
    NOT?: lab_resultsWhereInput | lab_resultsWhereInput[]
    id?: StringFilter<"lab_results"> | string
    requestId?: StringNullableFilter<"lab_results"> | string | null
    patientId?: StringNullableFilter<"lab_results"> | string | null
    patient?: JsonNullableFilter<"lab_results">
    testName?: StringNullableFilter<"lab_results"> | string | null
    result?: StringNullableFilter<"lab_results"> | string | null
    notes?: StringNullableFilter<"lab_results"> | string | null
    performedBy?: StringNullableFilter<"lab_results"> | string | null
    createdAt?: DateTimeFilter<"lab_results"> | Date | string
  }

  export type lab_resultsOrderByWithRelationInput = {
    id?: SortOrder
    requestId?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    testName?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type lab_resultsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: lab_resultsWhereInput | lab_resultsWhereInput[]
    OR?: lab_resultsWhereInput[]
    NOT?: lab_resultsWhereInput | lab_resultsWhereInput[]
    requestId?: StringNullableFilter<"lab_results"> | string | null
    patientId?: StringNullableFilter<"lab_results"> | string | null
    patient?: JsonNullableFilter<"lab_results">
    testName?: StringNullableFilter<"lab_results"> | string | null
    result?: StringNullableFilter<"lab_results"> | string | null
    notes?: StringNullableFilter<"lab_results"> | string | null
    performedBy?: StringNullableFilter<"lab_results"> | string | null
    createdAt?: DateTimeFilter<"lab_results"> | Date | string
  }, "id">

  export type lab_resultsOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    testName?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: lab_resultsCountOrderByAggregateInput
    _max?: lab_resultsMaxOrderByAggregateInput
    _min?: lab_resultsMinOrderByAggregateInput
  }

  export type lab_resultsScalarWhereWithAggregatesInput = {
    AND?: lab_resultsScalarWhereWithAggregatesInput | lab_resultsScalarWhereWithAggregatesInput[]
    OR?: lab_resultsScalarWhereWithAggregatesInput[]
    NOT?: lab_resultsScalarWhereWithAggregatesInput | lab_resultsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"lab_results"> | string
    requestId?: StringNullableWithAggregatesFilter<"lab_results"> | string | null
    patientId?: StringNullableWithAggregatesFilter<"lab_results"> | string | null
    patient?: JsonNullableWithAggregatesFilter<"lab_results">
    testName?: StringNullableWithAggregatesFilter<"lab_results"> | string | null
    result?: StringNullableWithAggregatesFilter<"lab_results"> | string | null
    notes?: StringNullableWithAggregatesFilter<"lab_results"> | string | null
    performedBy?: StringNullableWithAggregatesFilter<"lab_results"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"lab_results"> | Date | string
  }

  export type prescriptionsWhereInput = {
    AND?: prescriptionsWhereInput | prescriptionsWhereInput[]
    OR?: prescriptionsWhereInput[]
    NOT?: prescriptionsWhereInput | prescriptionsWhereInput[]
    id?: StringFilter<"prescriptions"> | string
    patientId?: StringNullableFilter<"prescriptions"> | string | null
    patient?: JsonNullableFilter<"prescriptions">
    prescribedBy?: StringNullableFilter<"prescriptions"> | string | null
    medications?: JsonNullableFilter<"prescriptions">
    status?: StringFilter<"prescriptions"> | string
    notes?: StringNullableFilter<"prescriptions"> | string | null
    createdAt?: DateTimeFilter<"prescriptions"> | Date | string
    dispensedAt?: DateTimeNullableFilter<"prescriptions"> | Date | string | null
  }

  export type prescriptionsOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    prescribedBy?: SortOrderInput | SortOrder
    medications?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    dispensedAt?: SortOrderInput | SortOrder
  }

  export type prescriptionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: prescriptionsWhereInput | prescriptionsWhereInput[]
    OR?: prescriptionsWhereInput[]
    NOT?: prescriptionsWhereInput | prescriptionsWhereInput[]
    patientId?: StringNullableFilter<"prescriptions"> | string | null
    patient?: JsonNullableFilter<"prescriptions">
    prescribedBy?: StringNullableFilter<"prescriptions"> | string | null
    medications?: JsonNullableFilter<"prescriptions">
    status?: StringFilter<"prescriptions"> | string
    notes?: StringNullableFilter<"prescriptions"> | string | null
    createdAt?: DateTimeFilter<"prescriptions"> | Date | string
    dispensedAt?: DateTimeNullableFilter<"prescriptions"> | Date | string | null
  }, "id">

  export type prescriptionsOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    prescribedBy?: SortOrderInput | SortOrder
    medications?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    dispensedAt?: SortOrderInput | SortOrder
    _count?: prescriptionsCountOrderByAggregateInput
    _max?: prescriptionsMaxOrderByAggregateInput
    _min?: prescriptionsMinOrderByAggregateInput
  }

  export type prescriptionsScalarWhereWithAggregatesInput = {
    AND?: prescriptionsScalarWhereWithAggregatesInput | prescriptionsScalarWhereWithAggregatesInput[]
    OR?: prescriptionsScalarWhereWithAggregatesInput[]
    NOT?: prescriptionsScalarWhereWithAggregatesInput | prescriptionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"prescriptions"> | string
    patientId?: StringNullableWithAggregatesFilter<"prescriptions"> | string | null
    patient?: JsonNullableWithAggregatesFilter<"prescriptions">
    prescribedBy?: StringNullableWithAggregatesFilter<"prescriptions"> | string | null
    medications?: JsonNullableWithAggregatesFilter<"prescriptions">
    status?: StringWithAggregatesFilter<"prescriptions"> | string
    notes?: StringNullableWithAggregatesFilter<"prescriptions"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"prescriptions"> | Date | string
    dispensedAt?: DateTimeNullableWithAggregatesFilter<"prescriptions"> | Date | string | null
  }

  export type queue_entriesWhereInput = {
    AND?: queue_entriesWhereInput | queue_entriesWhereInput[]
    OR?: queue_entriesWhereInput[]
    NOT?: queue_entriesWhereInput | queue_entriesWhereInput[]
    id?: StringFilter<"queue_entries"> | string
    patientId?: StringNullableFilter<"queue_entries"> | string | null
    patient?: JsonNullableFilter<"queue_entries">
    unit?: StringNullableFilter<"queue_entries"> | string | null
    status?: StringFilter<"queue_entries"> | string
    priority?: IntFilter<"queue_entries"> | number
    notes?: StringNullableFilter<"queue_entries"> | string | null
    checkedInAt?: DateTimeFilter<"queue_entries"> | Date | string
    seenAt?: DateTimeNullableFilter<"queue_entries"> | Date | string | null
  }

  export type queue_entriesOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    notes?: SortOrderInput | SortOrder
    checkedInAt?: SortOrder
    seenAt?: SortOrderInput | SortOrder
  }

  export type queue_entriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: queue_entriesWhereInput | queue_entriesWhereInput[]
    OR?: queue_entriesWhereInput[]
    NOT?: queue_entriesWhereInput | queue_entriesWhereInput[]
    patientId?: StringNullableFilter<"queue_entries"> | string | null
    patient?: JsonNullableFilter<"queue_entries">
    unit?: StringNullableFilter<"queue_entries"> | string | null
    status?: StringFilter<"queue_entries"> | string
    priority?: IntFilter<"queue_entries"> | number
    notes?: StringNullableFilter<"queue_entries"> | string | null
    checkedInAt?: DateTimeFilter<"queue_entries"> | Date | string
    seenAt?: DateTimeNullableFilter<"queue_entries"> | Date | string | null
  }, "id">

  export type queue_entriesOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    notes?: SortOrderInput | SortOrder
    checkedInAt?: SortOrder
    seenAt?: SortOrderInput | SortOrder
    _count?: queue_entriesCountOrderByAggregateInput
    _avg?: queue_entriesAvgOrderByAggregateInput
    _max?: queue_entriesMaxOrderByAggregateInput
    _min?: queue_entriesMinOrderByAggregateInput
    _sum?: queue_entriesSumOrderByAggregateInput
  }

  export type queue_entriesScalarWhereWithAggregatesInput = {
    AND?: queue_entriesScalarWhereWithAggregatesInput | queue_entriesScalarWhereWithAggregatesInput[]
    OR?: queue_entriesScalarWhereWithAggregatesInput[]
    NOT?: queue_entriesScalarWhereWithAggregatesInput | queue_entriesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"queue_entries"> | string
    patientId?: StringNullableWithAggregatesFilter<"queue_entries"> | string | null
    patient?: JsonNullableWithAggregatesFilter<"queue_entries">
    unit?: StringNullableWithAggregatesFilter<"queue_entries"> | string | null
    status?: StringWithAggregatesFilter<"queue_entries"> | string
    priority?: IntWithAggregatesFilter<"queue_entries"> | number
    notes?: StringNullableWithAggregatesFilter<"queue_entries"> | string | null
    checkedInAt?: DateTimeWithAggregatesFilter<"queue_entries"> | Date | string
    seenAt?: DateTimeNullableWithAggregatesFilter<"queue_entries"> | Date | string | null
  }

  export type appointmentsWhereInput = {
    AND?: appointmentsWhereInput | appointmentsWhereInput[]
    OR?: appointmentsWhereInput[]
    NOT?: appointmentsWhereInput | appointmentsWhereInput[]
    id?: StringFilter<"appointments"> | string
    patientId?: StringNullableFilter<"appointments"> | string | null
    patient?: JsonNullableFilter<"appointments">
    doctorId?: StringNullableFilter<"appointments"> | string | null
    doctorName?: StringNullableFilter<"appointments"> | string | null
    type?: StringNullableFilter<"appointments"> | string | null
    reason?: StringNullableFilter<"appointments"> | string | null
    appointmentDate?: StringNullableFilter<"appointments"> | string | null
    startTime?: StringNullableFilter<"appointments"> | string | null
    endTime?: StringNullableFilter<"appointments"> | string | null
    status?: StringFilter<"appointments"> | string
    notes?: StringNullableFilter<"appointments"> | string | null
    initials?: StringNullableFilter<"appointments"> | string | null
    createdAt?: DateTimeFilter<"appointments"> | Date | string
  }

  export type appointmentsOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    doctorName?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    appointmentDate?: SortOrderInput | SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    initials?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type appointmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: appointmentsWhereInput | appointmentsWhereInput[]
    OR?: appointmentsWhereInput[]
    NOT?: appointmentsWhereInput | appointmentsWhereInput[]
    patientId?: StringNullableFilter<"appointments"> | string | null
    patient?: JsonNullableFilter<"appointments">
    doctorId?: StringNullableFilter<"appointments"> | string | null
    doctorName?: StringNullableFilter<"appointments"> | string | null
    type?: StringNullableFilter<"appointments"> | string | null
    reason?: StringNullableFilter<"appointments"> | string | null
    appointmentDate?: StringNullableFilter<"appointments"> | string | null
    startTime?: StringNullableFilter<"appointments"> | string | null
    endTime?: StringNullableFilter<"appointments"> | string | null
    status?: StringFilter<"appointments"> | string
    notes?: StringNullableFilter<"appointments"> | string | null
    initials?: StringNullableFilter<"appointments"> | string | null
    createdAt?: DateTimeFilter<"appointments"> | Date | string
  }, "id">

  export type appointmentsOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    doctorName?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    appointmentDate?: SortOrderInput | SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    initials?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: appointmentsCountOrderByAggregateInput
    _max?: appointmentsMaxOrderByAggregateInput
    _min?: appointmentsMinOrderByAggregateInput
  }

  export type appointmentsScalarWhereWithAggregatesInput = {
    AND?: appointmentsScalarWhereWithAggregatesInput | appointmentsScalarWhereWithAggregatesInput[]
    OR?: appointmentsScalarWhereWithAggregatesInput[]
    NOT?: appointmentsScalarWhereWithAggregatesInput | appointmentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"appointments"> | string
    patientId?: StringNullableWithAggregatesFilter<"appointments"> | string | null
    patient?: JsonNullableWithAggregatesFilter<"appointments">
    doctorId?: StringNullableWithAggregatesFilter<"appointments"> | string | null
    doctorName?: StringNullableWithAggregatesFilter<"appointments"> | string | null
    type?: StringNullableWithAggregatesFilter<"appointments"> | string | null
    reason?: StringNullableWithAggregatesFilter<"appointments"> | string | null
    appointmentDate?: StringNullableWithAggregatesFilter<"appointments"> | string | null
    startTime?: StringNullableWithAggregatesFilter<"appointments"> | string | null
    endTime?: StringNullableWithAggregatesFilter<"appointments"> | string | null
    status?: StringWithAggregatesFilter<"appointments"> | string
    notes?: StringNullableWithAggregatesFilter<"appointments"> | string | null
    initials?: StringNullableWithAggregatesFilter<"appointments"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"appointments"> | Date | string
  }

  export type admissionsWhereInput = {
    AND?: admissionsWhereInput | admissionsWhereInput[]
    OR?: admissionsWhereInput[]
    NOT?: admissionsWhereInput | admissionsWhereInput[]
    id?: StringFilter<"admissions"> | string
    patientId?: StringNullableFilter<"admissions"> | string | null
    patient?: JsonNullableFilter<"admissions">
    unit?: StringNullableFilter<"admissions"> | string | null
    bedNumber?: IntNullableFilter<"admissions"> | number | null
    reason?: StringNullableFilter<"admissions"> | string | null
    status?: StringFilter<"admissions"> | string
    admittedAt?: DateTimeFilter<"admissions"> | Date | string
    dischargedAt?: DateTimeNullableFilter<"admissions"> | Date | string | null
    notes?: StringNullableFilter<"admissions"> | string | null
    createdAt?: DateTimeFilter<"admissions"> | Date | string
    updatedAt?: DateTimeFilter<"admissions"> | Date | string
  }

  export type admissionsOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    bedNumber?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    admittedAt?: SortOrder
    dischargedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type admissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: admissionsWhereInput | admissionsWhereInput[]
    OR?: admissionsWhereInput[]
    NOT?: admissionsWhereInput | admissionsWhereInput[]
    patientId?: StringNullableFilter<"admissions"> | string | null
    patient?: JsonNullableFilter<"admissions">
    unit?: StringNullableFilter<"admissions"> | string | null
    bedNumber?: IntNullableFilter<"admissions"> | number | null
    reason?: StringNullableFilter<"admissions"> | string | null
    status?: StringFilter<"admissions"> | string
    admittedAt?: DateTimeFilter<"admissions"> | Date | string
    dischargedAt?: DateTimeNullableFilter<"admissions"> | Date | string | null
    notes?: StringNullableFilter<"admissions"> | string | null
    createdAt?: DateTimeFilter<"admissions"> | Date | string
    updatedAt?: DateTimeFilter<"admissions"> | Date | string
  }, "id">

  export type admissionsOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    bedNumber?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    admittedAt?: SortOrder
    dischargedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: admissionsCountOrderByAggregateInput
    _avg?: admissionsAvgOrderByAggregateInput
    _max?: admissionsMaxOrderByAggregateInput
    _min?: admissionsMinOrderByAggregateInput
    _sum?: admissionsSumOrderByAggregateInput
  }

  export type admissionsScalarWhereWithAggregatesInput = {
    AND?: admissionsScalarWhereWithAggregatesInput | admissionsScalarWhereWithAggregatesInput[]
    OR?: admissionsScalarWhereWithAggregatesInput[]
    NOT?: admissionsScalarWhereWithAggregatesInput | admissionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"admissions"> | string
    patientId?: StringNullableWithAggregatesFilter<"admissions"> | string | null
    patient?: JsonNullableWithAggregatesFilter<"admissions">
    unit?: StringNullableWithAggregatesFilter<"admissions"> | string | null
    bedNumber?: IntNullableWithAggregatesFilter<"admissions"> | number | null
    reason?: StringNullableWithAggregatesFilter<"admissions"> | string | null
    status?: StringWithAggregatesFilter<"admissions"> | string
    admittedAt?: DateTimeWithAggregatesFilter<"admissions"> | Date | string
    dischargedAt?: DateTimeNullableWithAggregatesFilter<"admissions"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"admissions"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"admissions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"admissions"> | Date | string
  }

  export type drugsWhereInput = {
    AND?: drugsWhereInput | drugsWhereInput[]
    OR?: drugsWhereInput[]
    NOT?: drugsWhereInput | drugsWhereInput[]
    id?: StringFilter<"drugs"> | string
    name?: StringFilter<"drugs"> | string
    category?: StringNullableFilter<"drugs"> | string | null
    dosageForm?: StringNullableFilter<"drugs"> | string | null
    strength?: StringNullableFilter<"drugs"> | string | null
    unit?: StringNullableFilter<"drugs"> | string | null
    price?: FloatNullableFilter<"drugs"> | number | null
    quantityInStock?: IntFilter<"drugs"> | number
    reorderLevel?: IntFilter<"drugs"> | number
    isActive?: BoolFilter<"drugs"> | boolean
    createdAt?: DateTimeFilter<"drugs"> | Date | string
  }

  export type drugsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    dosageForm?: SortOrderInput | SortOrder
    strength?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    quantityInStock?: SortOrder
    reorderLevel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type drugsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: drugsWhereInput | drugsWhereInput[]
    OR?: drugsWhereInput[]
    NOT?: drugsWhereInput | drugsWhereInput[]
    name?: StringFilter<"drugs"> | string
    category?: StringNullableFilter<"drugs"> | string | null
    dosageForm?: StringNullableFilter<"drugs"> | string | null
    strength?: StringNullableFilter<"drugs"> | string | null
    unit?: StringNullableFilter<"drugs"> | string | null
    price?: FloatNullableFilter<"drugs"> | number | null
    quantityInStock?: IntFilter<"drugs"> | number
    reorderLevel?: IntFilter<"drugs"> | number
    isActive?: BoolFilter<"drugs"> | boolean
    createdAt?: DateTimeFilter<"drugs"> | Date | string
  }, "id">

  export type drugsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    dosageForm?: SortOrderInput | SortOrder
    strength?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    quantityInStock?: SortOrder
    reorderLevel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: drugsCountOrderByAggregateInput
    _avg?: drugsAvgOrderByAggregateInput
    _max?: drugsMaxOrderByAggregateInput
    _min?: drugsMinOrderByAggregateInput
    _sum?: drugsSumOrderByAggregateInput
  }

  export type drugsScalarWhereWithAggregatesInput = {
    AND?: drugsScalarWhereWithAggregatesInput | drugsScalarWhereWithAggregatesInput[]
    OR?: drugsScalarWhereWithAggregatesInput[]
    NOT?: drugsScalarWhereWithAggregatesInput | drugsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"drugs"> | string
    name?: StringWithAggregatesFilter<"drugs"> | string
    category?: StringNullableWithAggregatesFilter<"drugs"> | string | null
    dosageForm?: StringNullableWithAggregatesFilter<"drugs"> | string | null
    strength?: StringNullableWithAggregatesFilter<"drugs"> | string | null
    unit?: StringNullableWithAggregatesFilter<"drugs"> | string | null
    price?: FloatNullableWithAggregatesFilter<"drugs"> | number | null
    quantityInStock?: IntWithAggregatesFilter<"drugs"> | number
    reorderLevel?: IntWithAggregatesFilter<"drugs"> | number
    isActive?: BoolWithAggregatesFilter<"drugs"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"drugs"> | Date | string
  }

  export type lab_testsWhereInput = {
    AND?: lab_testsWhereInput | lab_testsWhereInput[]
    OR?: lab_testsWhereInput[]
    NOT?: lab_testsWhereInput | lab_testsWhereInput[]
    id?: StringFilter<"lab_tests"> | string
    name?: StringFilter<"lab_tests"> | string
    category?: StringNullableFilter<"lab_tests"> | string | null
    price?: FloatNullableFilter<"lab_tests"> | number | null
    turnaroundTime?: StringNullableFilter<"lab_tests"> | string | null
    isActive?: BoolFilter<"lab_tests"> | boolean
    createdAt?: DateTimeFilter<"lab_tests"> | Date | string
  }

  export type lab_testsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    turnaroundTime?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type lab_testsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: lab_testsWhereInput | lab_testsWhereInput[]
    OR?: lab_testsWhereInput[]
    NOT?: lab_testsWhereInput | lab_testsWhereInput[]
    name?: StringFilter<"lab_tests"> | string
    category?: StringNullableFilter<"lab_tests"> | string | null
    price?: FloatNullableFilter<"lab_tests"> | number | null
    turnaroundTime?: StringNullableFilter<"lab_tests"> | string | null
    isActive?: BoolFilter<"lab_tests"> | boolean
    createdAt?: DateTimeFilter<"lab_tests"> | Date | string
  }, "id">

  export type lab_testsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    turnaroundTime?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: lab_testsCountOrderByAggregateInput
    _avg?: lab_testsAvgOrderByAggregateInput
    _max?: lab_testsMaxOrderByAggregateInput
    _min?: lab_testsMinOrderByAggregateInput
    _sum?: lab_testsSumOrderByAggregateInput
  }

  export type lab_testsScalarWhereWithAggregatesInput = {
    AND?: lab_testsScalarWhereWithAggregatesInput | lab_testsScalarWhereWithAggregatesInput[]
    OR?: lab_testsScalarWhereWithAggregatesInput[]
    NOT?: lab_testsScalarWhereWithAggregatesInput | lab_testsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"lab_tests"> | string
    name?: StringWithAggregatesFilter<"lab_tests"> | string
    category?: StringNullableWithAggregatesFilter<"lab_tests"> | string | null
    price?: FloatNullableWithAggregatesFilter<"lab_tests"> | number | null
    turnaroundTime?: StringNullableWithAggregatesFilter<"lab_tests"> | string | null
    isActive?: BoolWithAggregatesFilter<"lab_tests"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"lab_tests"> | Date | string
  }

  export type announcementsWhereInput = {
    AND?: announcementsWhereInput | announcementsWhereInput[]
    OR?: announcementsWhereInput[]
    NOT?: announcementsWhereInput | announcementsWhereInput[]
    id?: StringFilter<"announcements"> | string
    title?: StringFilter<"announcements"> | string
    content?: StringNullableFilter<"announcements"> | string | null
    type?: StringFilter<"announcements"> | string
    createdBy?: StringNullableFilter<"announcements"> | string | null
    createdAt?: DateTimeFilter<"announcements"> | Date | string
  }

  export type announcementsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    type?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type announcementsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: announcementsWhereInput | announcementsWhereInput[]
    OR?: announcementsWhereInput[]
    NOT?: announcementsWhereInput | announcementsWhereInput[]
    title?: StringFilter<"announcements"> | string
    content?: StringNullableFilter<"announcements"> | string | null
    type?: StringFilter<"announcements"> | string
    createdBy?: StringNullableFilter<"announcements"> | string | null
    createdAt?: DateTimeFilter<"announcements"> | Date | string
  }, "id">

  export type announcementsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    type?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: announcementsCountOrderByAggregateInput
    _max?: announcementsMaxOrderByAggregateInput
    _min?: announcementsMinOrderByAggregateInput
  }

  export type announcementsScalarWhereWithAggregatesInput = {
    AND?: announcementsScalarWhereWithAggregatesInput | announcementsScalarWhereWithAggregatesInput[]
    OR?: announcementsScalarWhereWithAggregatesInput[]
    NOT?: announcementsScalarWhereWithAggregatesInput | announcementsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"announcements"> | string
    title?: StringWithAggregatesFilter<"announcements"> | string
    content?: StringNullableWithAggregatesFilter<"announcements"> | string | null
    type?: StringWithAggregatesFilter<"announcements"> | string
    createdBy?: StringNullableWithAggregatesFilter<"announcements"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"announcements"> | Date | string
  }

  export type voice_notesWhereInput = {
    AND?: voice_notesWhereInput | voice_notesWhereInput[]
    OR?: voice_notesWhereInput[]
    NOT?: voice_notesWhereInput | voice_notesWhereInput[]
    id?: StringFilter<"voice_notes"> | string
    patientId?: StringNullableFilter<"voice_notes"> | string | null
    patient?: JsonNullableFilter<"voice_notes">
    recipientRole?: StringNullableFilter<"voice_notes"> | string | null
    transcription?: StringNullableFilter<"voice_notes"> | string | null
    audioUrl?: StringNullableFilter<"voice_notes"> | string | null
    initials?: StringNullableFilter<"voice_notes"> | string | null
    createdBy?: StringNullableFilter<"voice_notes"> | string | null
    createdAt?: DateTimeFilter<"voice_notes"> | Date | string
  }

  export type voice_notesOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    recipientRole?: SortOrderInput | SortOrder
    transcription?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    initials?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type voice_notesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: voice_notesWhereInput | voice_notesWhereInput[]
    OR?: voice_notesWhereInput[]
    NOT?: voice_notesWhereInput | voice_notesWhereInput[]
    patientId?: StringNullableFilter<"voice_notes"> | string | null
    patient?: JsonNullableFilter<"voice_notes">
    recipientRole?: StringNullableFilter<"voice_notes"> | string | null
    transcription?: StringNullableFilter<"voice_notes"> | string | null
    audioUrl?: StringNullableFilter<"voice_notes"> | string | null
    initials?: StringNullableFilter<"voice_notes"> | string | null
    createdBy?: StringNullableFilter<"voice_notes"> | string | null
    createdAt?: DateTimeFilter<"voice_notes"> | Date | string
  }, "id">

  export type voice_notesOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    recipientRole?: SortOrderInput | SortOrder
    transcription?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    initials?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: voice_notesCountOrderByAggregateInput
    _max?: voice_notesMaxOrderByAggregateInput
    _min?: voice_notesMinOrderByAggregateInput
  }

  export type voice_notesScalarWhereWithAggregatesInput = {
    AND?: voice_notesScalarWhereWithAggregatesInput | voice_notesScalarWhereWithAggregatesInput[]
    OR?: voice_notesScalarWhereWithAggregatesInput[]
    NOT?: voice_notesScalarWhereWithAggregatesInput | voice_notesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"voice_notes"> | string
    patientId?: StringNullableWithAggregatesFilter<"voice_notes"> | string | null
    patient?: JsonNullableWithAggregatesFilter<"voice_notes">
    recipientRole?: StringNullableWithAggregatesFilter<"voice_notes"> | string | null
    transcription?: StringNullableWithAggregatesFilter<"voice_notes"> | string | null
    audioUrl?: StringNullableWithAggregatesFilter<"voice_notes"> | string | null
    initials?: StringNullableWithAggregatesFilter<"voice_notes"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"voice_notes"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"voice_notes"> | Date | string
  }

  export type medical_certificatesWhereInput = {
    AND?: medical_certificatesWhereInput | medical_certificatesWhereInput[]
    OR?: medical_certificatesWhereInput[]
    NOT?: medical_certificatesWhereInput | medical_certificatesWhereInput[]
    id?: StringFilter<"medical_certificates"> | string
    patientId?: StringNullableFilter<"medical_certificates"> | string | null
    patient?: JsonNullableFilter<"medical_certificates">
    type?: StringNullableFilter<"medical_certificates"> | string | null
    diagnosis?: StringNullableFilter<"medical_certificates"> | string | null
    daysOff?: IntNullableFilter<"medical_certificates"> | number | null
    startDate?: StringNullableFilter<"medical_certificates"> | string | null
    endDate?: StringNullableFilter<"medical_certificates"> | string | null
    notes?: StringNullableFilter<"medical_certificates"> | string | null
    issuedBy?: StringNullableFilter<"medical_certificates"> | string | null
    createdAt?: DateTimeFilter<"medical_certificates"> | Date | string
  }

  export type medical_certificatesOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    diagnosis?: SortOrderInput | SortOrder
    daysOff?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    issuedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type medical_certificatesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: medical_certificatesWhereInput | medical_certificatesWhereInput[]
    OR?: medical_certificatesWhereInput[]
    NOT?: medical_certificatesWhereInput | medical_certificatesWhereInput[]
    patientId?: StringNullableFilter<"medical_certificates"> | string | null
    patient?: JsonNullableFilter<"medical_certificates">
    type?: StringNullableFilter<"medical_certificates"> | string | null
    diagnosis?: StringNullableFilter<"medical_certificates"> | string | null
    daysOff?: IntNullableFilter<"medical_certificates"> | number | null
    startDate?: StringNullableFilter<"medical_certificates"> | string | null
    endDate?: StringNullableFilter<"medical_certificates"> | string | null
    notes?: StringNullableFilter<"medical_certificates"> | string | null
    issuedBy?: StringNullableFilter<"medical_certificates"> | string | null
    createdAt?: DateTimeFilter<"medical_certificates"> | Date | string
  }, "id">

  export type medical_certificatesOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    diagnosis?: SortOrderInput | SortOrder
    daysOff?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    issuedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: medical_certificatesCountOrderByAggregateInput
    _avg?: medical_certificatesAvgOrderByAggregateInput
    _max?: medical_certificatesMaxOrderByAggregateInput
    _min?: medical_certificatesMinOrderByAggregateInput
    _sum?: medical_certificatesSumOrderByAggregateInput
  }

  export type medical_certificatesScalarWhereWithAggregatesInput = {
    AND?: medical_certificatesScalarWhereWithAggregatesInput | medical_certificatesScalarWhereWithAggregatesInput[]
    OR?: medical_certificatesScalarWhereWithAggregatesInput[]
    NOT?: medical_certificatesScalarWhereWithAggregatesInput | medical_certificatesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"medical_certificates"> | string
    patientId?: StringNullableWithAggregatesFilter<"medical_certificates"> | string | null
    patient?: JsonNullableWithAggregatesFilter<"medical_certificates">
    type?: StringNullableWithAggregatesFilter<"medical_certificates"> | string | null
    diagnosis?: StringNullableWithAggregatesFilter<"medical_certificates"> | string | null
    daysOff?: IntNullableWithAggregatesFilter<"medical_certificates"> | number | null
    startDate?: StringNullableWithAggregatesFilter<"medical_certificates"> | string | null
    endDate?: StringNullableWithAggregatesFilter<"medical_certificates"> | string | null
    notes?: StringNullableWithAggregatesFilter<"medical_certificates"> | string | null
    issuedBy?: StringNullableWithAggregatesFilter<"medical_certificates"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"medical_certificates"> | Date | string
  }

  export type referral_lettersWhereInput = {
    AND?: referral_lettersWhereInput | referral_lettersWhereInput[]
    OR?: referral_lettersWhereInput[]
    NOT?: referral_lettersWhereInput | referral_lettersWhereInput[]
    id?: StringFilter<"referral_letters"> | string
    patientId?: StringNullableFilter<"referral_letters"> | string | null
    patient?: JsonNullableFilter<"referral_letters">
    referredTo?: StringNullableFilter<"referral_letters"> | string | null
    reason?: StringNullableFilter<"referral_letters"> | string | null
    diagnosis?: StringNullableFilter<"referral_letters"> | string | null
    notes?: StringNullableFilter<"referral_letters"> | string | null
    issuedBy?: StringNullableFilter<"referral_letters"> | string | null
    createdAt?: DateTimeFilter<"referral_letters"> | Date | string
  }

  export type referral_lettersOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    referredTo?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    diagnosis?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    issuedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type referral_lettersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: referral_lettersWhereInput | referral_lettersWhereInput[]
    OR?: referral_lettersWhereInput[]
    NOT?: referral_lettersWhereInput | referral_lettersWhereInput[]
    patientId?: StringNullableFilter<"referral_letters"> | string | null
    patient?: JsonNullableFilter<"referral_letters">
    referredTo?: StringNullableFilter<"referral_letters"> | string | null
    reason?: StringNullableFilter<"referral_letters"> | string | null
    diagnosis?: StringNullableFilter<"referral_letters"> | string | null
    notes?: StringNullableFilter<"referral_letters"> | string | null
    issuedBy?: StringNullableFilter<"referral_letters"> | string | null
    createdAt?: DateTimeFilter<"referral_letters"> | Date | string
  }, "id">

  export type referral_lettersOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    referredTo?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    diagnosis?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    issuedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: referral_lettersCountOrderByAggregateInput
    _max?: referral_lettersMaxOrderByAggregateInput
    _min?: referral_lettersMinOrderByAggregateInput
  }

  export type referral_lettersScalarWhereWithAggregatesInput = {
    AND?: referral_lettersScalarWhereWithAggregatesInput | referral_lettersScalarWhereWithAggregatesInput[]
    OR?: referral_lettersScalarWhereWithAggregatesInput[]
    NOT?: referral_lettersScalarWhereWithAggregatesInput | referral_lettersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"referral_letters"> | string
    patientId?: StringNullableWithAggregatesFilter<"referral_letters"> | string | null
    patient?: JsonNullableWithAggregatesFilter<"referral_letters">
    referredTo?: StringNullableWithAggregatesFilter<"referral_letters"> | string | null
    reason?: StringNullableWithAggregatesFilter<"referral_letters"> | string | null
    diagnosis?: StringNullableWithAggregatesFilter<"referral_letters"> | string | null
    notes?: StringNullableWithAggregatesFilter<"referral_letters"> | string | null
    issuedBy?: StringNullableWithAggregatesFilter<"referral_letters"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"referral_letters"> | Date | string
  }

  export type discharge_summariesWhereInput = {
    AND?: discharge_summariesWhereInput | discharge_summariesWhereInput[]
    OR?: discharge_summariesWhereInput[]
    NOT?: discharge_summariesWhereInput | discharge_summariesWhereInput[]
    id?: StringFilter<"discharge_summaries"> | string
    patientId?: StringNullableFilter<"discharge_summaries"> | string | null
    patient?: JsonNullableFilter<"discharge_summaries">
    admissionDate?: StringNullableFilter<"discharge_summaries"> | string | null
    dischargeDate?: StringNullableFilter<"discharge_summaries"> | string | null
    diagnosis?: StringNullableFilter<"discharge_summaries"> | string | null
    treatment?: StringNullableFilter<"discharge_summaries"> | string | null
    medications?: StringNullableFilter<"discharge_summaries"> | string | null
    followUp?: StringNullableFilter<"discharge_summaries"> | string | null
    notes?: StringNullableFilter<"discharge_summaries"> | string | null
    dischargedBy?: StringNullableFilter<"discharge_summaries"> | string | null
    createdAt?: DateTimeFilter<"discharge_summaries"> | Date | string
  }

  export type discharge_summariesOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    admissionDate?: SortOrderInput | SortOrder
    dischargeDate?: SortOrderInput | SortOrder
    diagnosis?: SortOrderInput | SortOrder
    treatment?: SortOrderInput | SortOrder
    medications?: SortOrderInput | SortOrder
    followUp?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    dischargedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type discharge_summariesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: discharge_summariesWhereInput | discharge_summariesWhereInput[]
    OR?: discharge_summariesWhereInput[]
    NOT?: discharge_summariesWhereInput | discharge_summariesWhereInput[]
    patientId?: StringNullableFilter<"discharge_summaries"> | string | null
    patient?: JsonNullableFilter<"discharge_summaries">
    admissionDate?: StringNullableFilter<"discharge_summaries"> | string | null
    dischargeDate?: StringNullableFilter<"discharge_summaries"> | string | null
    diagnosis?: StringNullableFilter<"discharge_summaries"> | string | null
    treatment?: StringNullableFilter<"discharge_summaries"> | string | null
    medications?: StringNullableFilter<"discharge_summaries"> | string | null
    followUp?: StringNullableFilter<"discharge_summaries"> | string | null
    notes?: StringNullableFilter<"discharge_summaries"> | string | null
    dischargedBy?: StringNullableFilter<"discharge_summaries"> | string | null
    createdAt?: DateTimeFilter<"discharge_summaries"> | Date | string
  }, "id">

  export type discharge_summariesOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    patient?: SortOrderInput | SortOrder
    admissionDate?: SortOrderInput | SortOrder
    dischargeDate?: SortOrderInput | SortOrder
    diagnosis?: SortOrderInput | SortOrder
    treatment?: SortOrderInput | SortOrder
    medications?: SortOrderInput | SortOrder
    followUp?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    dischargedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: discharge_summariesCountOrderByAggregateInput
    _max?: discharge_summariesMaxOrderByAggregateInput
    _min?: discharge_summariesMinOrderByAggregateInput
  }

  export type discharge_summariesScalarWhereWithAggregatesInput = {
    AND?: discharge_summariesScalarWhereWithAggregatesInput | discharge_summariesScalarWhereWithAggregatesInput[]
    OR?: discharge_summariesScalarWhereWithAggregatesInput[]
    NOT?: discharge_summariesScalarWhereWithAggregatesInput | discharge_summariesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"discharge_summaries"> | string
    patientId?: StringNullableWithAggregatesFilter<"discharge_summaries"> | string | null
    patient?: JsonNullableWithAggregatesFilter<"discharge_summaries">
    admissionDate?: StringNullableWithAggregatesFilter<"discharge_summaries"> | string | null
    dischargeDate?: StringNullableWithAggregatesFilter<"discharge_summaries"> | string | null
    diagnosis?: StringNullableWithAggregatesFilter<"discharge_summaries"> | string | null
    treatment?: StringNullableWithAggregatesFilter<"discharge_summaries"> | string | null
    medications?: StringNullableWithAggregatesFilter<"discharge_summaries"> | string | null
    followUp?: StringNullableWithAggregatesFilter<"discharge_summaries"> | string | null
    notes?: StringNullableWithAggregatesFilter<"discharge_summaries"> | string | null
    dischargedBy?: StringNullableWithAggregatesFilter<"discharge_summaries"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"discharge_summaries"> | Date | string
  }

  export type audit_logsWhereInput = {
    AND?: audit_logsWhereInput | audit_logsWhereInput[]
    OR?: audit_logsWhereInput[]
    NOT?: audit_logsWhereInput | audit_logsWhereInput[]
    id?: StringFilter<"audit_logs"> | string
    userId?: StringNullableFilter<"audit_logs"> | string | null
    userName?: StringNullableFilter<"audit_logs"> | string | null
    action?: StringFilter<"audit_logs"> | string
    description?: StringNullableFilter<"audit_logs"> | string | null
    metadata?: JsonNullableFilter<"audit_logs">
    timestamp?: DateTimeFilter<"audit_logs"> | Date | string
  }

  export type audit_logsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    action?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
  }

  export type audit_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: audit_logsWhereInput | audit_logsWhereInput[]
    OR?: audit_logsWhereInput[]
    NOT?: audit_logsWhereInput | audit_logsWhereInput[]
    userId?: StringNullableFilter<"audit_logs"> | string | null
    userName?: StringNullableFilter<"audit_logs"> | string | null
    action?: StringFilter<"audit_logs"> | string
    description?: StringNullableFilter<"audit_logs"> | string | null
    metadata?: JsonNullableFilter<"audit_logs">
    timestamp?: DateTimeFilter<"audit_logs"> | Date | string
  }, "id">

  export type audit_logsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    action?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: audit_logsCountOrderByAggregateInput
    _max?: audit_logsMaxOrderByAggregateInput
    _min?: audit_logsMinOrderByAggregateInput
  }

  export type audit_logsScalarWhereWithAggregatesInput = {
    AND?: audit_logsScalarWhereWithAggregatesInput | audit_logsScalarWhereWithAggregatesInput[]
    OR?: audit_logsScalarWhereWithAggregatesInput[]
    NOT?: audit_logsScalarWhereWithAggregatesInput | audit_logsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"audit_logs"> | string
    userId?: StringNullableWithAggregatesFilter<"audit_logs"> | string | null
    userName?: StringNullableWithAggregatesFilter<"audit_logs"> | string | null
    action?: StringWithAggregatesFilter<"audit_logs"> | string
    description?: StringNullableWithAggregatesFilter<"audit_logs"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"audit_logs">
    timestamp?: DateTimeWithAggregatesFilter<"audit_logs"> | Date | string
  }

  export type usersCreateInput = {
    id: string
    email: string
    name: string
    password: string
    role: string
    department?: string | null
    initials?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    isActive?: boolean
    isFirstLogin?: boolean
    approvalStatus?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type usersUncheckedCreateInput = {
    id: string
    email: string
    name: string
    password: string
    role: string
    department?: string | null
    initials?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    isActive?: boolean
    isFirstLogin?: boolean
    approvalStatus?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    approvalStatus?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    approvalStatus?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateManyInput = {
    id: string
    email: string
    name: string
    password: string
    role: string
    department?: string | null
    initials?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    isActive?: boolean
    isFirstLogin?: boolean
    approvalStatus?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    approvalStatus?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFirstLogin?: BoolFieldUpdateOperationsInput | boolean
    approvalStatus?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type patientsCreateInput = {
    id: string
    hospitalNumber?: string | null
    ruhcCode: string
    matricNumber?: string | null
    firstName: string
    lastName: string
    middleName?: string | null
    title?: string | null
    dateOfBirth?: string | null
    gender?: string | null
    bloodGroup?: string | null
    genotype?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    lga?: string | null
    nationality?: string | null
    religion?: string | null
    occupation?: string | null
    maritalStatus?: string | null
    nokName?: string | null
    nokRelationship?: string | null
    nokPhone?: string | null
    nokAddress?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelationship?: string | null
    insuranceNumber?: string | null
    insuranceProvider?: string | null
    allergies?: string | null
    chronicConditions?: string | null
    currentMedications?: string | null
    currentUnit?: string | null
    bedNumber?: number | null
    admissionDate?: Date | string | null
    dischargeDate?: Date | string | null
    isActive?: boolean
    registeredAt?: Date | string
    registeredBy?: string | null
    lastEditedBy?: string | null
    lastEditedAt?: Date | string | null
  }

  export type patientsUncheckedCreateInput = {
    id: string
    hospitalNumber?: string | null
    ruhcCode: string
    matricNumber?: string | null
    firstName: string
    lastName: string
    middleName?: string | null
    title?: string | null
    dateOfBirth?: string | null
    gender?: string | null
    bloodGroup?: string | null
    genotype?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    lga?: string | null
    nationality?: string | null
    religion?: string | null
    occupation?: string | null
    maritalStatus?: string | null
    nokName?: string | null
    nokRelationship?: string | null
    nokPhone?: string | null
    nokAddress?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelationship?: string | null
    insuranceNumber?: string | null
    insuranceProvider?: string | null
    allergies?: string | null
    chronicConditions?: string | null
    currentMedications?: string | null
    currentUnit?: string | null
    bedNumber?: number | null
    admissionDate?: Date | string | null
    dischargeDate?: Date | string | null
    isActive?: boolean
    registeredAt?: Date | string
    registeredBy?: string | null
    lastEditedBy?: string | null
    lastEditedAt?: Date | string | null
  }

  export type patientsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ruhcCode?: StringFieldUpdateOperationsInput | string
    matricNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nokName?: NullableStringFieldUpdateOperationsInput | string | null
    nokRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    nokPhone?: NullableStringFieldUpdateOperationsInput | string | null
    nokAddress?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    currentMedications?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bedNumber?: NullableIntFieldUpdateOperationsInput | number | null
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type patientsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ruhcCode?: StringFieldUpdateOperationsInput | string
    matricNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nokName?: NullableStringFieldUpdateOperationsInput | string | null
    nokRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    nokPhone?: NullableStringFieldUpdateOperationsInput | string | null
    nokAddress?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    currentMedications?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bedNumber?: NullableIntFieldUpdateOperationsInput | number | null
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type patientsCreateManyInput = {
    id: string
    hospitalNumber?: string | null
    ruhcCode: string
    matricNumber?: string | null
    firstName: string
    lastName: string
    middleName?: string | null
    title?: string | null
    dateOfBirth?: string | null
    gender?: string | null
    bloodGroup?: string | null
    genotype?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    lga?: string | null
    nationality?: string | null
    religion?: string | null
    occupation?: string | null
    maritalStatus?: string | null
    nokName?: string | null
    nokRelationship?: string | null
    nokPhone?: string | null
    nokAddress?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelationship?: string | null
    insuranceNumber?: string | null
    insuranceProvider?: string | null
    allergies?: string | null
    chronicConditions?: string | null
    currentMedications?: string | null
    currentUnit?: string | null
    bedNumber?: number | null
    admissionDate?: Date | string | null
    dischargeDate?: Date | string | null
    isActive?: boolean
    registeredAt?: Date | string
    registeredBy?: string | null
    lastEditedBy?: string | null
    lastEditedAt?: Date | string | null
  }

  export type patientsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ruhcCode?: StringFieldUpdateOperationsInput | string
    matricNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nokName?: NullableStringFieldUpdateOperationsInput | string | null
    nokRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    nokPhone?: NullableStringFieldUpdateOperationsInput | string | null
    nokAddress?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    currentMedications?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bedNumber?: NullableIntFieldUpdateOperationsInput | number | null
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type patientsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ruhcCode?: StringFieldUpdateOperationsInput | string
    matricNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    genotype?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nokName?: NullableStringFieldUpdateOperationsInput | string | null
    nokRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    nokPhone?: NullableStringFieldUpdateOperationsInput | string | null
    nokAddress?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelationship?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    chronicConditions?: NullableStringFieldUpdateOperationsInput | string | null
    currentMedications?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    bedNumber?: NullableIntFieldUpdateOperationsInput | number | null
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedBy?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type consultationsCreateInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    doctorId?: string | null
    doctorName?: string | null
    status?: string
    chiefComplaint?: string | null
    historyOfPresentIllness?: string | null
    pastMedicalHistory?: string | null
    signsAndSymptoms?: string | null
    bloodPressureSystolic?: string | null
    bloodPressureDiastolic?: string | null
    temperature?: string | null
    pulse?: string | null
    respiratoryRate?: string | null
    weight?: string | null
    height?: string | null
    oxygenSaturation?: string | null
    generalExamination?: string | null
    systemExamination?: string | null
    investigationsRequested?: NullableJsonNullValueInput | InputJsonValue
    scanRequested?: NullableJsonNullValueInput | InputJsonValue
    scanFindings?: string | null
    provisionalDiagnosis?: string | null
    finalDiagnosis?: string | null
    treatmentPlan?: string | null
    prescriptions?: NullableJsonNullValueInput | InputJsonValue
    referralTo?: string | null
    referralNotes?: string | null
    sendBackTo?: NullableJsonNullValueInput | InputJsonValue
    sendBackNotes?: string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type consultationsUncheckedCreateInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    doctorId?: string | null
    doctorName?: string | null
    status?: string
    chiefComplaint?: string | null
    historyOfPresentIllness?: string | null
    pastMedicalHistory?: string | null
    signsAndSymptoms?: string | null
    bloodPressureSystolic?: string | null
    bloodPressureDiastolic?: string | null
    temperature?: string | null
    pulse?: string | null
    respiratoryRate?: string | null
    weight?: string | null
    height?: string | null
    oxygenSaturation?: string | null
    generalExamination?: string | null
    systemExamination?: string | null
    investigationsRequested?: NullableJsonNullValueInput | InputJsonValue
    scanRequested?: NullableJsonNullValueInput | InputJsonValue
    scanFindings?: string | null
    provisionalDiagnosis?: string | null
    finalDiagnosis?: string | null
    treatmentPlan?: string | null
    prescriptions?: NullableJsonNullValueInput | InputJsonValue
    referralTo?: string | null
    referralNotes?: string | null
    sendBackTo?: NullableJsonNullValueInput | InputJsonValue
    sendBackNotes?: string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type consultationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    historyOfPresentIllness?: NullableStringFieldUpdateOperationsInput | string | null
    pastMedicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    signsAndSymptoms?: NullableStringFieldUpdateOperationsInput | string | null
    bloodPressureSystolic?: NullableStringFieldUpdateOperationsInput | string | null
    bloodPressureDiastolic?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    pulse?: NullableStringFieldUpdateOperationsInput | string | null
    respiratoryRate?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenSaturation?: NullableStringFieldUpdateOperationsInput | string | null
    generalExamination?: NullableStringFieldUpdateOperationsInput | string | null
    systemExamination?: NullableStringFieldUpdateOperationsInput | string | null
    investigationsRequested?: NullableJsonNullValueInput | InputJsonValue
    scanRequested?: NullableJsonNullValueInput | InputJsonValue
    scanFindings?: NullableStringFieldUpdateOperationsInput | string | null
    provisionalDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    finalDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentPlan?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptions?: NullableJsonNullValueInput | InputJsonValue
    referralTo?: NullableStringFieldUpdateOperationsInput | string | null
    referralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sendBackTo?: NullableJsonNullValueInput | InputJsonValue
    sendBackNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consultationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    historyOfPresentIllness?: NullableStringFieldUpdateOperationsInput | string | null
    pastMedicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    signsAndSymptoms?: NullableStringFieldUpdateOperationsInput | string | null
    bloodPressureSystolic?: NullableStringFieldUpdateOperationsInput | string | null
    bloodPressureDiastolic?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    pulse?: NullableStringFieldUpdateOperationsInput | string | null
    respiratoryRate?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenSaturation?: NullableStringFieldUpdateOperationsInput | string | null
    generalExamination?: NullableStringFieldUpdateOperationsInput | string | null
    systemExamination?: NullableStringFieldUpdateOperationsInput | string | null
    investigationsRequested?: NullableJsonNullValueInput | InputJsonValue
    scanRequested?: NullableJsonNullValueInput | InputJsonValue
    scanFindings?: NullableStringFieldUpdateOperationsInput | string | null
    provisionalDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    finalDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentPlan?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptions?: NullableJsonNullValueInput | InputJsonValue
    referralTo?: NullableStringFieldUpdateOperationsInput | string | null
    referralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sendBackTo?: NullableJsonNullValueInput | InputJsonValue
    sendBackNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consultationsCreateManyInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    doctorId?: string | null
    doctorName?: string | null
    status?: string
    chiefComplaint?: string | null
    historyOfPresentIllness?: string | null
    pastMedicalHistory?: string | null
    signsAndSymptoms?: string | null
    bloodPressureSystolic?: string | null
    bloodPressureDiastolic?: string | null
    temperature?: string | null
    pulse?: string | null
    respiratoryRate?: string | null
    weight?: string | null
    height?: string | null
    oxygenSaturation?: string | null
    generalExamination?: string | null
    systemExamination?: string | null
    investigationsRequested?: NullableJsonNullValueInput | InputJsonValue
    scanRequested?: NullableJsonNullValueInput | InputJsonValue
    scanFindings?: string | null
    provisionalDiagnosis?: string | null
    finalDiagnosis?: string | null
    treatmentPlan?: string | null
    prescriptions?: NullableJsonNullValueInput | InputJsonValue
    referralTo?: string | null
    referralNotes?: string | null
    sendBackTo?: NullableJsonNullValueInput | InputJsonValue
    sendBackNotes?: string | null
    sentAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type consultationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    historyOfPresentIllness?: NullableStringFieldUpdateOperationsInput | string | null
    pastMedicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    signsAndSymptoms?: NullableStringFieldUpdateOperationsInput | string | null
    bloodPressureSystolic?: NullableStringFieldUpdateOperationsInput | string | null
    bloodPressureDiastolic?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    pulse?: NullableStringFieldUpdateOperationsInput | string | null
    respiratoryRate?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenSaturation?: NullableStringFieldUpdateOperationsInput | string | null
    generalExamination?: NullableStringFieldUpdateOperationsInput | string | null
    systemExamination?: NullableStringFieldUpdateOperationsInput | string | null
    investigationsRequested?: NullableJsonNullValueInput | InputJsonValue
    scanRequested?: NullableJsonNullValueInput | InputJsonValue
    scanFindings?: NullableStringFieldUpdateOperationsInput | string | null
    provisionalDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    finalDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentPlan?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptions?: NullableJsonNullValueInput | InputJsonValue
    referralTo?: NullableStringFieldUpdateOperationsInput | string | null
    referralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sendBackTo?: NullableJsonNullValueInput | InputJsonValue
    sendBackNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consultationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    historyOfPresentIllness?: NullableStringFieldUpdateOperationsInput | string | null
    pastMedicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    signsAndSymptoms?: NullableStringFieldUpdateOperationsInput | string | null
    bloodPressureSystolic?: NullableStringFieldUpdateOperationsInput | string | null
    bloodPressureDiastolic?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    pulse?: NullableStringFieldUpdateOperationsInput | string | null
    respiratoryRate?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenSaturation?: NullableStringFieldUpdateOperationsInput | string | null
    generalExamination?: NullableStringFieldUpdateOperationsInput | string | null
    systemExamination?: NullableStringFieldUpdateOperationsInput | string | null
    investigationsRequested?: NullableJsonNullValueInput | InputJsonValue
    scanRequested?: NullableJsonNullValueInput | InputJsonValue
    scanFindings?: NullableStringFieldUpdateOperationsInput | string | null
    provisionalDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    finalDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentPlan?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptions?: NullableJsonNullValueInput | InputJsonValue
    referralTo?: NullableStringFieldUpdateOperationsInput | string | null
    referralNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sendBackTo?: NullableJsonNullValueInput | InputJsonValue
    sendBackNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vital_signsCreateInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    recordedBy?: string | null
    bloodPressureSystolic?: string | null
    bloodPressureDiastolic?: string | null
    temperature?: string | null
    pulse?: string | null
    respiratoryRate?: string | null
    weight?: string | null
    height?: string | null
    oxygenSaturation?: string | null
    painScore?: string | null
    notes?: string | null
    recordedAt?: Date | string
  }

  export type vital_signsUncheckedCreateInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    recordedBy?: string | null
    bloodPressureSystolic?: string | null
    bloodPressureDiastolic?: string | null
    temperature?: string | null
    pulse?: string | null
    respiratoryRate?: string | null
    weight?: string | null
    height?: string | null
    oxygenSaturation?: string | null
    painScore?: string | null
    notes?: string | null
    recordedAt?: Date | string
  }

  export type vital_signsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    bloodPressureSystolic?: NullableStringFieldUpdateOperationsInput | string | null
    bloodPressureDiastolic?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    pulse?: NullableStringFieldUpdateOperationsInput | string | null
    respiratoryRate?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenSaturation?: NullableStringFieldUpdateOperationsInput | string | null
    painScore?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vital_signsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    bloodPressureSystolic?: NullableStringFieldUpdateOperationsInput | string | null
    bloodPressureDiastolic?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    pulse?: NullableStringFieldUpdateOperationsInput | string | null
    respiratoryRate?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenSaturation?: NullableStringFieldUpdateOperationsInput | string | null
    painScore?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vital_signsCreateManyInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    recordedBy?: string | null
    bloodPressureSystolic?: string | null
    bloodPressureDiastolic?: string | null
    temperature?: string | null
    pulse?: string | null
    respiratoryRate?: string | null
    weight?: string | null
    height?: string | null
    oxygenSaturation?: string | null
    painScore?: string | null
    notes?: string | null
    recordedAt?: Date | string
  }

  export type vital_signsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    bloodPressureSystolic?: NullableStringFieldUpdateOperationsInput | string | null
    bloodPressureDiastolic?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    pulse?: NullableStringFieldUpdateOperationsInput | string | null
    respiratoryRate?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenSaturation?: NullableStringFieldUpdateOperationsInput | string | null
    painScore?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vital_signsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    bloodPressureSystolic?: NullableStringFieldUpdateOperationsInput | string | null
    bloodPressureDiastolic?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    pulse?: NullableStringFieldUpdateOperationsInput | string | null
    respiratoryRate?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
    oxygenSaturation?: NullableStringFieldUpdateOperationsInput | string | null
    painScore?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type lab_requestsCreateInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    requestedBy?: string | null
    tests?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    notes?: string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type lab_requestsUncheckedCreateInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    requestedBy?: string | null
    tests?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    notes?: string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type lab_requestsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tests?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type lab_requestsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tests?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type lab_requestsCreateManyInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    requestedBy?: string | null
    tests?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    notes?: string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type lab_requestsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tests?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type lab_requestsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tests?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type lab_resultsCreateInput = {
    id: string
    requestId?: string | null
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    testName?: string | null
    result?: string | null
    notes?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type lab_resultsUncheckedCreateInput = {
    id: string
    requestId?: string | null
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    testName?: string | null
    result?: string | null
    notes?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type lab_resultsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    testName?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type lab_resultsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    testName?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type lab_resultsCreateManyInput = {
    id: string
    requestId?: string | null
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    testName?: string | null
    result?: string | null
    notes?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type lab_resultsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    testName?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type lab_resultsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    testName?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prescriptionsCreateInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    prescribedBy?: string | null
    medications?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    notes?: string | null
    createdAt?: Date | string
    dispensedAt?: Date | string | null
  }

  export type prescriptionsUncheckedCreateInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    prescribedBy?: string | null
    medications?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    notes?: string | null
    createdAt?: Date | string
    dispensedAt?: Date | string | null
  }

  export type prescriptionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    prescribedBy?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type prescriptionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    prescribedBy?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type prescriptionsCreateManyInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    prescribedBy?: string | null
    medications?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    notes?: string | null
    createdAt?: Date | string
    dispensedAt?: Date | string | null
  }

  export type prescriptionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    prescribedBy?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type prescriptionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    prescribedBy?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dispensedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type queue_entriesCreateInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    unit?: string | null
    status?: string
    priority?: number
    notes?: string | null
    checkedInAt?: Date | string
    seenAt?: Date | string | null
  }

  export type queue_entriesUncheckedCreateInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    unit?: string | null
    status?: string
    priority?: number
    notes?: string | null
    checkedInAt?: Date | string
    seenAt?: Date | string | null
  }

  export type queue_entriesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type queue_entriesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type queue_entriesCreateManyInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    unit?: string | null
    status?: string
    priority?: number
    notes?: string | null
    checkedInAt?: Date | string
    seenAt?: Date | string | null
  }

  export type queue_entriesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type queue_entriesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type appointmentsCreateInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    doctorId?: string | null
    doctorName?: string | null
    type?: string | null
    reason?: string | null
    appointmentDate?: string | null
    startTime?: string | null
    endTime?: string | null
    status?: string
    notes?: string | null
    initials?: string | null
    createdAt?: Date | string
  }

  export type appointmentsUncheckedCreateInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    doctorId?: string | null
    doctorName?: string | null
    type?: string | null
    reason?: string | null
    appointmentDate?: string | null
    startTime?: string | null
    endTime?: string | null
    status?: string
    notes?: string | null
    initials?: string | null
    createdAt?: Date | string
  }

  export type appointmentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type appointmentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type appointmentsCreateManyInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    doctorId?: string | null
    doctorName?: string | null
    type?: string | null
    reason?: string | null
    appointmentDate?: string | null
    startTime?: string | null
    endTime?: string | null
    status?: string
    notes?: string | null
    initials?: string | null
    createdAt?: Date | string
  }

  export type appointmentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type appointmentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admissionsCreateInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    unit?: string | null
    bedNumber?: number | null
    reason?: string | null
    status?: string
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type admissionsUncheckedCreateInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    unit?: string | null
    bedNumber?: number | null
    reason?: string | null
    status?: string
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type admissionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    bedNumber?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admissionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    bedNumber?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admissionsCreateManyInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    unit?: string | null
    bedNumber?: number | null
    reason?: string | null
    status?: string
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type admissionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    bedNumber?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admissionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    bedNumber?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type drugsCreateInput = {
    id: string
    name: string
    category?: string | null
    dosageForm?: string | null
    strength?: string | null
    unit?: string | null
    price?: number | null
    quantityInStock?: number
    reorderLevel?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type drugsUncheckedCreateInput = {
    id: string
    name: string
    category?: string | null
    dosageForm?: string | null
    strength?: string | null
    unit?: string | null
    price?: number | null
    quantityInStock?: number
    reorderLevel?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type drugsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    quantityInStock?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type drugsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    quantityInStock?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type drugsCreateManyInput = {
    id: string
    name: string
    category?: string | null
    dosageForm?: string | null
    strength?: string | null
    unit?: string | null
    price?: number | null
    quantityInStock?: number
    reorderLevel?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type drugsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    quantityInStock?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type drugsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    quantityInStock?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type lab_testsCreateInput = {
    id: string
    name: string
    category?: string | null
    price?: number | null
    turnaroundTime?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type lab_testsUncheckedCreateInput = {
    id: string
    name: string
    category?: string | null
    price?: number | null
    turnaroundTime?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type lab_testsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    turnaroundTime?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type lab_testsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    turnaroundTime?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type lab_testsCreateManyInput = {
    id: string
    name: string
    category?: string | null
    price?: number | null
    turnaroundTime?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type lab_testsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    turnaroundTime?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type lab_testsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    turnaroundTime?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type announcementsCreateInput = {
    id: string
    title: string
    content?: string | null
    type?: string
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type announcementsUncheckedCreateInput = {
    id: string
    title: string
    content?: string | null
    type?: string
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type announcementsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type announcementsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type announcementsCreateManyInput = {
    id: string
    title: string
    content?: string | null
    type?: string
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type announcementsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type announcementsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type voice_notesCreateInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    recipientRole?: string | null
    transcription?: string | null
    audioUrl?: string | null
    initials?: string | null
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type voice_notesUncheckedCreateInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    recipientRole?: string | null
    transcription?: string | null
    audioUrl?: string | null
    initials?: string | null
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type voice_notesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    recipientRole?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type voice_notesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    recipientRole?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type voice_notesCreateManyInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    recipientRole?: string | null
    transcription?: string | null
    audioUrl?: string | null
    initials?: string | null
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type voice_notesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    recipientRole?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type voice_notesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    recipientRole?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    initials?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type medical_certificatesCreateInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    type?: string | null
    diagnosis?: string | null
    daysOff?: number | null
    startDate?: string | null
    endDate?: string | null
    notes?: string | null
    issuedBy?: string | null
    createdAt?: Date | string
  }

  export type medical_certificatesUncheckedCreateInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    type?: string | null
    diagnosis?: string | null
    daysOff?: number | null
    startDate?: string | null
    endDate?: string | null
    notes?: string | null
    issuedBy?: string | null
    createdAt?: Date | string
  }

  export type medical_certificatesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    type?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    daysOff?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    issuedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type medical_certificatesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    type?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    daysOff?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    issuedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type medical_certificatesCreateManyInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    type?: string | null
    diagnosis?: string | null
    daysOff?: number | null
    startDate?: string | null
    endDate?: string | null
    notes?: string | null
    issuedBy?: string | null
    createdAt?: Date | string
  }

  export type medical_certificatesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    type?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    daysOff?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    issuedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type medical_certificatesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    type?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    daysOff?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
    endDate?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    issuedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type referral_lettersCreateInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    referredTo?: string | null
    reason?: string | null
    diagnosis?: string | null
    notes?: string | null
    issuedBy?: string | null
    createdAt?: Date | string
  }

  export type referral_lettersUncheckedCreateInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    referredTo?: string | null
    reason?: string | null
    diagnosis?: string | null
    notes?: string | null
    issuedBy?: string | null
    createdAt?: Date | string
  }

  export type referral_lettersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    referredTo?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    issuedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type referral_lettersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    referredTo?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    issuedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type referral_lettersCreateManyInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    referredTo?: string | null
    reason?: string | null
    diagnosis?: string | null
    notes?: string | null
    issuedBy?: string | null
    createdAt?: Date | string
  }

  export type referral_lettersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    referredTo?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    issuedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type referral_lettersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    referredTo?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    issuedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type discharge_summariesCreateInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    admissionDate?: string | null
    dischargeDate?: string | null
    diagnosis?: string | null
    treatment?: string | null
    medications?: string | null
    followUp?: string | null
    notes?: string | null
    dischargedBy?: string | null
    createdAt?: Date | string
  }

  export type discharge_summariesUncheckedCreateInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    admissionDate?: string | null
    dischargeDate?: string | null
    diagnosis?: string | null
    treatment?: string | null
    medications?: string | null
    followUp?: string | null
    notes?: string | null
    dischargedBy?: string | null
    createdAt?: Date | string
  }

  export type discharge_summariesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    admissionDate?: NullableStringFieldUpdateOperationsInput | string | null
    dischargeDate?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    followUp?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dischargedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type discharge_summariesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    admissionDate?: NullableStringFieldUpdateOperationsInput | string | null
    dischargeDate?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    followUp?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dischargedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type discharge_summariesCreateManyInput = {
    id: string
    patientId?: string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    admissionDate?: string | null
    dischargeDate?: string | null
    diagnosis?: string | null
    treatment?: string | null
    medications?: string | null
    followUp?: string | null
    notes?: string | null
    dischargedBy?: string | null
    createdAt?: Date | string
  }

  export type discharge_summariesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    admissionDate?: NullableStringFieldUpdateOperationsInput | string | null
    dischargeDate?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    followUp?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dischargedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type discharge_summariesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: NullableJsonNullValueInput | InputJsonValue
    admissionDate?: NullableStringFieldUpdateOperationsInput | string | null
    dischargeDate?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    followUp?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dischargedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type audit_logsCreateInput = {
    id: string
    userId?: string | null
    userName?: string | null
    action: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type audit_logsUncheckedCreateInput = {
    id: string
    userId?: string | null
    userName?: string | null
    action: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type audit_logsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type audit_logsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type audit_logsCreateManyInput = {
    id: string
    userId?: string | null
    userName?: string | null
    action: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type audit_logsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type audit_logsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    department?: SortOrder
    initials?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    isActive?: SortOrder
    isFirstLogin?: SortOrder
    approvalStatus?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    department?: SortOrder
    initials?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    isActive?: SortOrder
    isFirstLogin?: SortOrder
    approvalStatus?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    department?: SortOrder
    initials?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    isActive?: SortOrder
    isFirstLogin?: SortOrder
    approvalStatus?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type patientsCountOrderByAggregateInput = {
    id?: SortOrder
    hospitalNumber?: SortOrder
    ruhcCode?: SortOrder
    matricNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    title?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    genotype?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    lga?: SortOrder
    nationality?: SortOrder
    religion?: SortOrder
    occupation?: SortOrder
    maritalStatus?: SortOrder
    nokName?: SortOrder
    nokRelationship?: SortOrder
    nokPhone?: SortOrder
    nokAddress?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    emergencyContactRelationship?: SortOrder
    insuranceNumber?: SortOrder
    insuranceProvider?: SortOrder
    allergies?: SortOrder
    chronicConditions?: SortOrder
    currentMedications?: SortOrder
    currentUnit?: SortOrder
    bedNumber?: SortOrder
    admissionDate?: SortOrder
    dischargeDate?: SortOrder
    isActive?: SortOrder
    registeredAt?: SortOrder
    registeredBy?: SortOrder
    lastEditedBy?: SortOrder
    lastEditedAt?: SortOrder
  }

  export type patientsAvgOrderByAggregateInput = {
    bedNumber?: SortOrder
  }

  export type patientsMaxOrderByAggregateInput = {
    id?: SortOrder
    hospitalNumber?: SortOrder
    ruhcCode?: SortOrder
    matricNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    title?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    genotype?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    lga?: SortOrder
    nationality?: SortOrder
    religion?: SortOrder
    occupation?: SortOrder
    maritalStatus?: SortOrder
    nokName?: SortOrder
    nokRelationship?: SortOrder
    nokPhone?: SortOrder
    nokAddress?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    emergencyContactRelationship?: SortOrder
    insuranceNumber?: SortOrder
    insuranceProvider?: SortOrder
    allergies?: SortOrder
    chronicConditions?: SortOrder
    currentMedications?: SortOrder
    currentUnit?: SortOrder
    bedNumber?: SortOrder
    admissionDate?: SortOrder
    dischargeDate?: SortOrder
    isActive?: SortOrder
    registeredAt?: SortOrder
    registeredBy?: SortOrder
    lastEditedBy?: SortOrder
    lastEditedAt?: SortOrder
  }

  export type patientsMinOrderByAggregateInput = {
    id?: SortOrder
    hospitalNumber?: SortOrder
    ruhcCode?: SortOrder
    matricNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    title?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    genotype?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    lga?: SortOrder
    nationality?: SortOrder
    religion?: SortOrder
    occupation?: SortOrder
    maritalStatus?: SortOrder
    nokName?: SortOrder
    nokRelationship?: SortOrder
    nokPhone?: SortOrder
    nokAddress?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    emergencyContactRelationship?: SortOrder
    insuranceNumber?: SortOrder
    insuranceProvider?: SortOrder
    allergies?: SortOrder
    chronicConditions?: SortOrder
    currentMedications?: SortOrder
    currentUnit?: SortOrder
    bedNumber?: SortOrder
    admissionDate?: SortOrder
    dischargeDate?: SortOrder
    isActive?: SortOrder
    registeredAt?: SortOrder
    registeredBy?: SortOrder
    lastEditedBy?: SortOrder
    lastEditedAt?: SortOrder
  }

  export type patientsSumOrderByAggregateInput = {
    bedNumber?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type consultationsCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    patient?: SortOrder
    doctorId?: SortOrder
    doctorName?: SortOrder
    status?: SortOrder
    chiefComplaint?: SortOrder
    historyOfPresentIllness?: SortOrder
    pastMedicalHistory?: SortOrder
    signsAndSymptoms?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    temperature?: SortOrder
    pulse?: SortOrder
    respiratoryRate?: SortOrder
    weight?: SortOrder
    height?: SortOrder
    oxygenSaturation?: SortOrder
    generalExamination?: SortOrder
    systemExamination?: SortOrder
    investigationsRequested?: SortOrder
    scanRequested?: SortOrder
    scanFindings?: SortOrder
    provisionalDiagnosis?: SortOrder
    finalDiagnosis?: SortOrder
    treatmentPlan?: SortOrder
    prescriptions?: SortOrder
    referralTo?: SortOrder
    referralNotes?: SortOrder
    sendBackTo?: SortOrder
    sendBackNotes?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type consultationsMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    doctorName?: SortOrder
    status?: SortOrder
    chiefComplaint?: SortOrder
    historyOfPresentIllness?: SortOrder
    pastMedicalHistory?: SortOrder
    signsAndSymptoms?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    temperature?: SortOrder
    pulse?: SortOrder
    respiratoryRate?: SortOrder
    weight?: SortOrder
    height?: SortOrder
    oxygenSaturation?: SortOrder
    generalExamination?: SortOrder
    systemExamination?: SortOrder
    scanFindings?: SortOrder
    provisionalDiagnosis?: SortOrder
    finalDiagnosis?: SortOrder
    treatmentPlan?: SortOrder
    referralTo?: SortOrder
    referralNotes?: SortOrder
    sendBackNotes?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type consultationsMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    doctorName?: SortOrder
    status?: SortOrder
    chiefComplaint?: SortOrder
    historyOfPresentIllness?: SortOrder
    pastMedicalHistory?: SortOrder
    signsAndSymptoms?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    temperature?: SortOrder
    pulse?: SortOrder
    respiratoryRate?: SortOrder
    weight?: SortOrder
    height?: SortOrder
    oxygenSaturation?: SortOrder
    generalExamination?: SortOrder
    systemExamination?: SortOrder
    scanFindings?: SortOrder
    provisionalDiagnosis?: SortOrder
    finalDiagnosis?: SortOrder
    treatmentPlan?: SortOrder
    referralTo?: SortOrder
    referralNotes?: SortOrder
    sendBackNotes?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type vital_signsCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    patient?: SortOrder
    recordedBy?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    temperature?: SortOrder
    pulse?: SortOrder
    respiratoryRate?: SortOrder
    weight?: SortOrder
    height?: SortOrder
    oxygenSaturation?: SortOrder
    painScore?: SortOrder
    notes?: SortOrder
    recordedAt?: SortOrder
  }

  export type vital_signsMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    recordedBy?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    temperature?: SortOrder
    pulse?: SortOrder
    respiratoryRate?: SortOrder
    weight?: SortOrder
    height?: SortOrder
    oxygenSaturation?: SortOrder
    painScore?: SortOrder
    notes?: SortOrder
    recordedAt?: SortOrder
  }

  export type vital_signsMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    recordedBy?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    temperature?: SortOrder
    pulse?: SortOrder
    respiratoryRate?: SortOrder
    weight?: SortOrder
    height?: SortOrder
    oxygenSaturation?: SortOrder
    painScore?: SortOrder
    notes?: SortOrder
    recordedAt?: SortOrder
  }

  export type lab_requestsCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    patient?: SortOrder
    requestedBy?: SortOrder
    tests?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type lab_requestsMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    requestedBy?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type lab_requestsMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    requestedBy?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type lab_resultsCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    patientId?: SortOrder
    patient?: SortOrder
    testName?: SortOrder
    result?: SortOrder
    notes?: SortOrder
    performedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type lab_resultsMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    patientId?: SortOrder
    testName?: SortOrder
    result?: SortOrder
    notes?: SortOrder
    performedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type lab_resultsMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    patientId?: SortOrder
    testName?: SortOrder
    result?: SortOrder
    notes?: SortOrder
    performedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type prescriptionsCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    patient?: SortOrder
    prescribedBy?: SortOrder
    medications?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    dispensedAt?: SortOrder
  }

  export type prescriptionsMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    prescribedBy?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    dispensedAt?: SortOrder
  }

  export type prescriptionsMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    prescribedBy?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    dispensedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type queue_entriesCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    patient?: SortOrder
    unit?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    notes?: SortOrder
    checkedInAt?: SortOrder
    seenAt?: SortOrder
  }

  export type queue_entriesAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type queue_entriesMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    unit?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    notes?: SortOrder
    checkedInAt?: SortOrder
    seenAt?: SortOrder
  }

  export type queue_entriesMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    unit?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    notes?: SortOrder
    checkedInAt?: SortOrder
    seenAt?: SortOrder
  }

  export type queue_entriesSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type appointmentsCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    patient?: SortOrder
    doctorId?: SortOrder
    doctorName?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    appointmentDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    initials?: SortOrder
    createdAt?: SortOrder
  }

  export type appointmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    doctorName?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    appointmentDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    initials?: SortOrder
    createdAt?: SortOrder
  }

  export type appointmentsMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    doctorName?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    appointmentDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    initials?: SortOrder
    createdAt?: SortOrder
  }

  export type admissionsCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    patient?: SortOrder
    unit?: SortOrder
    bedNumber?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    admittedAt?: SortOrder
    dischargedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type admissionsAvgOrderByAggregateInput = {
    bedNumber?: SortOrder
  }

  export type admissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    unit?: SortOrder
    bedNumber?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    admittedAt?: SortOrder
    dischargedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type admissionsMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    unit?: SortOrder
    bedNumber?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    admittedAt?: SortOrder
    dischargedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type admissionsSumOrderByAggregateInput = {
    bedNumber?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type drugsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    dosageForm?: SortOrder
    strength?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    quantityInStock?: SortOrder
    reorderLevel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type drugsAvgOrderByAggregateInput = {
    price?: SortOrder
    quantityInStock?: SortOrder
    reorderLevel?: SortOrder
  }

  export type drugsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    dosageForm?: SortOrder
    strength?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    quantityInStock?: SortOrder
    reorderLevel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type drugsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    dosageForm?: SortOrder
    strength?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    quantityInStock?: SortOrder
    reorderLevel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type drugsSumOrderByAggregateInput = {
    price?: SortOrder
    quantityInStock?: SortOrder
    reorderLevel?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type lab_testsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    price?: SortOrder
    turnaroundTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type lab_testsAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type lab_testsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    price?: SortOrder
    turnaroundTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type lab_testsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    price?: SortOrder
    turnaroundTime?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type lab_testsSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type announcementsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type announcementsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type announcementsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type voice_notesCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    patient?: SortOrder
    recipientRole?: SortOrder
    transcription?: SortOrder
    audioUrl?: SortOrder
    initials?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type voice_notesMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    recipientRole?: SortOrder
    transcription?: SortOrder
    audioUrl?: SortOrder
    initials?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type voice_notesMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    recipientRole?: SortOrder
    transcription?: SortOrder
    audioUrl?: SortOrder
    initials?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type medical_certificatesCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    patient?: SortOrder
    type?: SortOrder
    diagnosis?: SortOrder
    daysOff?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    notes?: SortOrder
    issuedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type medical_certificatesAvgOrderByAggregateInput = {
    daysOff?: SortOrder
  }

  export type medical_certificatesMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    diagnosis?: SortOrder
    daysOff?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    notes?: SortOrder
    issuedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type medical_certificatesMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    diagnosis?: SortOrder
    daysOff?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    notes?: SortOrder
    issuedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type medical_certificatesSumOrderByAggregateInput = {
    daysOff?: SortOrder
  }

  export type referral_lettersCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    patient?: SortOrder
    referredTo?: SortOrder
    reason?: SortOrder
    diagnosis?: SortOrder
    notes?: SortOrder
    issuedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type referral_lettersMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    referredTo?: SortOrder
    reason?: SortOrder
    diagnosis?: SortOrder
    notes?: SortOrder
    issuedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type referral_lettersMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    referredTo?: SortOrder
    reason?: SortOrder
    diagnosis?: SortOrder
    notes?: SortOrder
    issuedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type discharge_summariesCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    patient?: SortOrder
    admissionDate?: SortOrder
    dischargeDate?: SortOrder
    diagnosis?: SortOrder
    treatment?: SortOrder
    medications?: SortOrder
    followUp?: SortOrder
    notes?: SortOrder
    dischargedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type discharge_summariesMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    admissionDate?: SortOrder
    dischargeDate?: SortOrder
    diagnosis?: SortOrder
    treatment?: SortOrder
    medications?: SortOrder
    followUp?: SortOrder
    notes?: SortOrder
    dischargedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type discharge_summariesMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    admissionDate?: SortOrder
    dischargeDate?: SortOrder
    diagnosis?: SortOrder
    treatment?: SortOrder
    medications?: SortOrder
    followUp?: SortOrder
    notes?: SortOrder
    dischargedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type audit_logsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
  }

  export type audit_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
  }

  export type audit_logsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}